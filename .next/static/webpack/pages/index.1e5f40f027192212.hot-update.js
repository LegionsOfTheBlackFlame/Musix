"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./pages/index.jsx":
/*!*************************!*\
  !*** ./pages/index.jsx ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Home; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-three/fiber */ \"./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @react-three/drei */ \"./node_modules/@react-three/drei/index.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_examples_jsm_loaders_EXRLoader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three/examples/jsm/loaders/EXRLoader */ \"./node_modules/three/examples/jsm/loaders/EXRLoader.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/head */ \"./node_modules/next/head.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n// Globe Component\nconst Globe = ()=>{\n    _s();\n    // Textures for Ocean\n    const oceanTexture = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.useLoader)(three__WEBPACK_IMPORTED_MODULE_4__.TextureLoader, \"/textures/Ocean.jpg\");\n    // Textures for Land\n    const landDiffuse = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.useLoader)(three__WEBPACK_IMPORTED_MODULE_4__.TextureLoader, \"/textures/land/coast_sand_rocks_02_diff_4k.jpg\");\n    const landDisplacement = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.useLoader)(three__WEBPACK_IMPORTED_MODULE_4__.TextureLoader, \"/textures/land/coast_sand_rocks_02_disp_4k.png\");\n    const landRoughness = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.useLoader)(three_examples_jsm_loaders_EXRLoader__WEBPACK_IMPORTED_MODULE_5__.EXRLoader, \"/textures/land/coast_sand_rocks_02_rough_4k.exr\");\n    const landNormal = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.useLoader)(three_examples_jsm_loaders_EXRLoader__WEBPACK_IMPORTED_MODULE_5__.EXRLoader, \"/textures/land/coast_sand_rocks_02_nor_gl_4k.exr\");\n    // Textures for Snow\n    const snowDiffuse = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.useLoader)(three__WEBPACK_IMPORTED_MODULE_4__.TextureLoader, \"/textures/snow/snow_02_diff_4k.jpg\");\n    const snowDisplacement = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.useLoader)(three__WEBPACK_IMPORTED_MODULE_4__.TextureLoader, \"/textures/snow/snow_02_disp_4k.png\");\n    const snowRoughness = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.useLoader)(three__WEBPACK_IMPORTED_MODULE_4__.TextureLoader, \"/textures/snow/snow_02_rough_4k.jpg\");\n    const snowTranslucent = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.useLoader)(three__WEBPACK_IMPORTED_MODULE_4__.TextureLoader, \"/textures/snow/snow_02_translucent_4k.png\");\n    // Materials for Biomes\n    const materials = (0,react__WEBPACK_IMPORTED_MODULE_2__.useMemo)(()=>{\n        return {\n            ocean: new three__WEBPACK_IMPORTED_MODULE_4__.MeshStandardMaterial({\n                map: oceanTexture,\n                roughness: 0.5,\n                metalness: 0.5\n            }),\n            land: new three__WEBPACK_IMPORTED_MODULE_4__.MeshStandardMaterial({\n                map: landDiffuse,\n                displacementMap: landDisplacement,\n                displacementScale: 0.2,\n                normalMap: landNormal,\n                roughnessMap: landRoughness,\n                roughness: 0.4,\n                metalness: 0.2\n            }),\n            snow: new three__WEBPACK_IMPORTED_MODULE_4__.MeshStandardMaterial({\n                map: snowDiffuse,\n                displacementMap: snowDisplacement,\n                displacementScale: 0.1,\n                roughnessMap: snowRoughness,\n                roughness: 0.7,\n                metalness: 0.1,\n                alphaMap: snowTranslucent,\n                transparent: true\n            })\n        };\n    }, [\n        oceanTexture,\n        landDiffuse,\n        landDisplacement,\n        landRoughness,\n        landNormal,\n        snowDiffuse,\n        snowDisplacement,\n        snowRoughness,\n        snowTranslucent\n    ]);\n    // Biyom durumu kontrolü (ocean, land, snow)\n    const [biome, setBiome] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"ocean\");\n    // 10 saniyede bir biyomu değiştir\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        const interval = setInterval(()=>{\n            setBiome((prev)=>{\n                if (prev === \"ocean\") return \"land\";\n                if (prev === \"land\") return \"snow\";\n                return \"ocean\"; // Döngüye devam\n            });\n        }, 10000); // 10 saniye\n        return ()=>clearInterval(interval); // Temizleme işlemi\n    }, []);\n    // Küreyi çiz\n    const geometry = (0,react__WEBPACK_IMPORTED_MODULE_2__.useMemo)(()=>new three__WEBPACK_IMPORTED_MODULE_4__.SphereGeometry(2, 128, 128), []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n        geometry: geometry,\n        castShadow: true,\n        receiveShadow: true,\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meshStandardMaterial\", {\n            ...materials[biome]\n        }, void 0, false, {\n            fileName: \"/Users/ibrahimsumbul/Documents/GitHub/ibosoft/pages/index.jsx\",\n            lineNumber: 88,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/ibrahimsumbul/Documents/GitHub/ibosoft/pages/index.jsx\",\n        lineNumber: 86,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Globe, \"Se4OWeaQDQEqftLYkeHVWu04JdM=\", false, function() {\n    return [\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.useLoader,\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.useLoader,\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.useLoader,\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.useLoader,\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.useLoader,\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.useLoader,\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.useLoader,\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.useLoader,\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.useLoader\n    ];\n});\n_c = Globe;\n// Main Component\nfunction Home() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_1___default()), {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"title\", {\n                        children: \"Biome World\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ibrahimsumbul/Documents/GitHub/ibosoft/pages/index.jsx\",\n                        lineNumber: 98,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                        name: \"viewport\",\n                        content: \"width=device-width, initial-scale=1\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ibrahimsumbul/Documents/GitHub/ibosoft/pages/index.jsx\",\n                        lineNumber: 99,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ibrahimsumbul/Documents/GitHub/ibosoft/pages/index.jsx\",\n                lineNumber: 97,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.Canvas, {\n                style: {\n                    position: \"absolute\",\n                    top: 0,\n                    left: 0,\n                    width: \"100vw\",\n                    height: \"100vh\"\n                },\n                shadows: true,\n                camera: {\n                    position: [\n                        0,\n                        0,\n                        5\n                    ],\n                    fov: 50\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_drei__WEBPACK_IMPORTED_MODULE_6__.Environment, {\n                        preset: \"sunset\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ibrahimsumbul/Documents/GitHub/ibosoft/pages/index.jsx\",\n                        lineNumber: 113,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ambientLight\", {\n                        intensity: 0.5\n                    }, void 0, false, {\n                        fileName: \"/Users/ibrahimsumbul/Documents/GitHub/ibosoft/pages/index.jsx\",\n                        lineNumber: 114,\n                        columnNumber: 9\n                    }, this),\n                    \" \",\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"directionalLight\", {\n                        position: [\n                            5,\n                            5,\n                            5\n                        ],\n                        intensity: 1,\n                        castShadow: true\n                    }, void 0, false, {\n                        fileName: \"/Users/ibrahimsumbul/Documents/GitHub/ibosoft/pages/index.jsx\",\n                        lineNumber: 115,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Globe, {}, void 0, false, {\n                        fileName: \"/Users/ibrahimsumbul/Documents/GitHub/ibosoft/pages/index.jsx\",\n                        lineNumber: 116,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_drei__WEBPACK_IMPORTED_MODULE_6__.OrbitControls, {\n                        enableZoom: true,\n                        enableRotate: true,\n                        enablePan: false\n                    }, void 0, false, {\n                        fileName: \"/Users/ibrahimsumbul/Documents/GitHub/ibosoft/pages/index.jsx\",\n                        lineNumber: 117,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ibrahimsumbul/Documents/GitHub/ibosoft/pages/index.jsx\",\n                lineNumber: 101,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true);\n}\n_c1 = Home;\nvar _c, _c1;\n$RefreshReg$(_c, \"Globe\");\n$RefreshReg$(_c1, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Ozs7Ozs7Ozs7OzswQkFFaEMsOERBQUNuRCxzREFBTUE7Z0JBQ0xvRCxPQUFPO29CQUNMQyxVQUFVO29CQUNWQyxLQUFLO29CQUNMQyxNQUFNO29CQUNOQyxPQUFPO29CQUNQQyxRQUFRO2dCQUNWO2dCQUNBQyxPQUFPO2dCQUNQQyxRQUFRO29CQUFFTixVQUFVO3dCQUFDO3dCQUFHO3dCQUFHO3FCQUFFO29CQUFFTyxLQUFLO2dCQUFHOztrQ0FHdkMsOERBQUN6RCwwREFBV0E7d0JBQUMwRCxRQUFPOzs7Ozs7a0NBQ3BCLDhEQUFDQzt3QkFBYUMsV0FBVzs7Ozs7O29CQUFPO2tDQUNoQyw4REFBQ0M7d0JBQWlCWCxVQUFVOzRCQUFDOzRCQUFHOzRCQUFHO3lCQUFFO3dCQUFFVSxXQUFXO3dCQUFHbkIsVUFBVTs7Ozs7O2tDQUMvRCw4REFBQ2pDOzs7OztrQ0FDRCw4REFBQ1QsNERBQWFBO3dCQUFDK0QsVUFBVTt3QkFBQ0MsWUFBWTt3QkFBQ0MsV0FBVzs7Ozs7Ozs7Ozs7Ozs7QUFJMUQ7TUEzQndCcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcGFnZXMvaW5kZXguanN4PzdmZmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2FudmFzLCB1c2VMb2FkZXIgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuaW1wb3J0IHsgT3JiaXRDb250cm9scywgRW52aXJvbm1lbnQgfSBmcm9tICdAcmVhY3QtdGhyZWUvZHJlaSc7XG5pbXBvcnQgeyBUZXh0dXJlTG9hZGVyIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgRVhSTG9hZGVyIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvRVhSTG9hZGVyJztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCBIZWFkIGZyb20gJ25leHQvaGVhZCc7XG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuXG4vLyBHbG9iZSBDb21wb25lbnRcbmNvbnN0IEdsb2JlID0gKCkgPT4ge1xuICAvLyBUZXh0dXJlcyBmb3IgT2NlYW5cbiAgY29uc3Qgb2NlYW5UZXh0dXJlID0gdXNlTG9hZGVyKFRleHR1cmVMb2FkZXIsICcvdGV4dHVyZXMvT2NlYW4uanBnJyk7XG5cbiAgLy8gVGV4dHVyZXMgZm9yIExhbmRcbiAgY29uc3QgbGFuZERpZmZ1c2UgPSB1c2VMb2FkZXIoVGV4dHVyZUxvYWRlciwgJy90ZXh0dXJlcy9sYW5kL2NvYXN0X3NhbmRfcm9ja3NfMDJfZGlmZl80ay5qcGcnKTtcbiAgY29uc3QgbGFuZERpc3BsYWNlbWVudCA9IHVzZUxvYWRlcihUZXh0dXJlTG9hZGVyLCAnL3RleHR1cmVzL2xhbmQvY29hc3Rfc2FuZF9yb2Nrc18wMl9kaXNwXzRrLnBuZycpO1xuICBjb25zdCBsYW5kUm91Z2huZXNzID0gdXNlTG9hZGVyKEVYUkxvYWRlciwgJy90ZXh0dXJlcy9sYW5kL2NvYXN0X3NhbmRfcm9ja3NfMDJfcm91Z2hfNGsuZXhyJyk7XG4gIGNvbnN0IGxhbmROb3JtYWwgPSB1c2VMb2FkZXIoRVhSTG9hZGVyLCAnL3RleHR1cmVzL2xhbmQvY29hc3Rfc2FuZF9yb2Nrc18wMl9ub3JfZ2xfNGsuZXhyJyk7XG5cbiAgLy8gVGV4dHVyZXMgZm9yIFNub3dcbiAgY29uc3Qgc25vd0RpZmZ1c2UgPSB1c2VMb2FkZXIoVGV4dHVyZUxvYWRlciwgJy90ZXh0dXJlcy9zbm93L3Nub3dfMDJfZGlmZl80ay5qcGcnKTtcbiAgY29uc3Qgc25vd0Rpc3BsYWNlbWVudCA9IHVzZUxvYWRlcihUZXh0dXJlTG9hZGVyLCAnL3RleHR1cmVzL3Nub3cvc25vd18wMl9kaXNwXzRrLnBuZycpO1xuICBjb25zdCBzbm93Um91Z2huZXNzID0gdXNlTG9hZGVyKFRleHR1cmVMb2FkZXIsICcvdGV4dHVyZXMvc25vdy9zbm93XzAyX3JvdWdoXzRrLmpwZycpO1xuICBjb25zdCBzbm93VHJhbnNsdWNlbnQgPSB1c2VMb2FkZXIoVGV4dHVyZUxvYWRlciwgJy90ZXh0dXJlcy9zbm93L3Nub3dfMDJfdHJhbnNsdWNlbnRfNGsucG5nJyk7XG5cbiAgLy8gTWF0ZXJpYWxzIGZvciBCaW9tZXNcbiAgY29uc3QgbWF0ZXJpYWxzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9jZWFuOiBuZXcgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgICAgICBtYXA6IG9jZWFuVGV4dHVyZSxcbiAgICAgICAgcm91Z2huZXNzOiAwLjUsIC8vIERhaGEgcGFybGFrIHnDvHpleVxuICAgICAgICBtZXRhbG5lc3M6IDAuNSxcbiAgICAgIH0pLFxuICAgICAgbGFuZDogbmV3IFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsKHtcbiAgICAgICAgbWFwOiBsYW5kRGlmZnVzZSxcbiAgICAgICAgZGlzcGxhY2VtZW50TWFwOiBsYW5kRGlzcGxhY2VtZW50LFxuICAgICAgICBkaXNwbGFjZW1lbnRTY2FsZTogMC4yLCAvLyBLYWJhcnRtYSBlZmVrdGkgYXJ0xLFyxLFsZMSxXG4gICAgICAgIG5vcm1hbE1hcDogbGFuZE5vcm1hbCxcbiAgICAgICAgcm91Z2huZXNzTWFwOiBsYW5kUm91Z2huZXNzLFxuICAgICAgICByb3VnaG5lc3M6IDAuNCxcbiAgICAgICAgbWV0YWxuZXNzOiAwLjIsXG4gICAgICB9KSxcbiAgICAgIHNub3c6IG5ldyBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCh7XG4gICAgICAgIG1hcDogc25vd0RpZmZ1c2UsXG4gICAgICAgIGRpc3BsYWNlbWVudE1hcDogc25vd0Rpc3BsYWNlbWVudCxcbiAgICAgICAgZGlzcGxhY2VtZW50U2NhbGU6IDAuMSxcbiAgICAgICAgcm91Z2huZXNzTWFwOiBzbm93Um91Z2huZXNzLFxuICAgICAgICByb3VnaG5lc3M6IDAuNyxcbiAgICAgICAgbWV0YWxuZXNzOiAwLjEsXG4gICAgICAgIGFscGhhTWFwOiBzbm93VHJhbnNsdWNlbnQsXG4gICAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgfSksXG4gICAgfTtcbiAgfSwgW1xuICAgIG9jZWFuVGV4dHVyZSxcbiAgICBsYW5kRGlmZnVzZSxcbiAgICBsYW5kRGlzcGxhY2VtZW50LFxuICAgIGxhbmRSb3VnaG5lc3MsXG4gICAgbGFuZE5vcm1hbCxcbiAgICBzbm93RGlmZnVzZSxcbiAgICBzbm93RGlzcGxhY2VtZW50LFxuICAgIHNub3dSb3VnaG5lc3MsXG4gICAgc25vd1RyYW5zbHVjZW50LFxuICBdKTtcblxuICAvLyBCaXlvbSBkdXJ1bXUga29udHJvbMO8IChvY2VhbiwgbGFuZCwgc25vdylcbiAgY29uc3QgW2Jpb21lLCBzZXRCaW9tZV0gPSB1c2VTdGF0ZSgnb2NlYW4nKTtcblxuICAvLyAxMCBzYW5peWVkZSBiaXIgYml5b211IGRlxJ9pxZ90aXJcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHNldEJpb21lKChwcmV2KSA9PiB7XG4gICAgICAgIGlmIChwcmV2ID09PSAnb2NlYW4nKSByZXR1cm4gJ2xhbmQnO1xuICAgICAgICBpZiAocHJldiA9PT0gJ2xhbmQnKSByZXR1cm4gJ3Nub3cnO1xuICAgICAgICByZXR1cm4gJ29jZWFuJzsgLy8gRMO2bmfDvHllIGRldmFtXG4gICAgICB9KTtcbiAgICB9LCAxMDAwMCk7IC8vIDEwIHNhbml5ZVxuXG4gICAgcmV0dXJuICgpID0+IGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpOyAvLyBUZW1pemxlbWUgacWfbGVtaVxuICB9LCBbXSk7XG5cbiAgLy8gS8O8cmV5aSDDp2l6XG4gIGNvbnN0IGdlb21ldHJ5ID0gdXNlTWVtbygoKSA9PiBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoMiwgMTI4LCAxMjgpLCBbXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8bWVzaCBnZW9tZXRyeT17Z2VvbWV0cnl9IGNhc3RTaGFkb3cgcmVjZWl2ZVNoYWRvdz5cbiAgICAgIHsvKiBEaW5hbWlrIGJpeW9tIG1hbHplbWVzaSAqL31cbiAgICAgIDxtZXNoU3RhbmRhcmRNYXRlcmlhbCB7Li4ubWF0ZXJpYWxzW2Jpb21lXX0gLz5cbiAgICA8L21lc2g+XG4gICk7XG59O1xuXG4vLyBNYWluIENvbXBvbmVudFxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSG9tZSgpIHtcbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPEhlYWQ+XG4gICAgICAgIDx0aXRsZT5CaW9tZSBXb3JsZDwvdGl0bGU+XG4gICAgICAgIDxtZXRhIG5hbWU9XCJ2aWV3cG9ydFwiIGNvbnRlbnQ9XCJ3aWR0aD1kZXZpY2Utd2lkdGgsIGluaXRpYWwtc2NhbGU9MVwiIC8+XG4gICAgICA8L0hlYWQ+XG4gICAgICA8Q2FudmFzXG4gICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgd2lkdGg6ICcxMDB2dycsXG4gICAgICAgICAgaGVpZ2h0OiAnMTAwdmgnLFxuICAgICAgICB9fVxuICAgICAgICBzaGFkb3dzXG4gICAgICAgIGNhbWVyYT17eyBwb3NpdGlvbjogWzAsIDAsIDVdLCBmb3Y6IDUwIH19XG4gICAgICA+XG4gICAgICAgIHsvKiBPcnRhbWEgZWsgxLHFn8SxayBrYXluYWtsYXLEsSBla2xleWVsaW0gKi99XG4gICAgICAgIDxFbnZpcm9ubWVudCBwcmVzZXQ9XCJzdW5zZXRcIiAvPlxuICAgICAgICA8YW1iaWVudExpZ2h0IGludGVuc2l0eT17MC41fSAvPiB7LyogR2VuZWwgYXlkxLFubGF0bWEgKi99XG4gICAgICAgIDxkaXJlY3Rpb25hbExpZ2h0IHBvc2l0aW9uPXtbNSwgNSwgNV19IGludGVuc2l0eT17MX0gY2FzdFNoYWRvdyAvPlxuICAgICAgICA8R2xvYmUgLz5cbiAgICAgICAgPE9yYml0Q29udHJvbHMgZW5hYmxlWm9vbSBlbmFibGVSb3RhdGUgZW5hYmxlUGFuPXtmYWxzZX0gLz5cbiAgICAgIDwvQ2FudmFzPlxuICAgIDwvPlxuICApO1xufSJdLCJuYW1lcyI6WyJDYW52YXMiLCJ1c2VMb2FkZXIiLCJPcmJpdENvbnRyb2xzIiwiRW52aXJvbm1lbnQiLCJUZXh0dXJlTG9hZGVyIiwiRVhSTG9hZGVyIiwiVEhSRUUiLCJIZWFkIiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VNZW1vIiwiR2xvYmUiLCJvY2VhblRleHR1cmUiLCJsYW5kRGlmZnVzZSIsImxhbmREaXNwbGFjZW1lbnQiLCJsYW5kUm91Z2huZXNzIiwibGFuZE5vcm1hbCIsInNub3dEaWZmdXNlIiwic25vd0Rpc3BsYWNlbWVudCIsInNub3dSb3VnaG5lc3MiLCJzbm93VHJhbnNsdWNlbnQiLCJtYXRlcmlhbHMiLCJvY2VhbiIsIk1lc2hTdGFuZGFyZE1hdGVyaWFsIiwibWFwIiwicm91Z2huZXNzIiwibWV0YWxuZXNzIiwibGFuZCIsImRpc3BsYWNlbWVudE1hcCIsImRpc3BsYWNlbWVudFNjYWxlIiwibm9ybWFsTWFwIiwicm91Z2huZXNzTWFwIiwic25vdyIsImFscGhhTWFwIiwidHJhbnNwYXJlbnQiLCJiaW9tZSIsInNldEJpb21lIiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsInByZXYiLCJjbGVhckludGVydmFsIiwiZ2VvbWV0cnkiLCJTcGhlcmVHZW9tZXRyeSIsIm1lc2giLCJjYXN0U2hhZG93IiwicmVjZWl2ZVNoYWRvdyIsIm1lc2hTdGFuZGFyZE1hdGVyaWFsIiwiSG9tZSIsInRpdGxlIiwibWV0YSIsIm5hbWUiLCJjb250ZW50Iiwic3R5bGUiLCJwb3NpdGlvbiIsInRvcCIsImxlZnQiLCJ3aWR0aCIsImhlaWdodCIsInNoYWRvd3MiLCJjYW1lcmEiLCJmb3YiLCJwcmVzZXQiLCJhbWJpZW50TGlnaHQiLCJpbnRlbnNpdHkiLCJkaXJlY3Rpb25hbExpZ2h0IiwiZW5hYmxlWm9vbSIsImVuYWJsZVJvdGF0ZSIsImVuYWJsZVBhbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pages/index.jsx\n"));

/***/ }),

/***/ "./node_modules/three/examples/jsm/libs/fflate.module.js":
/*!***************************************************************!*\
  !*** ./node_modules/three/examples/jsm/libs/fflate.module.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncCompress: function() { return /* binding */ AsyncGzip; },\n/* harmony export */   AsyncDecompress: function() { return /* binding */ AsyncDecompress; },\n/* harmony export */   AsyncDeflate: function() { return /* binding */ AsyncDeflate; },\n/* harmony export */   AsyncGunzip: function() { return /* binding */ AsyncGunzip; },\n/* harmony export */   AsyncGzip: function() { return /* binding */ AsyncGzip; },\n/* harmony export */   AsyncInflate: function() { return /* binding */ AsyncInflate; },\n/* harmony export */   AsyncUnzipInflate: function() { return /* binding */ AsyncUnzipInflate; },\n/* harmony export */   AsyncUnzlib: function() { return /* binding */ AsyncUnzlib; },\n/* harmony export */   AsyncZipDeflate: function() { return /* binding */ AsyncZipDeflate; },\n/* harmony export */   AsyncZlib: function() { return /* binding */ AsyncZlib; },\n/* harmony export */   Compress: function() { return /* binding */ Gzip; },\n/* harmony export */   DecodeUTF8: function() { return /* binding */ DecodeUTF8; },\n/* harmony export */   Decompress: function() { return /* binding */ Decompress; },\n/* harmony export */   Deflate: function() { return /* binding */ Deflate; },\n/* harmony export */   EncodeUTF8: function() { return /* binding */ EncodeUTF8; },\n/* harmony export */   Gunzip: function() { return /* binding */ Gunzip; },\n/* harmony export */   Gzip: function() { return /* binding */ Gzip; },\n/* harmony export */   Inflate: function() { return /* binding */ Inflate; },\n/* harmony export */   Unzip: function() { return /* binding */ Unzip; },\n/* harmony export */   UnzipInflate: function() { return /* binding */ UnzipInflate; },\n/* harmony export */   UnzipPassThrough: function() { return /* binding */ UnzipPassThrough; },\n/* harmony export */   Unzlib: function() { return /* binding */ Unzlib; },\n/* harmony export */   Zip: function() { return /* binding */ Zip; },\n/* harmony export */   ZipDeflate: function() { return /* binding */ ZipDeflate; },\n/* harmony export */   ZipPassThrough: function() { return /* binding */ ZipPassThrough; },\n/* harmony export */   Zlib: function() { return /* binding */ Zlib; },\n/* harmony export */   compress: function() { return /* binding */ gzip; },\n/* harmony export */   compressSync: function() { return /* binding */ gzipSync; },\n/* harmony export */   decompress: function() { return /* binding */ decompress; },\n/* harmony export */   decompressSync: function() { return /* binding */ decompressSync; },\n/* harmony export */   deflate: function() { return /* binding */ deflate; },\n/* harmony export */   deflateSync: function() { return /* binding */ deflateSync; },\n/* harmony export */   gunzip: function() { return /* binding */ gunzip; },\n/* harmony export */   gunzipSync: function() { return /* binding */ gunzipSync; },\n/* harmony export */   gzip: function() { return /* binding */ gzip; },\n/* harmony export */   gzipSync: function() { return /* binding */ gzipSync; },\n/* harmony export */   inflate: function() { return /* binding */ inflate; },\n/* harmony export */   inflateSync: function() { return /* binding */ inflateSync; },\n/* harmony export */   strFromU8: function() { return /* binding */ strFromU8; },\n/* harmony export */   strToU8: function() { return /* binding */ strToU8; },\n/* harmony export */   unzip: function() { return /* binding */ unzip; },\n/* harmony export */   unzipSync: function() { return /* binding */ unzipSync; },\n/* harmony export */   unzlib: function() { return /* binding */ unzlib; },\n/* harmony export */   unzlibSync: function() { return /* binding */ unzlibSync; },\n/* harmony export */   zip: function() { return /* binding */ zip; },\n/* harmony export */   zipSync: function() { return /* binding */ zipSync; },\n/* harmony export */   zlib: function() { return /* binding */ zlib; },\n/* harmony export */   zlibSync: function() { return /* binding */ zlibSync; }\n/* harmony export */ });\n/*!\nfflate - fast JavaScript compression/decompression\n<https://101arrowz.github.io/fflate>\nLicensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE\nversion 0.6.9\n*/\n\n// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar ch2 = {};\nvar durl = function (c) { return URL.createObjectURL(new Blob([c], { type: 'text/javascript' })); };\nvar cwk = function (u) { return new Worker(u); };\ntry {\n    URL.revokeObjectURL(durl(''));\n}\ncatch (e) {\n    // We're in Deno or a very old browser\n    durl = function (c) { return 'data:application/javascript;charset=UTF-8,' + encodeURI(c); };\n    // If Deno, this is necessary; if not, this changes nothing\n    cwk = function (u) { return new Worker(u, { type: 'module' }); };\n}\nvar wk = (function (c, id, msg, transfer, cb) {\n    var w = cwk(ch2[id] || (ch2[id] = durl(c)));\n    w.onerror = function (e) { return cb(e.error, null); };\n    w.onmessage = function (e) { return cb(null, e.data); };\n    w.postMessage(msg, transfer);\n    return w;\n});\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\n// see fleb note\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new u32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return [b, r];\n};\nvar _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i)\n        ++l[cd[i] - 1];\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 0; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >>> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i) {\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);\n            }\n        }\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p / 8) | 0) + (p & 7 && 1); };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);\n    n.set(v.subarray(s, e));\n    return n;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, buf, st) {\n    // source length\n    var sl = dat.length;\n    if (!sl || (st && !st.l && sl < 5))\n        return buf || new u8(0);\n    // have to estimate size\n    var noBuf = !buf || st;\n    // no state\n    var noSt = !st || st.i;\n    if (!st)\n        st = {};\n    // Assumes roughly 33% compression ratio average\n    if (!buf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            st.f = final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        throw 'unexpected EOF';\n                    break;\n                }\n                // ensure size\n                if (noBuf)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >>> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                throw 'invalid block type';\n            if (pos > tbts) {\n                if (noSt)\n                    throw 'unexpected EOF';\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17;\n        if (noBuf)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for (;; lpos = pos) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt)\n                    throw 'unexpected EOF';\n                break;\n            }\n            if (!c)\n                throw 'invalid length/literal';\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n                if (!d)\n                    throw 'invalid distance';\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt)\n                        throw 'unexpected EOF';\n                    break;\n                }\n                if (noBuf)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                for (; bt < end; bt += 4) {\n                    buf[bt] = buf[bt - dt];\n                    buf[bt + 1] = buf[bt + 1 - dt];\n                    buf[bt + 2] = buf[bt + 2 - dt];\n                    buf[bt + 3] = buf[bt + 3 - dt];\n                }\n                bt = end;\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    return bt == buf.length ? buf : slc(buf, 0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n    d[o + 2] |= v >>> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return [et, 0];\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return [v, 1];\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return [new u8(tr), mbt];\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return [cl.subarray(0, cli), s];\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >>> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];\n    var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];\n    var _c = lc(dlt), lclt = _c[0], nlc = _c[1];\n    var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        lcfreq[lclt[i] & 31]++;\n    for (var i = 0; i < lcdt.length; ++i)\n        lcfreq[lcdt[i] & 31]++;\n    var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n    if (flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >>> 5) & 127), p += clct[i] >>> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        if (syms[i] > 255) {\n            var len = (syms[i] >>> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (syms[i] >>> 23) & 31), p += fleb[len];\n            var dst = syms[i] & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (syms[i] >>> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, lst) {\n    var s = dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var pos = 0;\n    if (!lvl || s < 8) {\n        for (var i = 0; i <= s; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e < s) {\n                // write full block\n                pos = wfblk(w, pos, dat.subarray(i, e));\n            }\n            else {\n                // write final block\n                w[i] = lst;\n                pos = wfblk(w, pos, dat.subarray(i, s));\n            }\n        }\n    }\n    else {\n        var opt = deo[lvl - 1];\n        var n = opt >>> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = new u16(32768), head = new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new u32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n        var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;\n        for (; i < s; ++i) {\n            // hash value\n            // deopt when i > s - 3 - at end, deopt acceptable\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && rem > 423) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = (imod - pimod) & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = (i - dif + j + 32768) & 32767;\n                                    var pti = prev[ti];\n                                    var cd = (ti - pti + 32768) & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += (imod - pimod + 32768) & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one Uint32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        // this is the easiest way to avoid needing to maintain state\n        if (!lst && pos & 7)\n            pos = wfblk(w, pos + 1, et);\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n    var t = new u32(256);\n    for (var i = 0; i < 256; ++i) {\n        var c = i, k = 9;\n        while (--k)\n            c = ((c & 1) && 0xEDB88320) ^ (c >>> 1);\n        t[i] = c;\n    }\n    return t;\n})();\n// CRC32\nvar crc = function () {\n    var c = -1;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return ~c; }\n    };\n};\n// Alder32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 2655, l);\n                for (; i < e; ++i)\n                    m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function () {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | (a >>> 8) << 16 | (b & 255) << 8 | (b >>> 8);\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : (12 + opt.mem), pre, post, !st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/ /g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return [fnStr, td];\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k] instanceof u8 || v[k] instanceof u16 || v[k] instanceof u32)\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    var _a;\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            _a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];\n        ch[id] = wcln(fns[m], fnStr, td_1);\n    }\n    var td = mrg({}, ch[id][1]);\n    return wk(ch[id][0] + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, hMap, max, bits, bits16, shft, slc, inflt, inflateSync, pbf, gu8]; };\nvar bDflt = function () { return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zlv]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get u8\nvar gu8 = function (o) { return o && o.size && new u8(o.size); };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) { return strm.push(ev.data[0], ev.data[1]); };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.push = function (d, f) {\n        if (t)\n            throw 'stream finished';\n        if (!strm.ondata)\n            throw 'no stream handler';\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };\nvar b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        throw 'invalid gzip data';\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += d[10] | (d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return ((d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16) | (d[l - 1] << 24)) >>> 0;\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + ((o.filename && (o.filename.length + 1)) || 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (fl ? (32 - 2 * fl) : 1);\n};\n// zlib valid\nvar zlv = function (d) {\n    if ((d[0] & 15) != 8 || (d[0] >>> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        throw 'invalid zlib data';\n    if (d[1] & 32)\n        throw 'invalid zlib data: preset dictionaries not supported';\n};\nfunction AsyncCmpStrm(opts, cb) {\n    if (!cb && typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n// zlib footer: -4 to -0 is Adler32\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (!cb && typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, !f), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (this.d)\n            throw 'stream finished';\n        if (!this.ondata)\n            throw 'no stream handler';\n        this.d = final;\n        this.p(chunk, final || false);\n    };\n    return Deflate;\n}());\n\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6);\n    }\n    return AsyncDeflate;\n}());\n\nfunction deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nfunction deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an inflation stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Inflate(cb) {\n        this.s = {};\n        this.p = new u8(0);\n        this.ondata = cb;\n    }\n    Inflate.prototype.e = function (c) {\n        if (this.d)\n            throw 'stream finished';\n        if (!this.ondata)\n            throw 'no stream handler';\n        var l = this.p.length;\n        var n = new u8(l + c.length);\n        n.set(this.p), n.set(c, l), this.p = n;\n    };\n    Inflate.prototype.c = function (final) {\n        this.d = this.s.i = final || false;\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.o, this.s);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\n\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous inflation stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncInflate(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, 0, function () {\n            var strm = new Inflate();\n            onmessage = astrm(strm);\n        }, 7);\n    }\n    return AsyncInflate;\n}());\n\nfunction inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gu8(ev.data[1]))); }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nfunction inflateSync(data, out) {\n    return inflt(data, out);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        this.c.p(c);\n        this.l += c.length;\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    return Gzip;\n}());\n\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8);\n    }\n    return AsyncGzip;\n}());\n\nfunction gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nfunction gzipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a GUNZIP stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Gunzip(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            var s = this.p.length > 3 ? gzs(this.p) : 4;\n            if (s >= this.p.length && !final)\n                return;\n            this.p = this.p.subarray(s), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 8)\n                throw 'invalid gzip stream';\n            this.p = this.p.subarray(0, -8);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Gunzip;\n}());\n\n/**\n * Asynchronous streaming GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous GUNZIP stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncGunzip(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, 0, function () {\n            var strm = new Gunzip();\n            onmessage = astrm(strm);\n        }, 9);\n    }\n    return AsyncGunzip;\n}());\n\nfunction gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0])); }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.\n * @returns The decompressed version of the data\n */\nfunction gunzipSync(data, out) {\n    return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));\n}\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        this.c.p(c);\n        var raw = dopt(c, this.o, this.v && 2, f && 4, !f);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    return Zlib;\n}());\n\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10);\n    }\n    return AsyncZlib;\n}());\n\nfunction zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nfunction zlibSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates a Zlib decompression stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Unzlib(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 2 && !final)\n                return;\n            this.p = this.p.subarray(2), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4)\n                throw 'invalid zlib stream';\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\n\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous Zlib decompression stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncUnzlib(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, 0, function () {\n            var strm = new Unzlib();\n            onmessage = astrm(strm);\n        }, 11);\n    }\n    return AsyncUnzlib;\n}());\n\nfunction unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gu8(ev.data[1]))); }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nfunction unzlibSync(data, out) {\n    return inflt((zlv(data), data.subarray(2, -4)), out);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\n\n// Default algorithm for compression (used because having a known output size allows faster decompression)\n\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    /**\n     * Creates a decompression stream\n     * @param cb The callback to call whenever data is decompressed\n     */\n    function Decompress(cb) {\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no stream handler';\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                var _this_1 = this;\n                var cb = function () { _this_1.ondata.apply(_this_1, arguments); };\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(cb)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(cb)\n                        : new this.Z(cb);\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\n\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    /**\n   * Creates an asynchronous decompression stream\n   * @param cb The callback to call whenever data is decompressed\n   */\n    function AsyncDecompress(cb) {\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\n\nfunction decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nfunction decompressSync(data, out) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, out)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, out)\n            : unzlibSync(data, out);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k;\n        if (val instanceof u8)\n            t[n] = [val, o];\n        else if (Array.isArray(val))\n            t[n] = [val[0], mrg(o, val[1])];\n        else\n            fltn(val, n + '/', t, o);\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, { stream: true });\n    tds = 1;\n}\ncatch (e) { }\n// decode UTF8\nvar dutf8 = function (d) {\n    for (var r = '', i = 0;;) {\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length)\n            return [r, slc(d, i - 1)];\n        if (!eb)\n            r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n        }\n        else if (eb & 1)\n            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\n        else\n            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */\nvar DecodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */\n    function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds)\n            this.t = new TextDecoder();\n        else\n            this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    DecodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no callback';\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, { stream: true }), final);\n            if (final) {\n                if (this.t.decode().length)\n                    throw 'invalid utf-8 data';\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p)\n            throw 'stream finished';\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), ch = _a[0], np = _a[1];\n        if (final) {\n            if (np.length)\n                throw 'invalid utf-8 data';\n            this.p = null;\n        }\n        else\n            this.p = np;\n        this.ondata(ch, final);\n    };\n    return DecodeUTF8;\n}());\n\n/**\n * Streaming UTF-8 encoding\n */\nvar EncodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */\n    function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */\n    EncodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no callback';\n        if (this.d)\n            throw 'stream finished';\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}());\n\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nfunction strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for (var i = 0; i < str.length; ++i)\n            ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te)\n        return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nfunction strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = '';\n        for (var i = 0; i < dat.length; i += 16384)\n            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    }\n    else if (td)\n        return td.decode(dat);\n    else {\n        var _a = dutf8(dat), out = _a[0], ext = _a[1];\n        if (ext.length)\n            throw 'invalid utf-8 data';\n        return out;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\n// read zip64 extra field\nvar z64e = function (d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n        ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n};\n// extra field length\nvar exfl = function (ex) {\n    var le = 0;\n    if (ex) {\n        for (var k in ex) {\n            var l = ex[k].length;\n            if (l > 65535)\n                throw 'extra field too long';\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (f.flag << 1) | (c == null && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        throw 'date not in range 1980-2099';\n    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >>> 1)), b += 4;\n    if (c != null) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for (var k in ex) {\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col)\n        d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */\nvar ZipPassThrough = /*#__PURE__*/ (function () {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */\n    function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.process = function (chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no callback - add to ZIP archive before pushing';\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final)\n            this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}());\n\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */\nvar ZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function ZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function (chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}());\n\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */\nvar AsyncZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function AsyncZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function (err, dat, final) {\n            _this_1.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function (chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}());\n\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */\nvar Zip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */\n    function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */\n    Zip.prototype.add = function (file) {\n        var _this_1 = this;\n        if (this.d & 2)\n            throw 'stream finished';\n        var f = strToU8(file.filename), fl = f.length;\n        var com = file.comment, o = com && strToU8(com);\n        var u = fl != file.filename.length || (o && (com.length != o.length));\n        var hl = fl + exfl(file.extra) + 30;\n        if (fl > 65535)\n            throw 'filename too long';\n        var header = new u8(hl);\n        wzh(header, 0, file, f, u);\n        var chks = [header];\n        var pAll = function () {\n            for (var _i = 0, chks_1 = chks; _i < chks_1.length; _i++) {\n                var chk = chks_1[_i];\n                _this_1.ondata(null, chk, false);\n            }\n            chks = [];\n        };\n        var tr = this.d;\n        this.d = 0;\n        var ind = this.u.length;\n        var uf = mrg(file, {\n            f: f,\n            u: u,\n            o: o,\n            t: function () {\n                if (file.terminate)\n                    file.terminate();\n            },\n            r: function () {\n                pAll();\n                if (tr) {\n                    var nxt = _this_1.u[ind + 1];\n                    if (nxt)\n                        nxt.r();\n                    else\n                        _this_1.d = 1;\n                }\n                tr = 1;\n            }\n        });\n        var cl = 0;\n        file.ondata = function (err, dat, final) {\n            if (err) {\n                _this_1.ondata(err, dat, final);\n                _this_1.terminate();\n            }\n            else {\n                cl += dat.length;\n                chks.push(dat);\n                if (final) {\n                    var dd = new u8(16);\n                    wbytes(dd, 0, 0x8074B50);\n                    wbytes(dd, 4, file.crc);\n                    wbytes(dd, 8, cl);\n                    wbytes(dd, 12, file.size);\n                    chks.push(dd);\n                    uf.c = cl, uf.b = hl + cl + 16, uf.crc = file.crc, uf.size = file.size;\n                    if (tr)\n                        uf.r();\n                    tr = 1;\n                }\n                else if (tr)\n                    pAll();\n            }\n        };\n        this.u.push(uf);\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */\n    Zip.prototype.end = function () {\n        var _this_1 = this;\n        if (this.d & 2) {\n            if (this.d & 1)\n                throw 'stream finishing';\n            throw 'stream finished';\n        }\n        if (this.d)\n            this.e();\n        else\n            this.u.push({\n                r: function () {\n                    if (!(_this_1.d & 1))\n                        return;\n                    _this_1.u.splice(-1, 1);\n                    _this_1.e();\n                },\n                t: function () { }\n            });\n        this.d = 3;\n    };\n    Zip.prototype.e = function () {\n        var bt = 0, l = 0, tl = 0;\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, f.c, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */\n    Zip.prototype.terminate = function () {\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}());\n\nfunction zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            }\n            catch (e) {\n                return cb(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cb(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || (m && (com.length != ms)),\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (s > 65535)\n            cbl('filename too long', null);\n        if (!compression)\n            cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nfunction zipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535)\n            throw 'filename too long';\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || (m && (com.length != ms)),\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */\nvar UnzipPassThrough = /*#__PURE__*/ (function () {\n    function UnzipPassThrough() {\n    }\n    UnzipPassThrough.prototype.push = function (data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}());\n\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */\nvar UnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function UnzipInflate() {\n        var _this_1 = this;\n        this.i = new Inflate(function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function (data, final) {\n        try {\n            this.i.push(data, final);\n        }\n        catch (e) {\n            this.ondata(e, data, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}());\n\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */\nvar AsyncUnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function AsyncUnzipInflate(_, sz) {\n        var _this_1 = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function (dat, final) {\n                _this_1.ondata(null, dat, final);\n            });\n        }\n        else {\n            this.i = new AsyncInflate(function (err, dat, final) {\n                _this_1.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function (data, final) {\n        if (this.i.terminate)\n            data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}());\n\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */\nvar Unzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */\n    function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzip.prototype.push = function (chunk, final) {\n        var _this_1 = this;\n        if (!this.onfile)\n            throw 'no callback';\n        if (!this.p)\n            throw 'stream finished';\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d)\n                this.d.push(toAdd, !this.c);\n            else\n                this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length)\n                return this.push(chunk, final);\n        }\n        else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length)\n                buf = chunk;\n            else if (!chunk.length)\n                buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function () {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_2 = [];\n                        this_1.k.unshift(chks_2);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        }\n                        else if (dd)\n                            sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function () {\n                                if (!file_1.ondata)\n                                    throw 'no callback';\n                                if (!sc_1)\n                                    file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this_1.o[cmp_1];\n                                    if (!ctr)\n                                        throw 'unknown compression type ' + cmp_1;\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };\n                                    for (var _i = 0, chks_3 = chks_2; _i < chks_3.length; _i++) {\n                                        var dat = chks_3[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this_1.k[0] == chks_2 && _this_1.c)\n                                        _this_1.d = d_1;\n                                    else\n                                        d_1.push(et, true);\n                                }\n                            },\n                            terminate: function () {\n                                if (d_1 && d_1.terminate)\n                                    d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0)\n                            file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                }\n                else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                    else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for (; i < l - 4; ++i) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add)\n                    add.push(dat, !!f);\n                else\n                    this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2)\n                return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c)\n                throw 'invalid zip file';\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */\n    Unzip.prototype.register = function (decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}());\n\n/**\n * Asynchronously decompresses a ZIP archive\n * @param data The raw compressed ZIP file\n * @param cb The callback to call with the decompressed files\n * @returns A function that can be used to immediately terminate the unzipping\n */\nfunction unzip(data, cb) {\n    if (typeof cb != 'function')\n        throw 'no callback';\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cb('invalid zip file', null);\n            return;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (!lft)\n        cb(null, {});\n    var c = lft;\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50) {\n            cb('invalid zip file', null);\n            return;\n        }\n        c = lft = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    var _loop_3 = function (i) {\n        var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            }\n            else {\n                files[fn] = d;\n                if (!--lft)\n                    cb(null, files);\n            }\n        };\n        if (!c_1)\n            cbl(null, slc(data, b, b + sc));\n        else if (c_1 == 8) {\n            var infl = data.subarray(b, b + sc);\n            if (sc < 320000) {\n                try {\n                    cbl(null, inflateSync(infl, new u8(su)));\n                }\n                catch (e) {\n                    cbl(e, null);\n                }\n            }\n            else\n                term.push(inflate(infl, { size: su }, cbl));\n        }\n        else\n            cbl('unknown compression type ' + c_1, null);\n    };\n    for (var i = 0; i < c; ++i) {\n        _loop_3(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @returns The decompressed files\n */\nfunction unzipSync(data) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            throw 'invalid zip file';\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50)\n            throw 'invalid zip file';\n        c = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!c_2)\n            files[fn] = slc(data, b, b + sc);\n        else if (c_2 == 8)\n            files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));\n        else\n            throw 'unknown compression type ' + c_2;\n    }\n    return files;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyZWUvZXhhbXBsZXMvanNtL2xpYnMvZmZsYXRlLm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyQ0FBMkMseUJBQXlCO0FBQzlGLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9DQUFvQztBQUM5RCxtQ0FBbUM7QUFDbkMseUJBQXlCLHVCQUF1QixnQkFBZ0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxXQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHdDQUF3QztBQUMxRSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0Isb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxXQUFXLGtDQUFrQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDZDQUE2QztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQSxTQUFTO0FBQ1QseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiw0QkFBNEIsc0JBQXNCLHNDQUFzQyxrQ0FBa0M7QUFDMUg7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwwQkFBMEI7QUFDMUI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ2tCO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUN1QjtBQUNqQjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrREFBa0Q7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDa0I7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUN1QjtBQUNqQjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1REFBdUQ7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ2U7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDb0I7QUFDZDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHVCQUF1QiwrQ0FBK0M7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDaUI7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ3NCO0FBQ2hCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsdUJBQXVCLHFDQUFxQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDZTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNvQjtBQUNkO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsdUJBQXVCLCtDQUErQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDaUI7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ3NCO0FBQ2hCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsdUJBQXVCLHNEQUFzRDtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ3dEO0FBQ3hEO0FBQ3NEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNxQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUMwQjtBQUNwQjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxjQUFjO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ3FCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDcUI7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0Isb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ3lCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNxQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDMEI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG9CQUFvQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZ0JBQWdCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxnQkFBZ0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNjO0FBQ1I7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUMyQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDdUI7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUM0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RSxzRUFBc0Usb0JBQW9CO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNnQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFVBQVU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdGhyZWUvZXhhbXBsZXMvanNtL2xpYnMvZmZsYXRlLm1vZHVsZS5qcz80MTdiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuZmZsYXRlIC0gZmFzdCBKYXZhU2NyaXB0IGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb25cbjxodHRwczovLzEwMWFycm93ei5naXRodWIuaW8vZmZsYXRlPlxuTGljZW5zZWQgdW5kZXIgTUlULiBodHRwczovL2dpdGh1Yi5jb20vMTAxYXJyb3d6L2ZmbGF0ZS9ibG9iL21hc3Rlci9MSUNFTlNFXG52ZXJzaW9uIDAuNi45XG4qL1xuXG4vLyBERUZMQVRFIGlzIGEgY29tcGxleCBmb3JtYXQ7IHRvIHJlYWQgdGhpcyBjb2RlLCB5b3Ugc2hvdWxkIHByb2JhYmx5IGNoZWNrIHRoZSBSRkMgZmlyc3Q6XG4vLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMTk1MVxuLy8gWW91IG1heSBhbHNvIHdpc2ggdG8gdGFrZSBhIGxvb2sgYXQgdGhlIGd1aWRlIEkgbWFkZSBhYm91dCB0aGlzIHByb2dyYW06XG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8xMDFhcnJvd3ovMjUzZjMxZWI1YWJjM2Q5Mjc1YWI5NDMwMDNmZmVjYWRcbi8vIFNvbWUgb2YgdGhlIGZvbGxvd2luZyBjb2RlIGlzIHNpbWlsYXIgdG8gdGhhdCBvZiBVWklQLmpzOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvcGVhL1VaSVAuanNcbi8vIEhvd2V2ZXIsIHRoZSB2YXN0IG1ham9yaXR5IG9mIHRoZSBjb2RlYmFzZSBoYXMgZGl2ZXJnZWQgZnJvbSBVWklQLmpzIHRvIGluY3JlYXNlIHBlcmZvcm1hbmNlIGFuZCByZWR1Y2UgYnVuZGxlIHNpemUuXG4vLyBTb21ldGltZXMgMCB3aWxsIGFwcGVhciB3aGVyZSAtMSB3b3VsZCBiZSBtb3JlIGFwcHJvcHJpYXRlLiBUaGlzIGlzIGJlY2F1c2UgdXNpbmcgYSB1aW50XG4vLyBpcyBiZXR0ZXIgZm9yIG1lbW9yeSBpbiBtb3N0IGVuZ2luZXMgKEkgKnRoaW5rKikuXG52YXIgY2gyID0ge307XG52YXIgZHVybCA9IGZ1bmN0aW9uIChjKSB7IHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtjXSwgeyB0eXBlOiAndGV4dC9qYXZhc2NyaXB0JyB9KSk7IH07XG52YXIgY3drID0gZnVuY3Rpb24gKHUpIHsgcmV0dXJuIG5ldyBXb3JrZXIodSk7IH07XG50cnkge1xuICAgIFVSTC5yZXZva2VPYmplY3RVUkwoZHVybCgnJykpO1xufVxuY2F0Y2ggKGUpIHtcbiAgICAvLyBXZSdyZSBpbiBEZW5vIG9yIGEgdmVyeSBvbGQgYnJvd3NlclxuICAgIGR1cmwgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ2RhdGE6YXBwbGljYXRpb24vamF2YXNjcmlwdDtjaGFyc2V0PVVURi04LCcgKyBlbmNvZGVVUkkoYyk7IH07XG4gICAgLy8gSWYgRGVubywgdGhpcyBpcyBuZWNlc3Nhcnk7IGlmIG5vdCwgdGhpcyBjaGFuZ2VzIG5vdGhpbmdcbiAgICBjd2sgPSBmdW5jdGlvbiAodSkgeyByZXR1cm4gbmV3IFdvcmtlcih1LCB7IHR5cGU6ICdtb2R1bGUnIH0pOyB9O1xufVxudmFyIHdrID0gKGZ1bmN0aW9uIChjLCBpZCwgbXNnLCB0cmFuc2ZlciwgY2IpIHtcbiAgICB2YXIgdyA9IGN3ayhjaDJbaWRdIHx8IChjaDJbaWRdID0gZHVybChjKSkpO1xuICAgIHcub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBjYihlLmVycm9yLCBudWxsKTsgfTtcbiAgICB3Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBjYihudWxsLCBlLmRhdGEpOyB9O1xuICAgIHcucG9zdE1lc3NhZ2UobXNnLCB0cmFuc2Zlcik7XG4gICAgcmV0dXJuIHc7XG59KTtcblxuLy8gYWxpYXNlcyBmb3Igc2hvcnRlciBjb21wcmVzc2VkIGNvZGUgKG1vc3QgbWluaWZlcnMgZG9uJ3QgZG8gdGhpcylcbnZhciB1OCA9IFVpbnQ4QXJyYXksIHUxNiA9IFVpbnQxNkFycmF5LCB1MzIgPSBVaW50MzJBcnJheTtcbi8vIGZpeGVkIGxlbmd0aCBleHRyYSBiaXRzXG52YXIgZmxlYiA9IG5ldyB1OChbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMSwgMSwgMSwgMSwgMiwgMiwgMiwgMiwgMywgMywgMywgMywgNCwgNCwgNCwgNCwgNSwgNSwgNSwgNSwgMCwgLyogdW51c2VkICovIDAsIDAsIC8qIGltcG9zc2libGUgKi8gMF0pO1xuLy8gZml4ZWQgZGlzdGFuY2UgZXh0cmEgYml0c1xuLy8gc2VlIGZsZWIgbm90ZVxudmFyIGZkZWIgPSBuZXcgdTgoWzAsIDAsIDAsIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDQsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDgsIDgsIDksIDksIDEwLCAxMCwgMTEsIDExLCAxMiwgMTIsIDEzLCAxMywgLyogdW51c2VkICovIDAsIDBdKTtcbi8vIGNvZGUgbGVuZ3RoIGluZGV4IG1hcFxudmFyIGNsaW0gPSBuZXcgdTgoWzE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTVdKTtcbi8vIGdldCBiYXNlLCByZXZlcnNlIGluZGV4IG1hcCBmcm9tIGV4dHJhIGJpdHNcbnZhciBmcmViID0gZnVuY3Rpb24gKGViLCBzdGFydCkge1xuICAgIHZhciBiID0gbmV3IHUxNigzMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMTsgKytpKSB7XG4gICAgICAgIGJbaV0gPSBzdGFydCArPSAxIDw8IGViW2kgLSAxXTtcbiAgICB9XG4gICAgLy8gbnVtYmVycyBoZXJlIGFyZSBhdCBtYXggMTggYml0c1xuICAgIHZhciByID0gbmV3IHUzMihiWzMwXSk7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCAzMDsgKytpKSB7XG4gICAgICAgIGZvciAodmFyIGogPSBiW2ldOyBqIDwgYltpICsgMV07ICsraikge1xuICAgICAgICAgICAgcltqXSA9ICgoaiAtIGJbaV0pIDw8IDUpIHwgaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2IsIHJdO1xufTtcbnZhciBfYSA9IGZyZWIoZmxlYiwgMiksIGZsID0gX2FbMF0sIHJldmZsID0gX2FbMV07XG4vLyB3ZSBjYW4gaWdub3JlIHRoZSBmYWN0IHRoYXQgdGhlIG90aGVyIG51bWJlcnMgYXJlIHdyb25nOyB0aGV5IG5ldmVyIGhhcHBlbiBhbnl3YXlcbmZsWzI4XSA9IDI1OCwgcmV2ZmxbMjU4XSA9IDI4O1xudmFyIF9iID0gZnJlYihmZGViLCAwKSwgZmQgPSBfYlswXSwgcmV2ZmQgPSBfYlsxXTtcbi8vIG1hcCBvZiB2YWx1ZSB0byByZXZlcnNlIChhc3N1bWluZyAxNiBiaXRzKVxudmFyIHJldiA9IG5ldyB1MTYoMzI3NjgpO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAzMjc2ODsgKytpKSB7XG4gICAgLy8gcmV2ZXJzZSB0YWJsZSBhbGdvcml0aG0gZnJvbSBTT1xuICAgIHZhciB4ID0gKChpICYgMHhBQUFBKSA+Pj4gMSkgfCAoKGkgJiAweDU1NTUpIDw8IDEpO1xuICAgIHggPSAoKHggJiAweENDQ0MpID4+PiAyKSB8ICgoeCAmIDB4MzMzMykgPDwgMik7XG4gICAgeCA9ICgoeCAmIDB4RjBGMCkgPj4+IDQpIHwgKCh4ICYgMHgwRjBGKSA8PCA0KTtcbiAgICByZXZbaV0gPSAoKCh4ICYgMHhGRjAwKSA+Pj4gOCkgfCAoKHggJiAweDAwRkYpIDw8IDgpKSA+Pj4gMTtcbn1cbi8vIGNyZWF0ZSBodWZmbWFuIHRyZWUgZnJvbSB1OCBcIm1hcFwiOiBpbmRleCAtPiBjb2RlIGxlbmd0aCBmb3IgY29kZSBpbmRleFxuLy8gbWIgKG1heCBiaXRzKSBtdXN0IGJlIGF0IG1vc3QgMTVcbi8vIFRPRE86IG9wdGltaXplL3NwbGl0IHVwP1xudmFyIGhNYXAgPSAoZnVuY3Rpb24gKGNkLCBtYiwgcikge1xuICAgIHZhciBzID0gY2QubGVuZ3RoO1xuICAgIC8vIGluZGV4XG4gICAgdmFyIGkgPSAwO1xuICAgIC8vIHUxNiBcIm1hcFwiOiBpbmRleCAtPiAjIG9mIGNvZGVzIHdpdGggYml0IGxlbmd0aCA9IGluZGV4XG4gICAgdmFyIGwgPSBuZXcgdTE2KG1iKTtcbiAgICAvLyBsZW5ndGggb2YgY2QgbXVzdCBiZSAyODggKHRvdGFsICMgb2YgY29kZXMpXG4gICAgZm9yICg7IGkgPCBzOyArK2kpXG4gICAgICAgICsrbFtjZFtpXSAtIDFdO1xuICAgIC8vIHUxNiBcIm1hcFwiOiBpbmRleCAtPiBtaW5pbXVtIGNvZGUgZm9yIGJpdCBsZW5ndGggPSBpbmRleFxuICAgIHZhciBsZSA9IG5ldyB1MTYobWIpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBtYjsgKytpKSB7XG4gICAgICAgIGxlW2ldID0gKGxlW2kgLSAxXSArIGxbaSAtIDFdKSA8PCAxO1xuICAgIH1cbiAgICB2YXIgY287XG4gICAgaWYgKHIpIHtcbiAgICAgICAgLy8gdTE2IFwibWFwXCI6IGluZGV4IC0+IG51bWJlciBvZiBhY3R1YWwgYml0cywgc3ltYm9sIGZvciBjb2RlXG4gICAgICAgIGNvID0gbmV3IHUxNigxIDw8IG1iKTtcbiAgICAgICAgLy8gYml0cyB0byByZW1vdmUgZm9yIHJldmVyc2VyXG4gICAgICAgIHZhciBydmIgPSAxNSAtIG1iO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgczsgKytpKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgMCBsZW5ndGhzXG4gICAgICAgICAgICBpZiAoY2RbaV0pIHtcbiAgICAgICAgICAgICAgICAvLyBudW0gZW5jb2RpbmcgYm90aCBzeW1ib2wgYW5kIGJpdHMgcmVhZFxuICAgICAgICAgICAgICAgIHZhciBzdiA9IChpIDw8IDQpIHwgY2RbaV07XG4gICAgICAgICAgICAgICAgLy8gZnJlZSBiaXRzXG4gICAgICAgICAgICAgICAgdmFyIHJfMSA9IG1iIC0gY2RbaV07XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgdmFsdWVcbiAgICAgICAgICAgICAgICB2YXIgdiA9IGxlW2NkW2ldIC0gMV0rKyA8PCByXzE7XG4gICAgICAgICAgICAgICAgLy8gbSBpcyBlbmQgdmFsdWVcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBtID0gdiB8ICgoMSA8PCByXzEpIC0gMSk7IHYgPD0gbTsgKyt2KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGV2ZXJ5IDE2IGJpdCB2YWx1ZSBzdGFydGluZyB3aXRoIHRoZSBjb2RlIHlpZWxkcyB0aGUgc2FtZSByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgY29bcmV2W3ZdID4+PiBydmJdID0gc3Y7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjbyA9IG5ldyB1MTYocyk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChjZFtpXSkge1xuICAgICAgICAgICAgICAgIGNvW2ldID0gcmV2W2xlW2NkW2ldIC0gMV0rK10gPj4+ICgxNSAtIGNkW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY287XG59KTtcbi8vIGZpeGVkIGxlbmd0aCB0cmVlXG52YXIgZmx0ID0gbmV3IHU4KDI4OCk7XG5mb3IgKHZhciBpID0gMDsgaSA8IDE0NDsgKytpKVxuICAgIGZsdFtpXSA9IDg7XG5mb3IgKHZhciBpID0gMTQ0OyBpIDwgMjU2OyArK2kpXG4gICAgZmx0W2ldID0gOTtcbmZvciAodmFyIGkgPSAyNTY7IGkgPCAyODA7ICsraSlcbiAgICBmbHRbaV0gPSA3O1xuZm9yICh2YXIgaSA9IDI4MDsgaSA8IDI4ODsgKytpKVxuICAgIGZsdFtpXSA9IDg7XG4vLyBmaXhlZCBkaXN0YW5jZSB0cmVlXG52YXIgZmR0ID0gbmV3IHU4KDMyKTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMzI7ICsraSlcbiAgICBmZHRbaV0gPSA1O1xuLy8gZml4ZWQgbGVuZ3RoIG1hcFxudmFyIGZsbSA9IC8qI19fUFVSRV9fKi8gaE1hcChmbHQsIDksIDApLCBmbHJtID0gLyojX19QVVJFX18qLyBoTWFwKGZsdCwgOSwgMSk7XG4vLyBmaXhlZCBkaXN0YW5jZSBtYXBcbnZhciBmZG0gPSAvKiNfX1BVUkVfXyovIGhNYXAoZmR0LCA1LCAwKSwgZmRybSA9IC8qI19fUFVSRV9fKi8gaE1hcChmZHQsIDUsIDEpO1xuLy8gZmluZCBtYXggb2YgYXJyYXlcbnZhciBtYXggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciBtID0gYVswXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGFbaV0gPiBtKVxuICAgICAgICAgICAgbSA9IGFbaV07XG4gICAgfVxuICAgIHJldHVybiBtO1xufTtcbi8vIHJlYWQgZCwgc3RhcnRpbmcgYXQgYml0IHAgYW5kIG1hc2sgd2l0aCBtXG52YXIgYml0cyA9IGZ1bmN0aW9uIChkLCBwLCBtKSB7XG4gICAgdmFyIG8gPSAocCAvIDgpIHwgMDtcbiAgICByZXR1cm4gKChkW29dIHwgKGRbbyArIDFdIDw8IDgpKSA+PiAocCAmIDcpKSAmIG07XG59O1xuLy8gcmVhZCBkLCBzdGFydGluZyBhdCBiaXQgcCBjb250aW51aW5nIGZvciBhdCBsZWFzdCAxNiBiaXRzXG52YXIgYml0czE2ID0gZnVuY3Rpb24gKGQsIHApIHtcbiAgICB2YXIgbyA9IChwIC8gOCkgfCAwO1xuICAgIHJldHVybiAoKGRbb10gfCAoZFtvICsgMV0gPDwgOCkgfCAoZFtvICsgMl0gPDwgMTYpKSA+PiAocCAmIDcpKTtcbn07XG4vLyBnZXQgZW5kIG9mIGJ5dGVcbnZhciBzaGZ0ID0gZnVuY3Rpb24gKHApIHsgcmV0dXJuICgocCAvIDgpIHwgMCkgKyAocCAmIDcgJiYgMSk7IH07XG4vLyB0eXBlZCBhcnJheSBzbGljZSAtIGFsbG93cyBnYXJiYWdlIGNvbGxlY3RvciB0byBmcmVlIG9yaWdpbmFsIHJlZmVyZW5jZSxcbi8vIHdoaWxlIGJlaW5nIG1vcmUgY29tcGF0aWJsZSB0aGFuIC5zbGljZVxudmFyIHNsYyA9IGZ1bmN0aW9uICh2LCBzLCBlKSB7XG4gICAgaWYgKHMgPT0gbnVsbCB8fCBzIDwgMClcbiAgICAgICAgcyA9IDA7XG4gICAgaWYgKGUgPT0gbnVsbCB8fCBlID4gdi5sZW5ndGgpXG4gICAgICAgIGUgPSB2Lmxlbmd0aDtcbiAgICAvLyBjYW4ndCB1c2UgLmNvbnN0cnVjdG9yIGluIGNhc2UgdXNlci1zdXBwbGllZFxuICAgIHZhciBuID0gbmV3ICh2IGluc3RhbmNlb2YgdTE2ID8gdTE2IDogdiBpbnN0YW5jZW9mIHUzMiA/IHUzMiA6IHU4KShlIC0gcyk7XG4gICAgbi5zZXQodi5zdWJhcnJheShzLCBlKSk7XG4gICAgcmV0dXJuIG47XG59O1xuLy8gZXhwYW5kcyByYXcgREVGTEFURSBkYXRhXG52YXIgaW5mbHQgPSBmdW5jdGlvbiAoZGF0LCBidWYsIHN0KSB7XG4gICAgLy8gc291cmNlIGxlbmd0aFxuICAgIHZhciBzbCA9IGRhdC5sZW5ndGg7XG4gICAgaWYgKCFzbCB8fCAoc3QgJiYgIXN0LmwgJiYgc2wgPCA1KSlcbiAgICAgICAgcmV0dXJuIGJ1ZiB8fCBuZXcgdTgoMCk7XG4gICAgLy8gaGF2ZSB0byBlc3RpbWF0ZSBzaXplXG4gICAgdmFyIG5vQnVmID0gIWJ1ZiB8fCBzdDtcbiAgICAvLyBubyBzdGF0ZVxuICAgIHZhciBub1N0ID0gIXN0IHx8IHN0Lmk7XG4gICAgaWYgKCFzdClcbiAgICAgICAgc3QgPSB7fTtcbiAgICAvLyBBc3N1bWVzIHJvdWdobHkgMzMlIGNvbXByZXNzaW9uIHJhdGlvIGF2ZXJhZ2VcbiAgICBpZiAoIWJ1ZilcbiAgICAgICAgYnVmID0gbmV3IHU4KHNsICogMyk7XG4gICAgLy8gZW5zdXJlIGJ1ZmZlciBjYW4gZml0IGF0IGxlYXN0IGwgZWxlbWVudHNcbiAgICB2YXIgY2J1ZiA9IGZ1bmN0aW9uIChsKSB7XG4gICAgICAgIHZhciBibCA9IGJ1Zi5sZW5ndGg7XG4gICAgICAgIC8vIG5lZWQgdG8gaW5jcmVhc2Ugc2l6ZSB0byBmaXRcbiAgICAgICAgaWYgKGwgPiBibCkge1xuICAgICAgICAgICAgLy8gRG91YmxlIG9yIHNldCB0byBuZWNlc3NhcnksIHdoaWNoZXZlciBpcyBncmVhdGVyXG4gICAgICAgICAgICB2YXIgbmJ1ZiA9IG5ldyB1OChNYXRoLm1heChibCAqIDIsIGwpKTtcbiAgICAgICAgICAgIG5idWYuc2V0KGJ1Zik7XG4gICAgICAgICAgICBidWYgPSBuYnVmO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyAgbGFzdCBjaHVuayAgICAgICAgIGJpdHBvcyAgICAgICAgICAgYnl0ZXNcbiAgICB2YXIgZmluYWwgPSBzdC5mIHx8IDAsIHBvcyA9IHN0LnAgfHwgMCwgYnQgPSBzdC5iIHx8IDAsIGxtID0gc3QubCwgZG0gPSBzdC5kLCBsYnQgPSBzdC5tLCBkYnQgPSBzdC5uO1xuICAgIC8vIHRvdGFsIGJpdHNcbiAgICB2YXIgdGJ0cyA9IHNsICogODtcbiAgICBkbyB7XG4gICAgICAgIGlmICghbG0pIHtcbiAgICAgICAgICAgIC8vIEJGSU5BTCAtIHRoaXMgaXMgb25seSAxIHdoZW4gbGFzdCBjaHVuayBpcyBuZXh0XG4gICAgICAgICAgICBzdC5mID0gZmluYWwgPSBiaXRzKGRhdCwgcG9zLCAxKTtcbiAgICAgICAgICAgIC8vIHR5cGU6IDAgPSBubyBjb21wcmVzc2lvbiwgMSA9IGZpeGVkIGh1ZmZtYW4sIDIgPSBkeW5hbWljIGh1ZmZtYW5cbiAgICAgICAgICAgIHZhciB0eXBlID0gYml0cyhkYXQsIHBvcyArIDEsIDMpO1xuICAgICAgICAgICAgcG9zICs9IDM7XG4gICAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBnbyB0byBlbmQgb2YgYnl0ZSBib3VuZGFyeVxuICAgICAgICAgICAgICAgIHZhciBzID0gc2hmdChwb3MpICsgNCwgbCA9IGRhdFtzIC0gNF0gfCAoZGF0W3MgLSAzXSA8PCA4KSwgdCA9IHMgKyBsO1xuICAgICAgICAgICAgICAgIGlmICh0ID4gc2wpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vU3QpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAndW5leHBlY3RlZCBFT0YnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIHNpemVcbiAgICAgICAgICAgICAgICBpZiAobm9CdWYpXG4gICAgICAgICAgICAgICAgICAgIGNidWYoYnQgKyBsKTtcbiAgICAgICAgICAgICAgICAvLyBDb3B5IG92ZXIgdW5jb21wcmVzc2VkIGRhdGFcbiAgICAgICAgICAgICAgICBidWYuc2V0KGRhdC5zdWJhcnJheShzLCB0KSwgYnQpO1xuICAgICAgICAgICAgICAgIC8vIEdldCBuZXcgYml0cG9zLCB1cGRhdGUgYnl0ZSBjb3VudFxuICAgICAgICAgICAgICAgIHN0LmIgPSBidCArPSBsLCBzdC5wID0gcG9zID0gdCAqIDg7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IDEpXG4gICAgICAgICAgICAgICAgbG0gPSBmbHJtLCBkbSA9IGZkcm0sIGxidCA9IDksIGRidCA9IDU7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IDIpIHtcbiAgICAgICAgICAgICAgICAvLyAgbGl0ZXJhbCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGhzXG4gICAgICAgICAgICAgICAgdmFyIGhMaXQgPSBiaXRzKGRhdCwgcG9zLCAzMSkgKyAyNTcsIGhjTGVuID0gYml0cyhkYXQsIHBvcyArIDEwLCAxNSkgKyA0O1xuICAgICAgICAgICAgICAgIHZhciB0bCA9IGhMaXQgKyBiaXRzKGRhdCwgcG9zICsgNSwgMzEpICsgMTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gMTQ7XG4gICAgICAgICAgICAgICAgLy8gbGVuZ3RoK2Rpc3RhbmNlIHRyZWVcbiAgICAgICAgICAgICAgICB2YXIgbGR0ID0gbmV3IHU4KHRsKTtcbiAgICAgICAgICAgICAgICAvLyBjb2RlIGxlbmd0aCB0cmVlXG4gICAgICAgICAgICAgICAgdmFyIGNsdCA9IG5ldyB1OCgxOSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoY0xlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSBpbmRleCBtYXAgdG8gZ2V0IHJlYWwgY29kZVxuICAgICAgICAgICAgICAgICAgICBjbHRbY2xpbVtpXV0gPSBiaXRzKGRhdCwgcG9zICsgaSAqIDMsIDcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3MgKz0gaGNMZW4gKiAzO1xuICAgICAgICAgICAgICAgIC8vIGNvZGUgbGVuZ3RocyBiaXRzXG4gICAgICAgICAgICAgICAgdmFyIGNsYiA9IG1heChjbHQpLCBjbGJtc2sgPSAoMSA8PCBjbGIpIC0gMTtcbiAgICAgICAgICAgICAgICAvLyBjb2RlIGxlbmd0aHMgbWFwXG4gICAgICAgICAgICAgICAgdmFyIGNsbSA9IGhNYXAoY2x0LCBjbGIsIDEpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGw7KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gY2xtW2JpdHMoZGF0LCBwb3MsIGNsYm1zayldO1xuICAgICAgICAgICAgICAgICAgICAvLyBiaXRzIHJlYWRcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IHIgJiAxNTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3ltYm9sXG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gciA+Pj4gNDtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29kZSBsZW5ndGggdG8gY29weVxuICAgICAgICAgICAgICAgICAgICBpZiAocyA8IDE2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZHRbaSsrXSA9IHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgY29weSAgIGNvdW50XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IDAsIG4gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgPT0gMTYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IDMgKyBiaXRzKGRhdCwgcG9zLCAzKSwgcG9zICs9IDIsIGMgPSBsZHRbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocyA9PSAxNylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gMyArIGJpdHMoZGF0LCBwb3MsIDcpLCBwb3MgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHMgPT0gMTgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IDExICsgYml0cyhkYXQsIHBvcywgMTI3KSwgcG9zICs9IDc7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobi0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxkdFtpKytdID0gYztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAgICBsZW5ndGggdHJlZSAgICAgICAgICAgICAgICAgZGlzdGFuY2UgdHJlZVxuICAgICAgICAgICAgICAgIHZhciBsdCA9IGxkdC5zdWJhcnJheSgwLCBoTGl0KSwgZHQgPSBsZHQuc3ViYXJyYXkoaExpdCk7XG4gICAgICAgICAgICAgICAgLy8gbWF4IGxlbmd0aCBiaXRzXG4gICAgICAgICAgICAgICAgbGJ0ID0gbWF4KGx0KTtcbiAgICAgICAgICAgICAgICAvLyBtYXggZGlzdCBiaXRzXG4gICAgICAgICAgICAgICAgZGJ0ID0gbWF4KGR0KTtcbiAgICAgICAgICAgICAgICBsbSA9IGhNYXAobHQsIGxidCwgMSk7XG4gICAgICAgICAgICAgICAgZG0gPSBoTWFwKGR0LCBkYnQsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93ICdpbnZhbGlkIGJsb2NrIHR5cGUnO1xuICAgICAgICAgICAgaWYgKHBvcyA+IHRidHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9TdClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ3VuZXhwZWN0ZWQgRU9GJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGJ1ZmZlciBjYW4gaG9sZCB0aGlzICsgdGhlIGxhcmdlc3QgcG9zc2libGUgYWRkaXRpb25cbiAgICAgICAgLy8gTWF4aW11bSBjaHVuayBzaXplIChwcmFjdGljYWxseSwgdGhlb3JldGljYWxseSBpbmZpbml0ZSkgaXMgMl4xNztcbiAgICAgICAgaWYgKG5vQnVmKVxuICAgICAgICAgICAgY2J1ZihidCArIDEzMTA3Mik7XG4gICAgICAgIHZhciBsbXMgPSAoMSA8PCBsYnQpIC0gMSwgZG1zID0gKDEgPDwgZGJ0KSAtIDE7XG4gICAgICAgIHZhciBscG9zID0gcG9zO1xuICAgICAgICBmb3IgKDs7IGxwb3MgPSBwb3MpIHtcbiAgICAgICAgICAgIC8vIGJpdHMgcmVhZCwgY29kZVxuICAgICAgICAgICAgdmFyIGMgPSBsbVtiaXRzMTYoZGF0LCBwb3MpICYgbG1zXSwgc3ltID0gYyA+Pj4gNDtcbiAgICAgICAgICAgIHBvcyArPSBjICYgMTU7XG4gICAgICAgICAgICBpZiAocG9zID4gdGJ0cykge1xuICAgICAgICAgICAgICAgIGlmIChub1N0KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyAndW5leHBlY3RlZCBFT0YnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjKVxuICAgICAgICAgICAgICAgIHRocm93ICdpbnZhbGlkIGxlbmd0aC9saXRlcmFsJztcbiAgICAgICAgICAgIGlmIChzeW0gPCAyNTYpXG4gICAgICAgICAgICAgICAgYnVmW2J0KytdID0gc3ltO1xuICAgICAgICAgICAgZWxzZSBpZiAoc3ltID09IDI1Nikge1xuICAgICAgICAgICAgICAgIGxwb3MgPSBwb3MsIGxtID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBhZGQgPSBzeW0gLSAyNTQ7XG4gICAgICAgICAgICAgICAgLy8gbm8gZXh0cmEgYml0cyBuZWVkZWQgaWYgbGVzc1xuICAgICAgICAgICAgICAgIGlmIChzeW0gPiAyNjQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBzeW0gLSAyNTcsIGIgPSBmbGViW2ldO1xuICAgICAgICAgICAgICAgICAgICBhZGQgPSBiaXRzKGRhdCwgcG9zLCAoMSA8PCBiKSAtIDEpICsgZmxbaV07XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSBiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkaXN0XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBkbVtiaXRzMTYoZGF0LCBwb3MpICYgZG1zXSwgZHN5bSA9IGQgPj4+IDQ7XG4gICAgICAgICAgICAgICAgaWYgKCFkKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyAnaW52YWxpZCBkaXN0YW5jZSc7XG4gICAgICAgICAgICAgICAgcG9zICs9IGQgJiAxNTtcbiAgICAgICAgICAgICAgICB2YXIgZHQgPSBmZFtkc3ltXTtcbiAgICAgICAgICAgICAgICBpZiAoZHN5bSA+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBmZGViW2RzeW1dO1xuICAgICAgICAgICAgICAgICAgICBkdCArPSBiaXRzMTYoZGF0LCBwb3MpICYgKCgxIDw8IGIpIC0gMSksIHBvcyArPSBiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9zID4gdGJ0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9TdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICd1bmV4cGVjdGVkIEVPRic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9CdWYpXG4gICAgICAgICAgICAgICAgICAgIGNidWYoYnQgKyAxMzEwNzIpO1xuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBidCArIGFkZDtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYnQgPCBlbmQ7IGJ0ICs9IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmW2J0XSA9IGJ1ZltidCAtIGR0XTtcbiAgICAgICAgICAgICAgICAgICAgYnVmW2J0ICsgMV0gPSBidWZbYnQgKyAxIC0gZHRdO1xuICAgICAgICAgICAgICAgICAgICBidWZbYnQgKyAyXSA9IGJ1ZltidCArIDIgLSBkdF07XG4gICAgICAgICAgICAgICAgICAgIGJ1ZltidCArIDNdID0gYnVmW2J0ICsgMyAtIGR0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnQgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3QubCA9IGxtLCBzdC5wID0gbHBvcywgc3QuYiA9IGJ0O1xuICAgICAgICBpZiAobG0pXG4gICAgICAgICAgICBmaW5hbCA9IDEsIHN0Lm0gPSBsYnQsIHN0LmQgPSBkbSwgc3QubiA9IGRidDtcbiAgICB9IHdoaWxlICghZmluYWwpO1xuICAgIHJldHVybiBidCA9PSBidWYubGVuZ3RoID8gYnVmIDogc2xjKGJ1ZiwgMCwgYnQpO1xufTtcbi8vIHN0YXJ0aW5nIGF0IHAsIHdyaXRlIHRoZSBtaW5pbXVtIG51bWJlciBvZiBiaXRzIHRoYXQgY2FuIGhvbGQgdiB0byBkXG52YXIgd2JpdHMgPSBmdW5jdGlvbiAoZCwgcCwgdikge1xuICAgIHYgPDw9IHAgJiA3O1xuICAgIHZhciBvID0gKHAgLyA4KSB8IDA7XG4gICAgZFtvXSB8PSB2O1xuICAgIGRbbyArIDFdIHw9IHYgPj4+IDg7XG59O1xuLy8gc3RhcnRpbmcgYXQgcCwgd3JpdGUgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGJpdHMgKD44KSB0aGF0IGNhbiBob2xkIHYgdG8gZFxudmFyIHdiaXRzMTYgPSBmdW5jdGlvbiAoZCwgcCwgdikge1xuICAgIHYgPDw9IHAgJiA3O1xuICAgIHZhciBvID0gKHAgLyA4KSB8IDA7XG4gICAgZFtvXSB8PSB2O1xuICAgIGRbbyArIDFdIHw9IHYgPj4+IDg7XG4gICAgZFtvICsgMl0gfD0gdiA+Pj4gMTY7XG59O1xuLy8gY3JlYXRlcyBjb2RlIGxlbmd0aHMgZnJvbSBhIGZyZXF1ZW5jeSB0YWJsZVxudmFyIGhUcmVlID0gZnVuY3Rpb24gKGQsIG1iKSB7XG4gICAgLy8gTmVlZCBleHRyYSBpbmZvIHRvIG1ha2UgYSB0cmVlXG4gICAgdmFyIHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGRbaV0pXG4gICAgICAgICAgICB0LnB1c2goeyBzOiBpLCBmOiBkW2ldIH0pO1xuICAgIH1cbiAgICB2YXIgcyA9IHQubGVuZ3RoO1xuICAgIHZhciB0MiA9IHQuc2xpY2UoKTtcbiAgICBpZiAoIXMpXG4gICAgICAgIHJldHVybiBbZXQsIDBdO1xuICAgIGlmIChzID09IDEpIHtcbiAgICAgICAgdmFyIHYgPSBuZXcgdTgodFswXS5zICsgMSk7XG4gICAgICAgIHZbdFswXS5zXSA9IDE7XG4gICAgICAgIHJldHVybiBbdiwgMV07XG4gICAgfVxuICAgIHQuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5mIC0gYi5mOyB9KTtcbiAgICAvLyBhZnRlciBpMiByZWFjaGVzIGxhc3QgaW5kLCB3aWxsIGJlIHN0b3BwZWRcbiAgICAvLyBmcmVxIG11c3QgYmUgZ3JlYXRlciB0aGFuIGxhcmdlc3QgcG9zc2libGUgbnVtYmVyIG9mIHN5bWJvbHNcbiAgICB0LnB1c2goeyBzOiAtMSwgZjogMjUwMDEgfSk7XG4gICAgdmFyIGwgPSB0WzBdLCByID0gdFsxXSwgaTAgPSAwLCBpMSA9IDEsIGkyID0gMjtcbiAgICB0WzBdID0geyBzOiAtMSwgZjogbC5mICsgci5mLCBsOiBsLCByOiByIH07XG4gICAgLy8gZWZmaWNpZW50IGFsZ29yaXRobSBmcm9tIFVaSVAuanNcbiAgICAvLyBpMCBpcyBsb29rYmVoaW5kLCBpMiBpcyBsb29rYWhlYWQgLSBhZnRlciBwcm9jZXNzaW5nIHR3byBsb3ctZnJlcVxuICAgIC8vIHN5bWJvbHMgdGhhdCBjb21iaW5lZCBoYXZlIGhpZ2ggZnJlcSwgd2lsbCBzdGFydCBwcm9jZXNzaW5nIGkyIChoaWdoLWZyZXEsXG4gICAgLy8gbm9uLWNvbXBvc2l0ZSkgc3ltYm9scyBpbnN0ZWFkXG4gICAgLy8gc2VlIGh0dHBzOi8vcmVkZGl0LmNvbS9yL3Bob3RvcGVhL2NvbW1lbnRzL2lrZWtodC91emlwanNfcXVlc3Rpb25zL1xuICAgIHdoaWxlIChpMSAhPSBzIC0gMSkge1xuICAgICAgICBsID0gdFt0W2kwXS5mIDwgdFtpMl0uZiA/IGkwKysgOiBpMisrXTtcbiAgICAgICAgciA9IHRbaTAgIT0gaTEgJiYgdFtpMF0uZiA8IHRbaTJdLmYgPyBpMCsrIDogaTIrK107XG4gICAgICAgIHRbaTErK10gPSB7IHM6IC0xLCBmOiBsLmYgKyByLmYsIGw6IGwsIHI6IHIgfTtcbiAgICB9XG4gICAgdmFyIG1heFN5bSA9IHQyWzBdLnM7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzOyArK2kpIHtcbiAgICAgICAgaWYgKHQyW2ldLnMgPiBtYXhTeW0pXG4gICAgICAgICAgICBtYXhTeW0gPSB0MltpXS5zO1xuICAgIH1cbiAgICAvLyBjb2RlIGxlbmd0aHNcbiAgICB2YXIgdHIgPSBuZXcgdTE2KG1heFN5bSArIDEpO1xuICAgIC8vIG1heCBiaXRzIGluIHRyZWVcbiAgICB2YXIgbWJ0ID0gbG4odFtpMSAtIDFdLCB0ciwgMCk7XG4gICAgaWYgKG1idCA+IG1iKSB7XG4gICAgICAgIC8vIG1vcmUgYWxnb3JpdGhtcyBmcm9tIFVaSVAuanNcbiAgICAgICAgLy8gVE9ETzogZmluZCBvdXQgaG93IHRoaXMgY29kZSB3b3JrcyAoZGVidClcbiAgICAgICAgLy8gIGluZCAgICBkZWJ0XG4gICAgICAgIHZhciBpID0gMCwgZHQgPSAwO1xuICAgICAgICAvLyAgICBsZWZ0ICAgICAgICAgICAgY29zdFxuICAgICAgICB2YXIgbGZ0ID0gbWJ0IC0gbWIsIGNzdCA9IDEgPDwgbGZ0O1xuICAgICAgICB0Mi5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiB0cltiLnNdIC0gdHJbYS5zXSB8fCBhLmYgLSBiLmY7IH0pO1xuICAgICAgICBmb3IgKDsgaSA8IHM7ICsraSkge1xuICAgICAgICAgICAgdmFyIGkyXzEgPSB0MltpXS5zO1xuICAgICAgICAgICAgaWYgKHRyW2kyXzFdID4gbWIpIHtcbiAgICAgICAgICAgICAgICBkdCArPSBjc3QgLSAoMSA8PCAobWJ0IC0gdHJbaTJfMV0pKTtcbiAgICAgICAgICAgICAgICB0cltpMl8xXSA9IG1iO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGR0ID4+Pj0gbGZ0O1xuICAgICAgICB3aGlsZSAoZHQgPiAwKSB7XG4gICAgICAgICAgICB2YXIgaTJfMiA9IHQyW2ldLnM7XG4gICAgICAgICAgICBpZiAodHJbaTJfMl0gPCBtYilcbiAgICAgICAgICAgICAgICBkdCAtPSAxIDw8IChtYiAtIHRyW2kyXzJdKysgLSAxKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGkgPj0gMCAmJiBkdDsgLS1pKSB7XG4gICAgICAgICAgICB2YXIgaTJfMyA9IHQyW2ldLnM7XG4gICAgICAgICAgICBpZiAodHJbaTJfM10gPT0gbWIpIHtcbiAgICAgICAgICAgICAgICAtLXRyW2kyXzNdO1xuICAgICAgICAgICAgICAgICsrZHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWJ0ID0gbWI7XG4gICAgfVxuICAgIHJldHVybiBbbmV3IHU4KHRyKSwgbWJ0XTtcbn07XG4vLyBnZXQgdGhlIG1heCBsZW5ndGggYW5kIGFzc2lnbiBsZW5ndGggY29kZXNcbnZhciBsbiA9IGZ1bmN0aW9uIChuLCBsLCBkKSB7XG4gICAgcmV0dXJuIG4ucyA9PSAtMVxuICAgICAgICA/IE1hdGgubWF4KGxuKG4ubCwgbCwgZCArIDEpLCBsbihuLnIsIGwsIGQgKyAxKSlcbiAgICAgICAgOiAobFtuLnNdID0gZCk7XG59O1xuLy8gbGVuZ3RoIGNvZGVzIGdlbmVyYXRpb25cbnZhciBsYyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgdmFyIHMgPSBjLmxlbmd0aDtcbiAgICAvLyBOb3RlIHRoYXQgdGhlIHNlbWljb2xvbiB3YXMgaW50ZW50aW9uYWxcbiAgICB3aGlsZSAocyAmJiAhY1stLXNdKVxuICAgICAgICA7XG4gICAgdmFyIGNsID0gbmV3IHUxNigrK3MpO1xuICAgIC8vICBpbmQgICAgICBudW0gICAgICAgICBzdHJlYWtcbiAgICB2YXIgY2xpID0gMCwgY2xuID0gY1swXSwgY2xzID0gMTtcbiAgICB2YXIgdyA9IGZ1bmN0aW9uICh2KSB7IGNsW2NsaSsrXSA9IHY7IH07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gczsgKytpKSB7XG4gICAgICAgIGlmIChjW2ldID09IGNsbiAmJiBpICE9IHMpXG4gICAgICAgICAgICArK2NscztcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWNsbiAmJiBjbHMgPiAyKSB7XG4gICAgICAgICAgICAgICAgZm9yICg7IGNscyA+IDEzODsgY2xzIC09IDEzOClcbiAgICAgICAgICAgICAgICAgICAgdygzMjc1NCk7XG4gICAgICAgICAgICAgICAgaWYgKGNscyA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdyhjbHMgPiAxMCA/ICgoY2xzIC0gMTEpIDw8IDUpIHwgMjg2OTAgOiAoKGNscyAtIDMpIDw8IDUpIHwgMTIzMDUpO1xuICAgICAgICAgICAgICAgICAgICBjbHMgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNscyA+IDMpIHtcbiAgICAgICAgICAgICAgICB3KGNsbiksIC0tY2xzO1xuICAgICAgICAgICAgICAgIGZvciAoOyBjbHMgPiA2OyBjbHMgLT0gNilcbiAgICAgICAgICAgICAgICAgICAgdyg4MzA0KTtcbiAgICAgICAgICAgICAgICBpZiAoY2xzID4gMilcbiAgICAgICAgICAgICAgICAgICAgdygoKGNscyAtIDMpIDw8IDUpIHwgODIwOCksIGNscyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2xzLS0pXG4gICAgICAgICAgICAgICAgdyhjbG4pO1xuICAgICAgICAgICAgY2xzID0gMTtcbiAgICAgICAgICAgIGNsbiA9IGNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtjbC5zdWJhcnJheSgwLCBjbGkpLCBzXTtcbn07XG4vLyBjYWxjdWxhdGUgdGhlIGxlbmd0aCBvZiBvdXRwdXQgZnJvbSB0cmVlLCBjb2RlIGxlbmd0aHNcbnZhciBjbGVuID0gZnVuY3Rpb24gKGNmLCBjbCkge1xuICAgIHZhciBsID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsLmxlbmd0aDsgKytpKVxuICAgICAgICBsICs9IGNmW2ldICogY2xbaV07XG4gICAgcmV0dXJuIGw7XG59O1xuLy8gd3JpdGVzIGEgZml4ZWQgYmxvY2tcbi8vIHJldHVybnMgdGhlIG5ldyBiaXQgcG9zXG52YXIgd2ZibGsgPSBmdW5jdGlvbiAob3V0LCBwb3MsIGRhdCkge1xuICAgIC8vIG5vIG5lZWQgdG8gd3JpdGUgMDAgYXMgdHlwZTogVHlwZWRBcnJheSBkZWZhdWx0cyB0byAwXG4gICAgdmFyIHMgPSBkYXQubGVuZ3RoO1xuICAgIHZhciBvID0gc2hmdChwb3MgKyAyKTtcbiAgICBvdXRbb10gPSBzICYgMjU1O1xuICAgIG91dFtvICsgMV0gPSBzID4+PiA4O1xuICAgIG91dFtvICsgMl0gPSBvdXRbb10gXiAyNTU7XG4gICAgb3V0W28gKyAzXSA9IG91dFtvICsgMV0gXiAyNTU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyArK2kpXG4gICAgICAgIG91dFtvICsgaSArIDRdID0gZGF0W2ldO1xuICAgIHJldHVybiAobyArIDQgKyBzKSAqIDg7XG59O1xuLy8gd3JpdGVzIGEgYmxvY2tcbnZhciB3YmxrID0gZnVuY3Rpb24gKGRhdCwgb3V0LCBmaW5hbCwgc3ltcywgbGYsIGRmLCBlYiwgbGksIGJzLCBibCwgcCkge1xuICAgIHdiaXRzKG91dCwgcCsrLCBmaW5hbCk7XG4gICAgKytsZlsyNTZdO1xuICAgIHZhciBfYSA9IGhUcmVlKGxmLCAxNSksIGRsdCA9IF9hWzBdLCBtbGIgPSBfYVsxXTtcbiAgICB2YXIgX2IgPSBoVHJlZShkZiwgMTUpLCBkZHQgPSBfYlswXSwgbWRiID0gX2JbMV07XG4gICAgdmFyIF9jID0gbGMoZGx0KSwgbGNsdCA9IF9jWzBdLCBubGMgPSBfY1sxXTtcbiAgICB2YXIgX2QgPSBsYyhkZHQpLCBsY2R0ID0gX2RbMF0sIG5kYyA9IF9kWzFdO1xuICAgIHZhciBsY2ZyZXEgPSBuZXcgdTE2KDE5KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxjbHQubGVuZ3RoOyArK2kpXG4gICAgICAgIGxjZnJlcVtsY2x0W2ldICYgMzFdKys7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsY2R0Lmxlbmd0aDsgKytpKVxuICAgICAgICBsY2ZyZXFbbGNkdFtpXSAmIDMxXSsrO1xuICAgIHZhciBfZSA9IGhUcmVlKGxjZnJlcSwgNyksIGxjdCA9IF9lWzBdLCBtbGNiID0gX2VbMV07XG4gICAgdmFyIG5sY2MgPSAxOTtcbiAgICBmb3IgKDsgbmxjYyA+IDQgJiYgIWxjdFtjbGltW25sY2MgLSAxXV07IC0tbmxjYylcbiAgICAgICAgO1xuICAgIHZhciBmbGVuID0gKGJsICsgNSkgPDwgMztcbiAgICB2YXIgZnRsZW4gPSBjbGVuKGxmLCBmbHQpICsgY2xlbihkZiwgZmR0KSArIGViO1xuICAgIHZhciBkdGxlbiA9IGNsZW4obGYsIGRsdCkgKyBjbGVuKGRmLCBkZHQpICsgZWIgKyAxNCArIDMgKiBubGNjICsgY2xlbihsY2ZyZXEsIGxjdCkgKyAoMiAqIGxjZnJlcVsxNl0gKyAzICogbGNmcmVxWzE3XSArIDcgKiBsY2ZyZXFbMThdKTtcbiAgICBpZiAoZmxlbiA8PSBmdGxlbiAmJiBmbGVuIDw9IGR0bGVuKVxuICAgICAgICByZXR1cm4gd2ZibGsob3V0LCBwLCBkYXQuc3ViYXJyYXkoYnMsIGJzICsgYmwpKTtcbiAgICB2YXIgbG0sIGxsLCBkbSwgZGw7XG4gICAgd2JpdHMob3V0LCBwLCAxICsgKGR0bGVuIDwgZnRsZW4pKSwgcCArPSAyO1xuICAgIGlmIChkdGxlbiA8IGZ0bGVuKSB7XG4gICAgICAgIGxtID0gaE1hcChkbHQsIG1sYiwgMCksIGxsID0gZGx0LCBkbSA9IGhNYXAoZGR0LCBtZGIsIDApLCBkbCA9IGRkdDtcbiAgICAgICAgdmFyIGxsbSA9IGhNYXAobGN0LCBtbGNiLCAwKTtcbiAgICAgICAgd2JpdHMob3V0LCBwLCBubGMgLSAyNTcpO1xuICAgICAgICB3Yml0cyhvdXQsIHAgKyA1LCBuZGMgLSAxKTtcbiAgICAgICAgd2JpdHMob3V0LCBwICsgMTAsIG5sY2MgLSA0KTtcbiAgICAgICAgcCArPSAxNDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBubGNjOyArK2kpXG4gICAgICAgICAgICB3Yml0cyhvdXQsIHAgKyAzICogaSwgbGN0W2NsaW1baV1dKTtcbiAgICAgICAgcCArPSAzICogbmxjYztcbiAgICAgICAgdmFyIGxjdHMgPSBbbGNsdCwgbGNkdF07XG4gICAgICAgIGZvciAodmFyIGl0ID0gMDsgaXQgPCAyOyArK2l0KSB7XG4gICAgICAgICAgICB2YXIgY2xjdCA9IGxjdHNbaXRdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IGNsY3RbaV0gJiAzMTtcbiAgICAgICAgICAgICAgICB3Yml0cyhvdXQsIHAsIGxsbVtsZW5dKSwgcCArPSBsY3RbbGVuXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMTUpXG4gICAgICAgICAgICAgICAgICAgIHdiaXRzKG91dCwgcCwgKGNsY3RbaV0gPj4+IDUpICYgMTI3KSwgcCArPSBjbGN0W2ldID4+PiAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbG0gPSBmbG0sIGxsID0gZmx0LCBkbSA9IGZkbSwgZGwgPSBmZHQ7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGk7ICsraSkge1xuICAgICAgICBpZiAoc3ltc1tpXSA+IDI1NSkge1xuICAgICAgICAgICAgdmFyIGxlbiA9IChzeW1zW2ldID4+PiAxOCkgJiAzMTtcbiAgICAgICAgICAgIHdiaXRzMTYob3V0LCBwLCBsbVtsZW4gKyAyNTddKSwgcCArPSBsbFtsZW4gKyAyNTddO1xuICAgICAgICAgICAgaWYgKGxlbiA+IDcpXG4gICAgICAgICAgICAgICAgd2JpdHMob3V0LCBwLCAoc3ltc1tpXSA+Pj4gMjMpICYgMzEpLCBwICs9IGZsZWJbbGVuXTtcbiAgICAgICAgICAgIHZhciBkc3QgPSBzeW1zW2ldICYgMzE7XG4gICAgICAgICAgICB3Yml0czE2KG91dCwgcCwgZG1bZHN0XSksIHAgKz0gZGxbZHN0XTtcbiAgICAgICAgICAgIGlmIChkc3QgPiAzKVxuICAgICAgICAgICAgICAgIHdiaXRzMTYob3V0LCBwLCAoc3ltc1tpXSA+Pj4gNSkgJiA4MTkxKSwgcCArPSBmZGViW2RzdF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3Yml0czE2KG91dCwgcCwgbG1bc3ltc1tpXV0pLCBwICs9IGxsW3N5bXNbaV1dO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdiaXRzMTYob3V0LCBwLCBsbVsyNTZdKTtcbiAgICByZXR1cm4gcCArIGxsWzI1Nl07XG59O1xuLy8gZGVmbGF0ZSBvcHRpb25zIChuaWNlIDw8IDEzKSB8IGNoYWluXG52YXIgZGVvID0gLyojX19QVVJFX18qLyBuZXcgdTMyKFs2NTU0MCwgMTMxMDgwLCAxMzEwODgsIDEzMTEwNCwgMjYyMTc2LCAxMDQ4NzA0LCAxMDQ4ODMyLCAyMTE0NTYwLCAyMTE3NjMyXSk7XG4vLyBlbXB0eVxudmFyIGV0ID0gLyojX19QVVJFX18qLyBuZXcgdTgoMCk7XG4vLyBjb21wcmVzc2VzIGRhdGEgaW50byBhIHJhdyBERUZMQVRFIGJ1ZmZlclxudmFyIGRmbHQgPSBmdW5jdGlvbiAoZGF0LCBsdmwsIHBsdmwsIHByZSwgcG9zdCwgbHN0KSB7XG4gICAgdmFyIHMgPSBkYXQubGVuZ3RoO1xuICAgIHZhciBvID0gbmV3IHU4KHByZSArIHMgKyA1ICogKDEgKyBNYXRoLmNlaWwocyAvIDcwMDApKSArIHBvc3QpO1xuICAgIC8vIHdyaXRpbmcgdG8gdGhpcyB3cml0ZXMgdG8gdGhlIG91dHB1dCBidWZmZXJcbiAgICB2YXIgdyA9IG8uc3ViYXJyYXkocHJlLCBvLmxlbmd0aCAtIHBvc3QpO1xuICAgIHZhciBwb3MgPSAwO1xuICAgIGlmICghbHZsIHx8IHMgPCA4KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHM7IGkgKz0gNjU1MzUpIHtcbiAgICAgICAgICAgIC8vIGVuZFxuICAgICAgICAgICAgdmFyIGUgPSBpICsgNjU1MzU7XG4gICAgICAgICAgICBpZiAoZSA8IHMpIHtcbiAgICAgICAgICAgICAgICAvLyB3cml0ZSBmdWxsIGJsb2NrXG4gICAgICAgICAgICAgICAgcG9zID0gd2ZibGsodywgcG9zLCBkYXQuc3ViYXJyYXkoaSwgZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd3JpdGUgZmluYWwgYmxvY2tcbiAgICAgICAgICAgICAgICB3W2ldID0gbHN0O1xuICAgICAgICAgICAgICAgIHBvcyA9IHdmYmxrKHcsIHBvcywgZGF0LnN1YmFycmF5KGksIHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIG9wdCA9IGRlb1tsdmwgLSAxXTtcbiAgICAgICAgdmFyIG4gPSBvcHQgPj4+IDEzLCBjID0gb3B0ICYgODE5MTtcbiAgICAgICAgdmFyIG1za18xID0gKDEgPDwgcGx2bCkgLSAxO1xuICAgICAgICAvLyAgICBwcmV2IDItYnl0ZSB2YWwgbWFwICAgIGN1cnIgMi1ieXRlIHZhbCBtYXBcbiAgICAgICAgdmFyIHByZXYgPSBuZXcgdTE2KDMyNzY4KSwgaGVhZCA9IG5ldyB1MTYobXNrXzEgKyAxKTtcbiAgICAgICAgdmFyIGJzMV8xID0gTWF0aC5jZWlsKHBsdmwgLyAzKSwgYnMyXzEgPSAyICogYnMxXzE7XG4gICAgICAgIHZhciBoc2ggPSBmdW5jdGlvbiAoaSkgeyByZXR1cm4gKGRhdFtpXSBeIChkYXRbaSArIDFdIDw8IGJzMV8xKSBeIChkYXRbaSArIDJdIDw8IGJzMl8xKSkgJiBtc2tfMTsgfTtcbiAgICAgICAgLy8gMjQ1NzYgaXMgYW4gYXJiaXRyYXJ5IG51bWJlciBvZiBtYXhpbXVtIHN5bWJvbHMgcGVyIGJsb2NrXG4gICAgICAgIC8vIDQyNCBidWZmZXIgZm9yIGxhc3QgYmxvY2tcbiAgICAgICAgdmFyIHN5bXMgPSBuZXcgdTMyKDI1MDAwKTtcbiAgICAgICAgLy8gbGVuZ3RoL2xpdGVyYWwgZnJlcSAgIGRpc3RhbmNlIGZyZXFcbiAgICAgICAgdmFyIGxmID0gbmV3IHUxNigyODgpLCBkZiA9IG5ldyB1MTYoMzIpO1xuICAgICAgICAvLyAgbC9sY250ICBleGJpdHMgIGluZGV4ICBsL2xpbmQgIHdhaXRkeCAgYml0cG9zXG4gICAgICAgIHZhciBsY18xID0gMCwgZWIgPSAwLCBpID0gMCwgbGkgPSAwLCB3aSA9IDAsIGJzID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCBzOyArK2kpIHtcbiAgICAgICAgICAgIC8vIGhhc2ggdmFsdWVcbiAgICAgICAgICAgIC8vIGRlb3B0IHdoZW4gaSA+IHMgLSAzIC0gYXQgZW5kLCBkZW9wdCBhY2NlcHRhYmxlXG4gICAgICAgICAgICB2YXIgaHYgPSBoc2goaSk7XG4gICAgICAgICAgICAvLyBpbmRleCBtb2QgMzI3NjggICAgcHJldmlvdXMgaW5kZXggbW9kXG4gICAgICAgICAgICB2YXIgaW1vZCA9IGkgJiAzMjc2NywgcGltb2QgPSBoZWFkW2h2XTtcbiAgICAgICAgICAgIHByZXZbaW1vZF0gPSBwaW1vZDtcbiAgICAgICAgICAgIGhlYWRbaHZdID0gaW1vZDtcbiAgICAgICAgICAgIC8vIFdlIGFsd2F5cyBzaG91bGQgbW9kaWZ5IGhlYWQgYW5kIHByZXYsIGJ1dCBvbmx5IGFkZCBzeW1ib2xzIGlmXG4gICAgICAgICAgICAvLyB0aGlzIGRhdGEgaXMgbm90IHlldCBwcm9jZXNzZWQgKFwid2FpdFwiIGZvciB3YWl0IGluZGV4KVxuICAgICAgICAgICAgaWYgKHdpIDw9IGkpIHtcbiAgICAgICAgICAgICAgICAvLyBieXRlcyByZW1haW5pbmdcbiAgICAgICAgICAgICAgICB2YXIgcmVtID0gcyAtIGk7XG4gICAgICAgICAgICAgICAgaWYgKChsY18xID4gNzAwMCB8fCBsaSA+IDI0NTc2KSAmJiByZW0gPiA0MjMpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gd2JsayhkYXQsIHcsIDAsIHN5bXMsIGxmLCBkZiwgZWIsIGxpLCBicywgaSAtIGJzLCBwb3MpO1xuICAgICAgICAgICAgICAgICAgICBsaSA9IGxjXzEgPSBlYiA9IDAsIGJzID0gaTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAyODY7ICsrailcbiAgICAgICAgICAgICAgICAgICAgICAgIGxmW2pdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAzMDsgKytqKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGZbal0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAgbGVuICAgIGRpc3QgICBjaGFpblxuICAgICAgICAgICAgICAgIHZhciBsID0gMiwgZCA9IDAsIGNoXzEgPSBjLCBkaWYgPSAoaW1vZCAtIHBpbW9kKSAmIDMyNzY3O1xuICAgICAgICAgICAgICAgIGlmIChyZW0gPiAyICYmIGh2ID09IGhzaChpIC0gZGlmKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4biA9IE1hdGgubWluKG4sIHJlbSkgLSAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4ZCA9IE1hdGgubWluKDMyNzY3LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWF4IHBvc3NpYmxlIGxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAvLyBub3QgY2FwcGVkIGF0IGRpZiBiZWNhdXNlIGRlY29tcHJlc3NvcnMgaW1wbGVtZW50IFwicm9sbGluZ1wiIGluZGV4IHBvcHVsYXRpb25cbiAgICAgICAgICAgICAgICAgICAgdmFyIG1sID0gTWF0aC5taW4oMjU4LCByZW0pO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZGlmIDw9IG1heGQgJiYgLS1jaF8xICYmIGltb2QgIT0gcGltb2QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRbaSArIGxdID09IGRhdFtpICsgbCAtIGRpZl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmwgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBubCA8IG1sICYmIGRhdFtpICsgbmxdID09IGRhdFtpICsgbmwgLSBkaWZdOyArK25sKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5sID4gbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gbmwsIGQgPSBkaWY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJyZWFrIG91dCBlYXJseSB3aGVuIHdlIHJlYWNoIFwibmljZVwiICh3ZSBhcmUgc2F0aXNmaWVkIGVub3VnaClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5sID4gbWF4bilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3csIGZpbmQgdGhlIHJhcmVzdCAyLWJ5dGUgc2VxdWVuY2Ugd2l0aGluIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGVuZ3RoIG9mIGxpdGVyYWxzIGFuZCBzZWFyY2ggZm9yIHRoYXQgaW5zdGVhZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTXVjaCBmYXN0ZXIgdGhhbiBqdXN0IHVzaW5nIHRoZSBzdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW1kID0gTWF0aC5taW4oZGlmLCBubCAtIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1tZDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGkgPSAoaSAtIGRpZiArIGogKyAzMjc2OCkgJiAzMjc2NztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwdGkgPSBwcmV2W3RpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjZCA9ICh0aSAtIHB0aSArIDMyNzY4KSAmIDMyNzY3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNkID4gbWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWQgPSBjZCwgcGltb2QgPSB0aTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRoZSBwcmV2aW91cyBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1vZCA9IHBpbW9kLCBwaW1vZCA9IHByZXZbaW1vZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWYgKz0gKGltb2QgLSBwaW1vZCArIDMyNzY4KSAmIDMyNzY3O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGQgd2lsbCBiZSBub256ZXJvIG9ubHkgd2hlbiBhIG1hdGNoIHdhcyBmb3VuZFxuICAgICAgICAgICAgICAgIGlmIChkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIGJvdGggZGlzdCBhbmQgbGVuIGRhdGEgaW4gb25lIFVpbnQzMlxuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhpcyBpcyByZWNvZ25pemVkIGFzIGEgbGVuL2Rpc3Qgd2l0aCAyOHRoIGJpdCAoMl4yOClcbiAgICAgICAgICAgICAgICAgICAgc3ltc1tsaSsrXSA9IDI2ODQzNTQ1NiB8IChyZXZmbFtsXSA8PCAxOCkgfCByZXZmZFtkXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbiA9IHJldmZsW2xdICYgMzEsIGRpbiA9IHJldmZkW2RdICYgMzE7XG4gICAgICAgICAgICAgICAgICAgIGViICs9IGZsZWJbbGluXSArIGZkZWJbZGluXTtcbiAgICAgICAgICAgICAgICAgICAgKytsZlsyNTcgKyBsaW5dO1xuICAgICAgICAgICAgICAgICAgICArK2RmW2Rpbl07XG4gICAgICAgICAgICAgICAgICAgIHdpID0gaSArIGw7XG4gICAgICAgICAgICAgICAgICAgICsrbGNfMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bXNbbGkrK10gPSBkYXRbaV07XG4gICAgICAgICAgICAgICAgICAgICsrbGZbZGF0W2ldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gd2JsayhkYXQsIHcsIGxzdCwgc3ltcywgbGYsIGRmLCBlYiwgbGksIGJzLCBpIC0gYnMsIHBvcyk7XG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIGVhc2llc3Qgd2F5IHRvIGF2b2lkIG5lZWRpbmcgdG8gbWFpbnRhaW4gc3RhdGVcbiAgICAgICAgaWYgKCFsc3QgJiYgcG9zICYgNylcbiAgICAgICAgICAgIHBvcyA9IHdmYmxrKHcsIHBvcyArIDEsIGV0KTtcbiAgICB9XG4gICAgcmV0dXJuIHNsYyhvLCAwLCBwcmUgKyBzaGZ0KHBvcykgKyBwb3N0KTtcbn07XG4vLyBDUkMzMiB0YWJsZVxudmFyIGNyY3QgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHQgPSBuZXcgdTMyKDI1Nik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICAgICAgICB2YXIgYyA9IGksIGsgPSA5O1xuICAgICAgICB3aGlsZSAoLS1rKVxuICAgICAgICAgICAgYyA9ICgoYyAmIDEpICYmIDB4RURCODgzMjApIF4gKGMgPj4+IDEpO1xuICAgICAgICB0W2ldID0gYztcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG59KSgpO1xuLy8gQ1JDMzJcbnZhciBjcmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGMgPSAtMTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgLy8gY2xvc3VyZXMgaGF2ZSBhd2Z1bCBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgdmFyIGNyID0gYztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBjciA9IGNyY3RbKGNyICYgMjU1KSBeIGRbaV1dIF4gKGNyID4+PiA4KTtcbiAgICAgICAgICAgIGMgPSBjcjtcbiAgICAgICAgfSxcbiAgICAgICAgZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gfmM7IH1cbiAgICB9O1xufTtcbi8vIEFsZGVyMzJcbnZhciBhZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYSA9IDEsIGIgPSAwO1xuICAgIHJldHVybiB7XG4gICAgICAgIHA6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAvLyBjbG9zdXJlcyBoYXZlIGF3ZnVsIHBlcmZvcm1hbmNlXG4gICAgICAgICAgICB2YXIgbiA9IGEsIG0gPSBiO1xuICAgICAgICAgICAgdmFyIGwgPSBkLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9IGw7KSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBNYXRoLm1pbihpICsgMjY1NSwgbCk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBlOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIG0gKz0gbiArPSBkW2ldO1xuICAgICAgICAgICAgICAgIG4gPSAobiAmIDY1NTM1KSArIDE1ICogKG4gPj4gMTYpLCBtID0gKG0gJiA2NTUzNSkgKyAxNSAqIChtID4+IDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGEgPSBuLCBiID0gbTtcbiAgICAgICAgfSxcbiAgICAgICAgZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYSAlPSA2NTUyMSwgYiAlPSA2NTUyMTtcbiAgICAgICAgICAgIHJldHVybiAoYSAmIDI1NSkgPDwgMjQgfCAoYSA+Pj4gOCkgPDwgMTYgfCAoYiAmIDI1NSkgPDwgOCB8IChiID4+PiA4KTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuO1xuLy8gZGVmbGF0ZSB3aXRoIG9wdHNcbnZhciBkb3B0ID0gZnVuY3Rpb24gKGRhdCwgb3B0LCBwcmUsIHBvc3QsIHN0KSB7XG4gICAgcmV0dXJuIGRmbHQoZGF0LCBvcHQubGV2ZWwgPT0gbnVsbCA/IDYgOiBvcHQubGV2ZWwsIG9wdC5tZW0gPT0gbnVsbCA/IE1hdGguY2VpbChNYXRoLm1heCg4LCBNYXRoLm1pbigxMywgTWF0aC5sb2coZGF0Lmxlbmd0aCkpKSAqIDEuNSkgOiAoMTIgKyBvcHQubWVtKSwgcHJlLCBwb3N0LCAhc3QpO1xufTtcbi8vIFdhbG1hcnQgb2JqZWN0IHNwcmVhZFxudmFyIG1yZyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIG8gPSB7fTtcbiAgICBmb3IgKHZhciBrIGluIGEpXG4gICAgICAgIG9ba10gPSBhW2tdO1xuICAgIGZvciAodmFyIGsgaW4gYilcbiAgICAgICAgb1trXSA9IGJba107XG4gICAgcmV0dXJuIG87XG59O1xuLy8gd29ya2VyIGNsb25lXG4vLyBUaGlzIGlzIHBvc3NpYmx5IHRoZSBjcmF6aWVzdCBwYXJ0IG9mIHRoZSBlbnRpcmUgY29kZWJhc2UsIGRlc3BpdGUgaG93IHNpbXBsZSBpdCBtYXkgc2VlbS5cbi8vIFRoZSBvbmx5IHBhcmFtZXRlciB0byB0aGlzIGZ1bmN0aW9uIGlzIGEgY2xvc3VyZSB0aGF0IHJldHVybnMgYW4gYXJyYXkgb2YgdmFyaWFibGVzIG91dHNpZGUgb2YgdGhlIGZ1bmN0aW9uIHNjb3BlLlxuLy8gV2UncmUgZ29pbmcgdG8gdHJ5IHRvIGZpZ3VyZSBvdXQgdGhlIHZhcmlhYmxlIG5hbWVzIHVzZWQgaW4gdGhlIGNsb3N1cmUgYXMgc3RyaW5ncyBiZWNhdXNlIHRoYXQgaXMgY3J1Y2lhbCBmb3Igd29ya2VyaXphdGlvbi5cbi8vIFdlIHdpbGwgcmV0dXJuIGFuIG9iamVjdCBtYXBwaW5nIG9mIHRydWUgdmFyaWFibGUgbmFtZSB0byB2YWx1ZSAoYmFzaWNhbGx5LCB0aGUgY3VycmVudCBzY29wZSBhcyBhIEpTIG9iamVjdCkuXG4vLyBUaGUgcmVhc29uIHdlIGNhbid0IGp1c3QgdXNlIHRoZSBvcmlnaW5hbCB2YXJpYWJsZSBuYW1lcyBpcyBtaW5pZmllcnMgbWFuZ2xpbmcgdGhlIHRvcGxldmVsIHNjb3BlLlxuLy8gVGhpcyB0b29rIG1lIHRocmVlIHdlZWtzIHRvIGZpZ3VyZSBvdXQgaG93IHRvIGRvLlxudmFyIHdjbG4gPSBmdW5jdGlvbiAoZm4sIGZuU3RyLCB0ZCkge1xuICAgIHZhciBkdCA9IGZuKCk7XG4gICAgdmFyIHN0ID0gZm4udG9TdHJpbmcoKTtcbiAgICB2YXIga3MgPSBzdC5zbGljZShzdC5pbmRleE9mKCdbJykgKyAxLCBzdC5sYXN0SW5kZXhPZignXScpKS5yZXBsYWNlKC8gL2csICcnKS5zcGxpdCgnLCcpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZHQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHYgPSBkdFtpXSwgayA9IGtzW2ldO1xuICAgICAgICBpZiAodHlwZW9mIHYgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZm5TdHIgKz0gJzsnICsgayArICc9JztcbiAgICAgICAgICAgIHZhciBzdF8xID0gdi50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKHYucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIGdsb2JhbCBvYmplY3RzXG4gICAgICAgICAgICAgICAgaWYgKHN0XzEuaW5kZXhPZignW25hdGl2ZSBjb2RlXScpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcEluZCA9IHN0XzEuaW5kZXhPZignICcsIDgpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgZm5TdHIgKz0gc3RfMS5zbGljZShzcEluZCwgc3RfMS5pbmRleE9mKCcoJywgc3BJbmQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZuU3RyICs9IHN0XzE7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHQgaW4gdi5wcm90b3R5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBmblN0ciArPSAnOycgKyBrICsgJy5wcm90b3R5cGUuJyArIHQgKyAnPScgKyB2LnByb3RvdHlwZVt0XS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBmblN0ciArPSBzdF8xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRkW2tdID0gdjtcbiAgICB9XG4gICAgcmV0dXJuIFtmblN0ciwgdGRdO1xufTtcbnZhciBjaCA9IFtdO1xuLy8gY2xvbmUgYnVmc1xudmFyIGNiZnMgPSBmdW5jdGlvbiAodikge1xuICAgIHZhciB0bCA9IFtdO1xuICAgIGZvciAodmFyIGsgaW4gdikge1xuICAgICAgICBpZiAodltrXSBpbnN0YW5jZW9mIHU4IHx8IHZba10gaW5zdGFuY2VvZiB1MTYgfHwgdltrXSBpbnN0YW5jZW9mIHUzMilcbiAgICAgICAgICAgIHRsLnB1c2goKHZba10gPSBuZXcgdltrXS5jb25zdHJ1Y3Rvcih2W2tdKSkuYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRsO1xufTtcbi8vIHVzZSBhIHdvcmtlciB0byBleGVjdXRlIGNvZGVcbnZhciB3cmtyID0gZnVuY3Rpb24gKGZucywgaW5pdCwgaWQsIGNiKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghY2hbaWRdKSB7XG4gICAgICAgIHZhciBmblN0ciA9ICcnLCB0ZF8xID0ge30sIG0gPSBmbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtOyArK2kpXG4gICAgICAgICAgICBfYSA9IHdjbG4oZm5zW2ldLCBmblN0ciwgdGRfMSksIGZuU3RyID0gX2FbMF0sIHRkXzEgPSBfYVsxXTtcbiAgICAgICAgY2hbaWRdID0gd2NsbihmbnNbbV0sIGZuU3RyLCB0ZF8xKTtcbiAgICB9XG4gICAgdmFyIHRkID0gbXJnKHt9LCBjaFtpZF1bMV0pO1xuICAgIHJldHVybiB3ayhjaFtpZF1bMF0gKyAnO29ubWVzc2FnZT1mdW5jdGlvbihlKXtmb3IodmFyIGsgaW4gZS5kYXRhKXNlbGZba109ZS5kYXRhW2tdO29ubWVzc2FnZT0nICsgaW5pdC50b1N0cmluZygpICsgJ30nLCBpZCwgdGQsIGNiZnModGQpLCBjYik7XG59O1xuLy8gYmFzZSBhc3luYyBpbmZsYXRlIGZuXG52YXIgYkluZmx0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW3U4LCB1MTYsIHUzMiwgZmxlYiwgZmRlYiwgY2xpbSwgZmwsIGZkLCBmbHJtLCBmZHJtLCByZXYsIGhNYXAsIG1heCwgYml0cywgYml0czE2LCBzaGZ0LCBzbGMsIGluZmx0LCBpbmZsYXRlU3luYywgcGJmLCBndThdOyB9O1xudmFyIGJEZmx0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW3U4LCB1MTYsIHUzMiwgZmxlYiwgZmRlYiwgY2xpbSwgcmV2ZmwsIHJldmZkLCBmbG0sIGZsdCwgZmRtLCBmZHQsIHJldiwgZGVvLCBldCwgaE1hcCwgd2JpdHMsIHdiaXRzMTYsIGhUcmVlLCBsbiwgbGMsIGNsZW4sIHdmYmxrLCB3YmxrLCBzaGZ0LCBzbGMsIGRmbHQsIGRvcHQsIGRlZmxhdGVTeW5jLCBwYmZdOyB9O1xuLy8gZ3ppcCBleHRyYVxudmFyIGd6ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtnemgsIGd6aGwsIHdieXRlcywgY3JjLCBjcmN0XTsgfTtcbi8vIGd1bnppcCBleHRyYVxudmFyIGd1emUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbZ3pzLCBnemxdOyB9O1xuLy8gemxpYiBleHRyYVxudmFyIHpsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt6bGgsIHdieXRlcywgYWRsZXJdOyB9O1xuLy8gdW56bGliIGV4dHJhXG52YXIgenVsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt6bHZdOyB9O1xuLy8gcG9zdCBidWZcbnZhciBwYmYgPSBmdW5jdGlvbiAobXNnKSB7IHJldHVybiBwb3N0TWVzc2FnZShtc2csIFttc2cuYnVmZmVyXSk7IH07XG4vLyBnZXQgdThcbnZhciBndTggPSBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBvLnNpemUgJiYgbmV3IHU4KG8uc2l6ZSk7IH07XG4vLyBhc3luYyBoZWxwZXJcbnZhciBjYmlmeSA9IGZ1bmN0aW9uIChkYXQsIG9wdHMsIGZucywgaW5pdCwgaWQsIGNiKSB7XG4gICAgdmFyIHcgPSB3cmtyKGZucywgaW5pdCwgaWQsIGZ1bmN0aW9uIChlcnIsIGRhdCkge1xuICAgICAgICB3LnRlcm1pbmF0ZSgpO1xuICAgICAgICBjYihlcnIsIGRhdCk7XG4gICAgfSk7XG4gICAgdy5wb3N0TWVzc2FnZShbZGF0LCBvcHRzXSwgb3B0cy5jb25zdW1lID8gW2RhdC5idWZmZXJdIDogW10pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHcudGVybWluYXRlKCk7IH07XG59O1xuLy8gYXV0byBzdHJlYW1cbnZhciBhc3RybSA9IGZ1bmN0aW9uIChzdHJtKSB7XG4gICAgc3RybS5vbmRhdGEgPSBmdW5jdGlvbiAoZGF0LCBmaW5hbCkgeyByZXR1cm4gcG9zdE1lc3NhZ2UoW2RhdCwgZmluYWxdLCBbZGF0LmJ1ZmZlcl0pOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIHN0cm0ucHVzaChldi5kYXRhWzBdLCBldi5kYXRhWzFdKTsgfTtcbn07XG4vLyBhc3luYyBzdHJlYW0gYXR0YWNoXG52YXIgYXN0cm1pZnkgPSBmdW5jdGlvbiAoZm5zLCBzdHJtLCBvcHRzLCBpbml0LCBpZCkge1xuICAgIHZhciB0O1xuICAgIHZhciB3ID0gd3JrcihmbnMsIGluaXQsIGlkLCBmdW5jdGlvbiAoZXJyLCBkYXQpIHtcbiAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgIHcudGVybWluYXRlKCksIHN0cm0ub25kYXRhLmNhbGwoc3RybSwgZXJyKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZGF0WzFdKVxuICAgICAgICAgICAgICAgIHcudGVybWluYXRlKCk7XG4gICAgICAgICAgICBzdHJtLm9uZGF0YS5jYWxsKHN0cm0sIGVyciwgZGF0WzBdLCBkYXRbMV0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdy5wb3N0TWVzc2FnZShvcHRzKTtcbiAgICBzdHJtLnB1c2ggPSBmdW5jdGlvbiAoZCwgZikge1xuICAgICAgICBpZiAodClcbiAgICAgICAgICAgIHRocm93ICdzdHJlYW0gZmluaXNoZWQnO1xuICAgICAgICBpZiAoIXN0cm0ub25kYXRhKVxuICAgICAgICAgICAgdGhyb3cgJ25vIHN0cmVhbSBoYW5kbGVyJztcbiAgICAgICAgdy5wb3N0TWVzc2FnZShbZCwgdCA9IGZdLCBbZC5idWZmZXJdKTtcbiAgICB9O1xuICAgIHN0cm0udGVybWluYXRlID0gZnVuY3Rpb24gKCkgeyB3LnRlcm1pbmF0ZSgpOyB9O1xufTtcbi8vIHJlYWQgMiBieXRlc1xudmFyIGIyID0gZnVuY3Rpb24gKGQsIGIpIHsgcmV0dXJuIGRbYl0gfCAoZFtiICsgMV0gPDwgOCk7IH07XG4vLyByZWFkIDQgYnl0ZXNcbnZhciBiNCA9IGZ1bmN0aW9uIChkLCBiKSB7IHJldHVybiAoZFtiXSB8IChkW2IgKyAxXSA8PCA4KSB8IChkW2IgKyAyXSA8PCAxNikgfCAoZFtiICsgM10gPDwgMjQpKSA+Pj4gMDsgfTtcbnZhciBiOCA9IGZ1bmN0aW9uIChkLCBiKSB7IHJldHVybiBiNChkLCBiKSArIChiNChkLCBiICsgNCkgKiA0Mjk0OTY3Mjk2KTsgfTtcbi8vIHdyaXRlIGJ5dGVzXG52YXIgd2J5dGVzID0gZnVuY3Rpb24gKGQsIGIsIHYpIHtcbiAgICBmb3IgKDsgdjsgKytiKVxuICAgICAgICBkW2JdID0gdiwgdiA+Pj49IDg7XG59O1xuLy8gZ3ppcCBoZWFkZXJcbnZhciBnemggPSBmdW5jdGlvbiAoYywgbykge1xuICAgIHZhciBmbiA9IG8uZmlsZW5hbWU7XG4gICAgY1swXSA9IDMxLCBjWzFdID0gMTM5LCBjWzJdID0gOCwgY1s4XSA9IG8ubGV2ZWwgPCAyID8gNCA6IG8ubGV2ZWwgPT0gOSA/IDIgOiAwLCBjWzldID0gMzsgLy8gYXNzdW1lIFVuaXhcbiAgICBpZiAoby5tdGltZSAhPSAwKVxuICAgICAgICB3Ynl0ZXMoYywgNCwgTWF0aC5mbG9vcihuZXcgRGF0ZShvLm10aW1lIHx8IERhdGUubm93KCkpIC8gMTAwMCkpO1xuICAgIGlmIChmbikge1xuICAgICAgICBjWzNdID0gODtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gZm4ubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBjW2kgKyAxMF0gPSBmbi5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbn07XG4vLyBnemlwIGZvb3RlcjogLTggdG8gLTQgPSBDUkMsIC00IHRvIC0wIGlzIGxlbmd0aFxuLy8gZ3ppcCBzdGFydFxudmFyIGd6cyA9IGZ1bmN0aW9uIChkKSB7XG4gICAgaWYgKGRbMF0gIT0gMzEgfHwgZFsxXSAhPSAxMzkgfHwgZFsyXSAhPSA4KVxuICAgICAgICB0aHJvdyAnaW52YWxpZCBnemlwIGRhdGEnO1xuICAgIHZhciBmbGcgPSBkWzNdO1xuICAgIHZhciBzdCA9IDEwO1xuICAgIGlmIChmbGcgJiA0KVxuICAgICAgICBzdCArPSBkWzEwXSB8IChkWzExXSA8PCA4KSArIDI7XG4gICAgZm9yICh2YXIgenMgPSAoZmxnID4+IDMgJiAxKSArIChmbGcgPj4gNCAmIDEpOyB6cyA+IDA7IHpzIC09ICFkW3N0KytdKVxuICAgICAgICA7XG4gICAgcmV0dXJuIHN0ICsgKGZsZyAmIDIpO1xufTtcbi8vIGd6aXAgbGVuZ3RoXG52YXIgZ3psID0gZnVuY3Rpb24gKGQpIHtcbiAgICB2YXIgbCA9IGQubGVuZ3RoO1xuICAgIHJldHVybiAoKGRbbCAtIDRdIHwgZFtsIC0gM10gPDwgOCB8IGRbbCAtIDJdIDw8IDE2KSB8IChkW2wgLSAxXSA8PCAyNCkpID4+PiAwO1xufTtcbi8vIGd6aXAgaGVhZGVyIGxlbmd0aFxudmFyIGd6aGwgPSBmdW5jdGlvbiAobykgeyByZXR1cm4gMTAgKyAoKG8uZmlsZW5hbWUgJiYgKG8uZmlsZW5hbWUubGVuZ3RoICsgMSkpIHx8IDApOyB9O1xuLy8gemxpYiBoZWFkZXJcbnZhciB6bGggPSBmdW5jdGlvbiAoYywgbykge1xuICAgIHZhciBsdiA9IG8ubGV2ZWwsIGZsID0gbHYgPT0gMCA/IDAgOiBsdiA8IDYgPyAxIDogbHYgPT0gOSA/IDMgOiAyO1xuICAgIGNbMF0gPSAxMjAsIGNbMV0gPSAoZmwgPDwgNikgfCAoZmwgPyAoMzIgLSAyICogZmwpIDogMSk7XG59O1xuLy8gemxpYiB2YWxpZFxudmFyIHpsdiA9IGZ1bmN0aW9uIChkKSB7XG4gICAgaWYgKChkWzBdICYgMTUpICE9IDggfHwgKGRbMF0gPj4+IDQpID4gNyB8fCAoKGRbMF0gPDwgOCB8IGRbMV0pICUgMzEpKVxuICAgICAgICB0aHJvdyAnaW52YWxpZCB6bGliIGRhdGEnO1xuICAgIGlmIChkWzFdICYgMzIpXG4gICAgICAgIHRocm93ICdpbnZhbGlkIHpsaWIgZGF0YTogcHJlc2V0IGRpY3Rpb25hcmllcyBub3Qgc3VwcG9ydGVkJztcbn07XG5mdW5jdGlvbiBBc3luY0NtcFN0cm0ob3B0cywgY2IpIHtcbiAgICBpZiAoIWNiICYmIHR5cGVvZiBvcHRzID09ICdmdW5jdGlvbicpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgcmV0dXJuIG9wdHM7XG59XG4vLyB6bGliIGZvb3RlcjogLTQgdG8gLTAgaXMgQWRsZXIzMlxuLyoqXG4gKiBTdHJlYW1pbmcgREVGTEFURSBjb21wcmVzc2lvblxuICovXG52YXIgRGVmbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWZsYXRlKG9wdHMsIGNiKSB7XG4gICAgICAgIGlmICghY2IgJiYgdHlwZW9mIG9wdHMgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgICAgICB0aGlzLm8gPSBvcHRzIHx8IHt9O1xuICAgIH1cbiAgICBEZWZsYXRlLnByb3RvdHlwZS5wID0gZnVuY3Rpb24gKGMsIGYpIHtcbiAgICAgICAgdGhpcy5vbmRhdGEoZG9wdChjLCB0aGlzLm8sIDAsIDAsICFmKSwgZik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBkZWZsYXRlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBEZWZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBpZiAodGhpcy5kKVxuICAgICAgICAgICAgdGhyb3cgJ3N0cmVhbSBmaW5pc2hlZCc7XG4gICAgICAgIGlmICghdGhpcy5vbmRhdGEpXG4gICAgICAgICAgICB0aHJvdyAnbm8gc3RyZWFtIGhhbmRsZXInO1xuICAgICAgICB0aGlzLmQgPSBmaW5hbDtcbiAgICAgICAgdGhpcy5wKGNodW5rLCBmaW5hbCB8fCBmYWxzZSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVmbGF0ZTtcbn0oKSk7XG5leHBvcnQgeyBEZWZsYXRlIH07XG4vKipcbiAqIEFzeW5jaHJvbm91cyBzdHJlYW1pbmcgREVGTEFURSBjb21wcmVzc2lvblxuICovXG52YXIgQXN5bmNEZWZsYXRlID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFzeW5jRGVmbGF0ZShvcHRzLCBjYikge1xuICAgICAgICBhc3RybWlmeShbXG4gICAgICAgICAgICBiRGZsdCxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFthc3RybSwgRGVmbGF0ZV07IH1cbiAgICAgICAgXSwgdGhpcywgQXN5bmNDbXBTdHJtLmNhbGwodGhpcywgb3B0cywgY2IpLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzdHJtID0gbmV3IERlZmxhdGUoZXYuZGF0YSk7XG4gICAgICAgICAgICBvbm1lc3NhZ2UgPSBhc3RybShzdHJtKTtcbiAgICAgICAgfSwgNik7XG4gICAgfVxuICAgIHJldHVybiBBc3luY0RlZmxhdGU7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNEZWZsYXRlIH07XG5leHBvcnQgZnVuY3Rpb24gZGVmbGF0ZShkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICByZXR1cm4gY2JpZnkoZGF0YSwgb3B0cywgW1xuICAgICAgICBiRGZsdCxcbiAgICBdLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIHBiZihkZWZsYXRlU3luYyhldi5kYXRhWzBdLCBldi5kYXRhWzFdKSk7IH0sIDAsIGNiKTtcbn1cbi8qKlxuICogQ29tcHJlc3NlcyBkYXRhIHdpdGggREVGTEFURSB3aXRob3V0IGFueSB3cmFwcGVyXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBjb21wcmVzc1xuICogQHBhcmFtIG9wdHMgVGhlIGNvbXByZXNzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIFRoZSBkZWZsYXRlZCB2ZXJzaW9uIG9mIHRoZSBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZsYXRlU3luYyhkYXRhLCBvcHRzKSB7XG4gICAgcmV0dXJuIGRvcHQoZGF0YSwgb3B0cyB8fCB7fSwgMCwgMCk7XG59XG4vKipcbiAqIFN0cmVhbWluZyBERUZMQVRFIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIEluZmxhdGUgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbmZsYXRpb24gc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgaXMgaW5mbGF0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJbmZsYXRlKGNiKSB7XG4gICAgICAgIHRoaXMucyA9IHt9O1xuICAgICAgICB0aGlzLnAgPSBuZXcgdTgoMCk7XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgfVxuICAgIEluZmxhdGUucHJvdG90eXBlLmUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAodGhpcy5kKVxuICAgICAgICAgICAgdGhyb3cgJ3N0cmVhbSBmaW5pc2hlZCc7XG4gICAgICAgIGlmICghdGhpcy5vbmRhdGEpXG4gICAgICAgICAgICB0aHJvdyAnbm8gc3RyZWFtIGhhbmRsZXInO1xuICAgICAgICB2YXIgbCA9IHRoaXMucC5sZW5ndGg7XG4gICAgICAgIHZhciBuID0gbmV3IHU4KGwgKyBjLmxlbmd0aCk7XG4gICAgICAgIG4uc2V0KHRoaXMucCksIG4uc2V0KGMsIGwpLCB0aGlzLnAgPSBuO1xuICAgIH07XG4gICAgSW5mbGF0ZS5wcm90b3R5cGUuYyA9IGZ1bmN0aW9uIChmaW5hbCkge1xuICAgICAgICB0aGlzLmQgPSB0aGlzLnMuaSA9IGZpbmFsIHx8IGZhbHNlO1xuICAgICAgICB2YXIgYnRzID0gdGhpcy5zLmI7XG4gICAgICAgIHZhciBkdCA9IGluZmx0KHRoaXMucCwgdGhpcy5vLCB0aGlzLnMpO1xuICAgICAgICB0aGlzLm9uZGF0YShzbGMoZHQsIGJ0cywgdGhpcy5zLmIpLCB0aGlzLmQpO1xuICAgICAgICB0aGlzLm8gPSBzbGMoZHQsIHRoaXMucy5iIC0gMzI3NjgpLCB0aGlzLnMuYiA9IHRoaXMuby5sZW5ndGg7XG4gICAgICAgIHRoaXMucCA9IHNsYyh0aGlzLnAsICh0aGlzLnMucCAvIDgpIHwgMCksIHRoaXMucy5wICY9IDc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBpbmZsYXRlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGZpbmFsIGNodW5rXG4gICAgICovXG4gICAgSW5mbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgdGhpcy5lKGNodW5rKSwgdGhpcy5jKGZpbmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBJbmZsYXRlO1xufSgpKTtcbmV4cG9ydCB7IEluZmxhdGUgfTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBERUZMQVRFIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIEFzeW5jSW5mbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFzeW5jaHJvbm91cyBpbmZsYXRpb24gc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgaXMgZGVmbGF0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBc3luY0luZmxhdGUoY2IpIHtcbiAgICAgICAgdGhpcy5vbmRhdGEgPSBjYjtcbiAgICAgICAgYXN0cm1pZnkoW1xuICAgICAgICAgICAgYkluZmx0LFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gW2FzdHJtLCBJbmZsYXRlXTsgfVxuICAgICAgICBdLCB0aGlzLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3RybSA9IG5ldyBJbmZsYXRlKCk7XG4gICAgICAgICAgICBvbm1lc3NhZ2UgPSBhc3RybShzdHJtKTtcbiAgICAgICAgfSwgNyk7XG4gICAgfVxuICAgIHJldHVybiBBc3luY0luZmxhdGU7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNJbmZsYXRlIH07XG5leHBvcnQgZnVuY3Rpb24gaW5mbGF0ZShkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICByZXR1cm4gY2JpZnkoZGF0YSwgb3B0cywgW1xuICAgICAgICBiSW5mbHRcbiAgICBdLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIHBiZihpbmZsYXRlU3luYyhldi5kYXRhWzBdLCBndTgoZXYuZGF0YVsxXSkpKTsgfSwgMSwgY2IpO1xufVxuLyoqXG4gKiBFeHBhbmRzIERFRkxBVEUgZGF0YSB3aXRoIG5vIHdyYXBwZXJcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGRlY29tcHJlc3NcbiAqIEBwYXJhbSBvdXQgV2hlcmUgdG8gd3JpdGUgdGhlIGRhdGEuIFNhdmVzIG1lbW9yeSBpZiB5b3Uga25vdyB0aGUgZGVjb21wcmVzc2VkIHNpemUgYW5kIHByb3ZpZGUgYW4gb3V0cHV0IGJ1ZmZlciBvZiB0aGF0IGxlbmd0aC5cbiAqIEByZXR1cm5zIFRoZSBkZWNvbXByZXNzZWQgdmVyc2lvbiBvZiB0aGUgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5mbGF0ZVN5bmMoZGF0YSwgb3V0KSB7XG4gICAgcmV0dXJuIGluZmx0KGRhdGEsIG91dCk7XG59XG4vLyBiZWZvcmUgeW91IHllbGwgYXQgbWUgZm9yIG5vdCBqdXN0IHVzaW5nIGV4dGVuZHMsIG15IHJlYXNvbiBpcyB0aGF0IFRTIGluaGVyaXRhbmNlIGlzIGhhcmQgdG8gd29ya2VyaXplLlxuLyoqXG4gKiBTdHJlYW1pbmcgR1pJUCBjb21wcmVzc2lvblxuICovXG52YXIgR3ppcCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHemlwKG9wdHMsIGNiKSB7XG4gICAgICAgIHRoaXMuYyA9IGNyYygpO1xuICAgICAgICB0aGlzLmwgPSAwO1xuICAgICAgICB0aGlzLnYgPSAxO1xuICAgICAgICBEZWZsYXRlLmNhbGwodGhpcywgb3B0cywgY2IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBHWklQcGVkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIEd6aXAucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIERlZmxhdGUucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZmluYWwpO1xuICAgIH07XG4gICAgR3ppcC5wcm90b3R5cGUucCA9IGZ1bmN0aW9uIChjLCBmKSB7XG4gICAgICAgIHRoaXMuYy5wKGMpO1xuICAgICAgICB0aGlzLmwgKz0gYy5sZW5ndGg7XG4gICAgICAgIHZhciByYXcgPSBkb3B0KGMsIHRoaXMubywgdGhpcy52ICYmIGd6aGwodGhpcy5vKSwgZiAmJiA4LCAhZik7XG4gICAgICAgIGlmICh0aGlzLnYpXG4gICAgICAgICAgICBnemgocmF3LCB0aGlzLm8pLCB0aGlzLnYgPSAwO1xuICAgICAgICBpZiAoZilcbiAgICAgICAgICAgIHdieXRlcyhyYXcsIHJhdy5sZW5ndGggLSA4LCB0aGlzLmMuZCgpKSwgd2J5dGVzKHJhdywgcmF3Lmxlbmd0aCAtIDQsIHRoaXMubCk7XG4gICAgICAgIHRoaXMub25kYXRhKHJhdywgZik7XG4gICAgfTtcbiAgICByZXR1cm4gR3ppcDtcbn0oKSk7XG5leHBvcnQgeyBHemlwIH07XG4vKipcbiAqIEFzeW5jaHJvbm91cyBzdHJlYW1pbmcgR1pJUCBjb21wcmVzc2lvblxuICovXG52YXIgQXN5bmNHemlwID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFzeW5jR3ppcChvcHRzLCBjYikge1xuICAgICAgICBhc3RybWlmeShbXG4gICAgICAgICAgICBiRGZsdCxcbiAgICAgICAgICAgIGd6ZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFthc3RybSwgRGVmbGF0ZSwgR3ppcF07IH1cbiAgICAgICAgXSwgdGhpcywgQXN5bmNDbXBTdHJtLmNhbGwodGhpcywgb3B0cywgY2IpLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzdHJtID0gbmV3IEd6aXAoZXYuZGF0YSk7XG4gICAgICAgICAgICBvbm1lc3NhZ2UgPSBhc3RybShzdHJtKTtcbiAgICAgICAgfSwgOCk7XG4gICAgfVxuICAgIHJldHVybiBBc3luY0d6aXA7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNHemlwIH07XG5leHBvcnQgZnVuY3Rpb24gZ3ppcChkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICByZXR1cm4gY2JpZnkoZGF0YSwgb3B0cywgW1xuICAgICAgICBiRGZsdCxcbiAgICAgICAgZ3plLFxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbZ3ppcFN5bmNdOyB9XG4gICAgXSwgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBwYmYoZ3ppcFN5bmMoZXYuZGF0YVswXSwgZXYuZGF0YVsxXSkpOyB9LCAyLCBjYik7XG59XG4vKipcbiAqIENvbXByZXNzZXMgZGF0YSB3aXRoIEdaSVBcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGNvbXByZXNzXG4gKiBAcGFyYW0gb3B0cyBUaGUgY29tcHJlc3Npb24gb3B0aW9uc1xuICogQHJldHVybnMgVGhlIGd6aXBwZWQgdmVyc2lvbiBvZiB0aGUgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ3ppcFN5bmMoZGF0YSwgb3B0cykge1xuICAgIGlmICghb3B0cylcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgIHZhciBjID0gY3JjKCksIGwgPSBkYXRhLmxlbmd0aDtcbiAgICBjLnAoZGF0YSk7XG4gICAgdmFyIGQgPSBkb3B0KGRhdGEsIG9wdHMsIGd6aGwob3B0cyksIDgpLCBzID0gZC5sZW5ndGg7XG4gICAgcmV0dXJuIGd6aChkLCBvcHRzKSwgd2J5dGVzKGQsIHMgLSA4LCBjLmQoKSksIHdieXRlcyhkLCBzIC0gNCwgbCksIGQ7XG59XG4vKipcbiAqIFN0cmVhbWluZyBHWklQIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIEd1bnppcCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgR1VOWklQIHN0cmVhbVxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuZXZlciBkYXRhIGlzIGluZmxhdGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gR3VuemlwKGNiKSB7XG4gICAgICAgIHRoaXMudiA9IDE7XG4gICAgICAgIEluZmxhdGUuY2FsbCh0aGlzLCBjYik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIEdVTlpJUHBlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBHdW56aXAucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIEluZmxhdGUucHJvdG90eXBlLmUuY2FsbCh0aGlzLCBjaHVuayk7XG4gICAgICAgIGlmICh0aGlzLnYpIHtcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5wLmxlbmd0aCA+IDMgPyBnenModGhpcy5wKSA6IDQ7XG4gICAgICAgICAgICBpZiAocyA+PSB0aGlzLnAubGVuZ3RoICYmICFmaW5hbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnAgPSB0aGlzLnAuc3ViYXJyYXkocyksIHRoaXMudiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wLmxlbmd0aCA8IDgpXG4gICAgICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgZ3ppcCBzdHJlYW0nO1xuICAgICAgICAgICAgdGhpcy5wID0gdGhpcy5wLnN1YmFycmF5KDAsIC04KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBuZWNlc3NhcnkgdG8gcHJldmVudCBUUyBmcm9tIHVzaW5nIHRoZSBjbG9zdXJlIHZhbHVlXG4gICAgICAgIC8vIFRoaXMgYWxsb3dzIGZvciB3b3JrZXJpemF0aW9uIHRvIGZ1bmN0aW9uIGNvcnJlY3RseVxuICAgICAgICBJbmZsYXRlLnByb3RvdHlwZS5jLmNhbGwodGhpcywgZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIEd1bnppcDtcbn0oKSk7XG5leHBvcnQgeyBHdW56aXAgfTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBHWklQIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIEFzeW5jR3VuemlwID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXN5bmNocm9ub3VzIEdVTlpJUCBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBpcyBkZWZsYXRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFzeW5jR3VuemlwKGNiKSB7XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgICAgIGFzdHJtaWZ5KFtcbiAgICAgICAgICAgIGJJbmZsdCxcbiAgICAgICAgICAgIGd1emUsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbYXN0cm0sIEluZmxhdGUsIEd1bnppcF07IH1cbiAgICAgICAgXSwgdGhpcywgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0cm0gPSBuZXcgR3VuemlwKCk7XG4gICAgICAgICAgICBvbm1lc3NhZ2UgPSBhc3RybShzdHJtKTtcbiAgICAgICAgfSwgOSk7XG4gICAgfVxuICAgIHJldHVybiBBc3luY0d1bnppcDtcbn0oKSk7XG5leHBvcnQgeyBBc3luY0d1bnppcCB9O1xuZXhwb3J0IGZ1bmN0aW9uIGd1bnppcChkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICByZXR1cm4gY2JpZnkoZGF0YSwgb3B0cywgW1xuICAgICAgICBiSW5mbHQsXG4gICAgICAgIGd1emUsXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtndW56aXBTeW5jXTsgfVxuICAgIF0sIGZ1bmN0aW9uIChldikgeyByZXR1cm4gcGJmKGd1bnppcFN5bmMoZXYuZGF0YVswXSkpOyB9LCAzLCBjYik7XG59XG4vKipcbiAqIEV4cGFuZHMgR1pJUCBkYXRhXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBkZWNvbXByZXNzXG4gKiBAcGFyYW0gb3V0IFdoZXJlIHRvIHdyaXRlIHRoZSBkYXRhLiBHWklQIGFscmVhZHkgZW5jb2RlcyB0aGUgb3V0cHV0IHNpemUsIHNvIHByb3ZpZGluZyB0aGlzIGRvZXNuJ3Qgc2F2ZSBtZW1vcnkuXG4gKiBAcmV0dXJucyBUaGUgZGVjb21wcmVzc2VkIHZlcnNpb24gb2YgdGhlIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGd1bnppcFN5bmMoZGF0YSwgb3V0KSB7XG4gICAgcmV0dXJuIGluZmx0KGRhdGEuc3ViYXJyYXkoZ3pzKGRhdGEpLCAtOCksIG91dCB8fCBuZXcgdTgoZ3psKGRhdGEpKSk7XG59XG4vKipcbiAqIFN0cmVhbWluZyBabGliIGNvbXByZXNzaW9uXG4gKi9cbnZhciBabGliID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFpsaWIob3B0cywgY2IpIHtcbiAgICAgICAgdGhpcy5jID0gYWRsZXIoKTtcbiAgICAgICAgdGhpcy52ID0gMTtcbiAgICAgICAgRGVmbGF0ZS5jYWxsKHRoaXMsIG9wdHMsIGNiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgemxpYmJlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBabGliLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBEZWZsYXRlLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGZpbmFsKTtcbiAgICB9O1xuICAgIFpsaWIucHJvdG90eXBlLnAgPSBmdW5jdGlvbiAoYywgZikge1xuICAgICAgICB0aGlzLmMucChjKTtcbiAgICAgICAgdmFyIHJhdyA9IGRvcHQoYywgdGhpcy5vLCB0aGlzLnYgJiYgMiwgZiAmJiA0LCAhZik7XG4gICAgICAgIGlmICh0aGlzLnYpXG4gICAgICAgICAgICB6bGgocmF3LCB0aGlzLm8pLCB0aGlzLnYgPSAwO1xuICAgICAgICBpZiAoZilcbiAgICAgICAgICAgIHdieXRlcyhyYXcsIHJhdy5sZW5ndGggLSA0LCB0aGlzLmMuZCgpKTtcbiAgICAgICAgdGhpcy5vbmRhdGEocmF3LCBmKTtcbiAgICB9O1xuICAgIHJldHVybiBabGliO1xufSgpKTtcbmV4cG9ydCB7IFpsaWIgfTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBabGliIGNvbXByZXNzaW9uXG4gKi9cbnZhciBBc3luY1psaWIgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXN5bmNabGliKG9wdHMsIGNiKSB7XG4gICAgICAgIGFzdHJtaWZ5KFtcbiAgICAgICAgICAgIGJEZmx0LFxuICAgICAgICAgICAgemxlLFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gW2FzdHJtLCBEZWZsYXRlLCBabGliXTsgfVxuICAgICAgICBdLCB0aGlzLCBBc3luY0NtcFN0cm0uY2FsbCh0aGlzLCBvcHRzLCBjYiksIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHN0cm0gPSBuZXcgWmxpYihldi5kYXRhKTtcbiAgICAgICAgICAgIG9ubWVzc2FnZSA9IGFzdHJtKHN0cm0pO1xuICAgICAgICB9LCAxMCk7XG4gICAgfVxuICAgIHJldHVybiBBc3luY1psaWI7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNabGliIH07XG5leHBvcnQgZnVuY3Rpb24gemxpYihkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICByZXR1cm4gY2JpZnkoZGF0YSwgb3B0cywgW1xuICAgICAgICBiRGZsdCxcbiAgICAgICAgemxlLFxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbemxpYlN5bmNdOyB9XG4gICAgXSwgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBwYmYoemxpYlN5bmMoZXYuZGF0YVswXSwgZXYuZGF0YVsxXSkpOyB9LCA0LCBjYik7XG59XG4vKipcbiAqIENvbXByZXNzIGRhdGEgd2l0aCBabGliXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBjb21wcmVzc1xuICogQHBhcmFtIG9wdHMgVGhlIGNvbXByZXNzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIFRoZSB6bGliLWNvbXByZXNzZWQgdmVyc2lvbiBvZiB0aGUgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gemxpYlN5bmMoZGF0YSwgb3B0cykge1xuICAgIGlmICghb3B0cylcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgIHZhciBhID0gYWRsZXIoKTtcbiAgICBhLnAoZGF0YSk7XG4gICAgdmFyIGQgPSBkb3B0KGRhdGEsIG9wdHMsIDIsIDQpO1xuICAgIHJldHVybiB6bGgoZCwgb3B0cyksIHdieXRlcyhkLCBkLmxlbmd0aCAtIDQsIGEuZCgpKSwgZDtcbn1cbi8qKlxuICogU3RyZWFtaW5nIFpsaWIgZGVjb21wcmVzc2lvblxuICovXG52YXIgVW56bGliID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBabGliIGRlY29tcHJlc3Npb24gc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgaXMgaW5mbGF0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBVbnpsaWIoY2IpIHtcbiAgICAgICAgdGhpcy52ID0gMTtcbiAgICAgICAgSW5mbGF0ZS5jYWxsKHRoaXMsIGNiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgdW56bGliYmVkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIFVuemxpYi5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgSW5mbGF0ZS5wcm90b3R5cGUuZS5jYWxsKHRoaXMsIGNodW5rKTtcbiAgICAgICAgaWYgKHRoaXMudikge1xuICAgICAgICAgICAgaWYgKHRoaXMucC5sZW5ndGggPCAyICYmICFmaW5hbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnAgPSB0aGlzLnAuc3ViYXJyYXkoMiksIHRoaXMudiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wLmxlbmd0aCA8IDQpXG4gICAgICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgemxpYiBzdHJlYW0nO1xuICAgICAgICAgICAgdGhpcy5wID0gdGhpcy5wLnN1YmFycmF5KDAsIC00KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBuZWNlc3NhcnkgdG8gcHJldmVudCBUUyBmcm9tIHVzaW5nIHRoZSBjbG9zdXJlIHZhbHVlXG4gICAgICAgIC8vIFRoaXMgYWxsb3dzIGZvciB3b3JrZXJpemF0aW9uIHRvIGZ1bmN0aW9uIGNvcnJlY3RseVxuICAgICAgICBJbmZsYXRlLnByb3RvdHlwZS5jLmNhbGwodGhpcywgZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIFVuemxpYjtcbn0oKSk7XG5leHBvcnQgeyBVbnpsaWIgfTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBabGliIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIEFzeW5jVW56bGliID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXN5bmNocm9ub3VzIFpsaWIgZGVjb21wcmVzc2lvbiBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBpcyBkZWZsYXRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFzeW5jVW56bGliKGNiKSB7XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgICAgIGFzdHJtaWZ5KFtcbiAgICAgICAgICAgIGJJbmZsdCxcbiAgICAgICAgICAgIHp1bGUsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbYXN0cm0sIEluZmxhdGUsIFVuemxpYl07IH1cbiAgICAgICAgXSwgdGhpcywgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0cm0gPSBuZXcgVW56bGliKCk7XG4gICAgICAgICAgICBvbm1lc3NhZ2UgPSBhc3RybShzdHJtKTtcbiAgICAgICAgfSwgMTEpO1xuICAgIH1cbiAgICByZXR1cm4gQXN5bmNVbnpsaWI7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNVbnpsaWIgfTtcbmV4cG9ydCBmdW5jdGlvbiB1bnpsaWIoZGF0YSwgb3B0cywgY2IpIHtcbiAgICBpZiAoIWNiKVxuICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGNiICE9ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93ICdubyBjYWxsYmFjayc7XG4gICAgcmV0dXJuIGNiaWZ5KGRhdGEsIG9wdHMsIFtcbiAgICAgICAgYkluZmx0LFxuICAgICAgICB6dWxlLFxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbdW56bGliU3luY107IH1cbiAgICBdLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIHBiZih1bnpsaWJTeW5jKGV2LmRhdGFbMF0sIGd1OChldi5kYXRhWzFdKSkpOyB9LCA1LCBjYik7XG59XG4vKipcbiAqIEV4cGFuZHMgWmxpYiBkYXRhXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBkZWNvbXByZXNzXG4gKiBAcGFyYW0gb3V0IFdoZXJlIHRvIHdyaXRlIHRoZSBkYXRhLiBTYXZlcyBtZW1vcnkgaWYgeW91IGtub3cgdGhlIGRlY29tcHJlc3NlZCBzaXplIGFuZCBwcm92aWRlIGFuIG91dHB1dCBidWZmZXIgb2YgdGhhdCBsZW5ndGguXG4gKiBAcmV0dXJucyBUaGUgZGVjb21wcmVzc2VkIHZlcnNpb24gb2YgdGhlIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuemxpYlN5bmMoZGF0YSwgb3V0KSB7XG4gICAgcmV0dXJuIGluZmx0KCh6bHYoZGF0YSksIGRhdGEuc3ViYXJyYXkoMiwgLTQpKSwgb3V0KTtcbn1cbi8vIERlZmF1bHQgYWxnb3JpdGhtIGZvciBjb21wcmVzc2lvbiAodXNlZCBiZWNhdXNlIGhhdmluZyBhIGtub3duIG91dHB1dCBzaXplIGFsbG93cyBmYXN0ZXIgZGVjb21wcmVzc2lvbilcbmV4cG9ydCB7IGd6aXAgYXMgY29tcHJlc3MsIEFzeW5jR3ppcCBhcyBBc3luY0NvbXByZXNzIH07XG4vLyBEZWZhdWx0IGFsZ29yaXRobSBmb3IgY29tcHJlc3Npb24gKHVzZWQgYmVjYXVzZSBoYXZpbmcgYSBrbm93biBvdXRwdXQgc2l6ZSBhbGxvd3MgZmFzdGVyIGRlY29tcHJlc3Npb24pXG5leHBvcnQgeyBnemlwU3luYyBhcyBjb21wcmVzc1N5bmMsIEd6aXAgYXMgQ29tcHJlc3MgfTtcbi8qKlxuICogU3RyZWFtaW5nIEdaSVAsIFpsaWIsIG9yIHJhdyBERUZMQVRFIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIERlY29tcHJlc3MgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlY29tcHJlc3Npb24gc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgaXMgZGVjb21wcmVzc2VkXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGVjb21wcmVzcyhjYikge1xuICAgICAgICB0aGlzLkcgPSBHdW56aXA7XG4gICAgICAgIHRoaXMuSSA9IEluZmxhdGU7XG4gICAgICAgIHRoaXMuWiA9IFVuemxpYjtcbiAgICAgICAgdGhpcy5vbmRhdGEgPSBjYjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgZGVjb21wcmVzc2VkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIERlY29tcHJlc3MucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIGlmICghdGhpcy5vbmRhdGEpXG4gICAgICAgICAgICB0aHJvdyAnbm8gc3RyZWFtIGhhbmRsZXInO1xuICAgICAgICBpZiAoIXRoaXMucykge1xuICAgICAgICAgICAgaWYgKHRoaXMucCAmJiB0aGlzLnAubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBuZXcgdTgodGhpcy5wLmxlbmd0aCArIGNodW5rLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbi5zZXQodGhpcy5wKSwgbi5zZXQoY2h1bmssIHRoaXMucC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMucCA9IGNodW5rO1xuICAgICAgICAgICAgaWYgKHRoaXMucC5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzXzEgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBjYiA9IGZ1bmN0aW9uICgpIHsgX3RoaXNfMS5vbmRhdGEuYXBwbHkoX3RoaXNfMSwgYXJndW1lbnRzKTsgfTtcbiAgICAgICAgICAgICAgICB0aGlzLnMgPSAodGhpcy5wWzBdID09IDMxICYmIHRoaXMucFsxXSA9PSAxMzkgJiYgdGhpcy5wWzJdID09IDgpXG4gICAgICAgICAgICAgICAgICAgID8gbmV3IHRoaXMuRyhjYilcbiAgICAgICAgICAgICAgICAgICAgOiAoKHRoaXMucFswXSAmIDE1KSAhPSA4IHx8ICh0aGlzLnBbMF0gPj4gNCkgPiA3IHx8ICgodGhpcy5wWzBdIDw8IDggfCB0aGlzLnBbMV0pICUgMzEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXcgdGhpcy5JKGNiKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXcgdGhpcy5aKGNiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnMucHVzaCh0aGlzLnAsIGZpbmFsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnAgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucy5wdXNoKGNodW5rLCBmaW5hbCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVjb21wcmVzcztcbn0oKSk7XG5leHBvcnQgeyBEZWNvbXByZXNzIH07XG4vKipcbiAqIEFzeW5jaHJvbm91cyBzdHJlYW1pbmcgR1pJUCwgWmxpYiwgb3IgcmF3IERFRkxBVEUgZGVjb21wcmVzc2lvblxuICovXG52YXIgQXN5bmNEZWNvbXByZXNzID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFzeW5jaHJvbm91cyBkZWNvbXByZXNzaW9uIHN0cmVhbVxuICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBpcyBkZWNvbXByZXNzZWRcbiAgICovXG4gICAgZnVuY3Rpb24gQXN5bmNEZWNvbXByZXNzKGNiKSB7XG4gICAgICAgIHRoaXMuRyA9IEFzeW5jR3VuemlwO1xuICAgICAgICB0aGlzLkkgPSBBc3luY0luZmxhdGU7XG4gICAgICAgIHRoaXMuWiA9IEFzeW5jVW56bGliO1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBkZWNvbXByZXNzZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgQXN5bmNEZWNvbXByZXNzLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBEZWNvbXByZXNzLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGZpbmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBBc3luY0RlY29tcHJlc3M7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNEZWNvbXByZXNzIH07XG5leHBvcnQgZnVuY3Rpb24gZGVjb21wcmVzcyhkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICByZXR1cm4gKGRhdGFbMF0gPT0gMzEgJiYgZGF0YVsxXSA9PSAxMzkgJiYgZGF0YVsyXSA9PSA4KVxuICAgICAgICA/IGd1bnppcChkYXRhLCBvcHRzLCBjYilcbiAgICAgICAgOiAoKGRhdGFbMF0gJiAxNSkgIT0gOCB8fCAoZGF0YVswXSA+PiA0KSA+IDcgfHwgKChkYXRhWzBdIDw8IDggfCBkYXRhWzFdKSAlIDMxKSlcbiAgICAgICAgICAgID8gaW5mbGF0ZShkYXRhLCBvcHRzLCBjYilcbiAgICAgICAgICAgIDogdW56bGliKGRhdGEsIG9wdHMsIGNiKTtcbn1cbi8qKlxuICogRXhwYW5kcyBjb21wcmVzc2VkIEdaSVAsIFpsaWIsIG9yIHJhdyBERUZMQVRFIGRhdGEsIGF1dG9tYXRpY2FsbHkgZGV0ZWN0aW5nIHRoZSBmb3JtYXRcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGRlY29tcHJlc3NcbiAqIEBwYXJhbSBvdXQgV2hlcmUgdG8gd3JpdGUgdGhlIGRhdGEuIFNhdmVzIG1lbW9yeSBpZiB5b3Uga25vdyB0aGUgZGVjb21wcmVzc2VkIHNpemUgYW5kIHByb3ZpZGUgYW4gb3V0cHV0IGJ1ZmZlciBvZiB0aGF0IGxlbmd0aC5cbiAqIEByZXR1cm5zIFRoZSBkZWNvbXByZXNzZWQgdmVyc2lvbiBvZiB0aGUgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb21wcmVzc1N5bmMoZGF0YSwgb3V0KSB7XG4gICAgcmV0dXJuIChkYXRhWzBdID09IDMxICYmIGRhdGFbMV0gPT0gMTM5ICYmIGRhdGFbMl0gPT0gOClcbiAgICAgICAgPyBndW56aXBTeW5jKGRhdGEsIG91dClcbiAgICAgICAgOiAoKGRhdGFbMF0gJiAxNSkgIT0gOCB8fCAoZGF0YVswXSA+PiA0KSA+IDcgfHwgKChkYXRhWzBdIDw8IDggfCBkYXRhWzFdKSAlIDMxKSlcbiAgICAgICAgICAgID8gaW5mbGF0ZVN5bmMoZGF0YSwgb3V0KVxuICAgICAgICAgICAgOiB1bnpsaWJTeW5jKGRhdGEsIG91dCk7XG59XG4vLyBmbGF0dGVuIGEgZGlyZWN0b3J5IHN0cnVjdHVyZVxudmFyIGZsdG4gPSBmdW5jdGlvbiAoZCwgcCwgdCwgbykge1xuICAgIGZvciAodmFyIGsgaW4gZCkge1xuICAgICAgICB2YXIgdmFsID0gZFtrXSwgbiA9IHAgKyBrO1xuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgdTgpXG4gICAgICAgICAgICB0W25dID0gW3ZhbCwgb107XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSlcbiAgICAgICAgICAgIHRbbl0gPSBbdmFsWzBdLCBtcmcobywgdmFsWzFdKV07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZsdG4odmFsLCBuICsgJy8nLCB0LCBvKTtcbiAgICB9XG59O1xuLy8gdGV4dCBlbmNvZGVyXG52YXIgdGUgPSB0eXBlb2YgVGV4dEVuY29kZXIgIT0gJ3VuZGVmaW5lZCcgJiYgLyojX19QVVJFX18qLyBuZXcgVGV4dEVuY29kZXIoKTtcbi8vIHRleHQgZGVjb2RlclxudmFyIHRkID0gdHlwZW9mIFRleHREZWNvZGVyICE9ICd1bmRlZmluZWQnICYmIC8qI19fUFVSRV9fKi8gbmV3IFRleHREZWNvZGVyKCk7XG4vLyB0ZXh0IGRlY29kZXIgc3RyZWFtXG52YXIgdGRzID0gMDtcbnRyeSB7XG4gICAgdGQuZGVjb2RlKGV0LCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICB0ZHMgPSAxO1xufVxuY2F0Y2ggKGUpIHsgfVxuLy8gZGVjb2RlIFVURjhcbnZhciBkdXRmOCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgZm9yICh2YXIgciA9ICcnLCBpID0gMDs7KSB7XG4gICAgICAgIHZhciBjID0gZFtpKytdO1xuICAgICAgICB2YXIgZWIgPSAoYyA+IDEyNykgKyAoYyA+IDIyMykgKyAoYyA+IDIzOSk7XG4gICAgICAgIGlmIChpICsgZWIgPiBkLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBbciwgc2xjKGQsIGkgLSAxKV07XG4gICAgICAgIGlmICghZWIpXG4gICAgICAgICAgICByICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgIGVsc2UgaWYgKGViID09IDMpIHtcbiAgICAgICAgICAgIGMgPSAoKGMgJiAxNSkgPDwgMTggfCAoZFtpKytdICYgNjMpIDw8IDEyIHwgKGRbaSsrXSAmIDYzKSA8PCA2IHwgKGRbaSsrXSAmIDYzKSkgLSA2NTUzNixcbiAgICAgICAgICAgICAgICByICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYgfCAoYyA+PiAxMCksIDU2MzIwIHwgKGMgJiAxMDIzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWIgJiAxKVxuICAgICAgICAgICAgciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMzEpIDw8IDYgfCAoZFtpKytdICYgNjMpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMTUpIDw8IDEyIHwgKGRbaSsrXSAmIDYzKSA8PCA2IHwgKGRbaSsrXSAmIDYzKSk7XG4gICAgfVxufTtcbi8qKlxuICogU3RyZWFtaW5nIFVURi04IGRlY29kaW5nXG4gKi9cbnZhciBEZWNvZGVVVEY4ID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBVVEYtOCBkZWNvZGluZyBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBpcyBkZWNvZGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGVjb2RlVVRGOChjYikge1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgICAgICBpZiAodGRzKVxuICAgICAgICAgICAgdGhpcy50ID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucCA9IGV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBkZWNvZGVkIGZyb20gVVRGLTggYmluYXJ5XG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIERlY29kZVVURjgucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIGlmICghdGhpcy5vbmRhdGEpXG4gICAgICAgICAgICB0aHJvdyAnbm8gY2FsbGJhY2snO1xuICAgICAgICBmaW5hbCA9ICEhZmluYWw7XG4gICAgICAgIGlmICh0aGlzLnQpIHtcbiAgICAgICAgICAgIHRoaXMub25kYXRhKHRoaXMudC5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pLCBmaW5hbCk7XG4gICAgICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50LmRlY29kZSgpLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgdXRmLTggZGF0YSc7XG4gICAgICAgICAgICAgICAgdGhpcy50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucClcbiAgICAgICAgICAgIHRocm93ICdzdHJlYW0gZmluaXNoZWQnO1xuICAgICAgICB2YXIgZGF0ID0gbmV3IHU4KHRoaXMucC5sZW5ndGggKyBjaHVuay5sZW5ndGgpO1xuICAgICAgICBkYXQuc2V0KHRoaXMucCk7XG4gICAgICAgIGRhdC5zZXQoY2h1bmssIHRoaXMucC5sZW5ndGgpO1xuICAgICAgICB2YXIgX2EgPSBkdXRmOChkYXQpLCBjaCA9IF9hWzBdLCBucCA9IF9hWzFdO1xuICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICAgIGlmIChucC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgdXRmLTggZGF0YSc7XG4gICAgICAgICAgICB0aGlzLnAgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucCA9IG5wO1xuICAgICAgICB0aGlzLm9uZGF0YShjaCwgZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIERlY29kZVVURjg7XG59KCkpO1xuZXhwb3J0IHsgRGVjb2RlVVRGOCB9O1xuLyoqXG4gKiBTdHJlYW1pbmcgVVRGLTggZW5jb2RpbmdcbiAqL1xudmFyIEVuY29kZVVURjggPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFVURi04IGRlY29kaW5nIHN0cmVhbVxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuZXZlciBkYXRhIGlzIGVuY29kZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFbmNvZGVVVEY4KGNiKSB7XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIGVuY29kZWQgdG8gVVRGLThcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIHN0cmluZyBkYXRhIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgRW5jb2RlVVRGOC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9uZGF0YSlcbiAgICAgICAgICAgIHRocm93ICdubyBjYWxsYmFjayc7XG4gICAgICAgIGlmICh0aGlzLmQpXG4gICAgICAgICAgICB0aHJvdyAnc3RyZWFtIGZpbmlzaGVkJztcbiAgICAgICAgdGhpcy5vbmRhdGEoc3RyVG9VOChjaHVuayksIHRoaXMuZCA9IGZpbmFsIHx8IGZhbHNlKTtcbiAgICB9O1xuICAgIHJldHVybiBFbmNvZGVVVEY4O1xufSgpKTtcbmV4cG9ydCB7IEVuY29kZVVURjggfTtcbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgaW50byBhIFVpbnQ4QXJyYXkgZm9yIHVzZSB3aXRoIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gbWV0aG9kc1xuICogQHBhcmFtIHN0ciBUaGUgc3RyaW5nIHRvIGVuY29kZVxuICogQHBhcmFtIGxhdGluMSBXaGV0aGVyIG9yIG5vdCB0byBpbnRlcnByZXQgdGhlIGRhdGEgYXMgTGF0aW4tMS4gVGhpcyBzaG91bGRcbiAqICAgICAgICAgICAgICAgbm90IG5lZWQgdG8gYmUgdHJ1ZSB1bmxlc3MgZGVjb2RpbmcgYSBiaW5hcnkgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIHN0cmluZyBlbmNvZGVkIGluIFVURi04L0xhdGluLTEgYmluYXJ5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJUb1U4KHN0ciwgbGF0aW4xKSB7XG4gICAgaWYgKGxhdGluMSkge1xuICAgICAgICB2YXIgYXJfMSA9IG5ldyB1OChzdHIubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBhcl8xW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHJldHVybiBhcl8xO1xuICAgIH1cbiAgICBpZiAodGUpXG4gICAgICAgIHJldHVybiB0ZS5lbmNvZGUoc3RyKTtcbiAgICB2YXIgbCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIGFyID0gbmV3IHU4KHN0ci5sZW5ndGggKyAoc3RyLmxlbmd0aCA+PiAxKSk7XG4gICAgdmFyIGFpID0gMDtcbiAgICB2YXIgdyA9IGZ1bmN0aW9uICh2KSB7IGFyW2FpKytdID0gdjsgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7ICsraSkge1xuICAgICAgICBpZiAoYWkgKyA1ID4gYXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbiA9IG5ldyB1OChhaSArIDggKyAoKGwgLSBpKSA8PCAxKSk7XG4gICAgICAgICAgICBuLnNldChhcik7XG4gICAgICAgICAgICBhciA9IG47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAxMjggfHwgbGF0aW4xKVxuICAgICAgICAgICAgdyhjKTtcbiAgICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpXG4gICAgICAgICAgICB3KDE5MiB8IChjID4+IDYpKSwgdygxMjggfCAoYyAmIDYzKSk7XG4gICAgICAgIGVsc2UgaWYgKGMgPiA1NTI5NSAmJiBjIDwgNTczNDQpXG4gICAgICAgICAgICBjID0gNjU1MzYgKyAoYyAmIDEwMjMgPDwgMTApIHwgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAxMDIzKSxcbiAgICAgICAgICAgICAgICB3KDI0MCB8IChjID4+IDE4KSksIHcoMTI4IHwgKChjID4+IDEyKSAmIDYzKSksIHcoMTI4IHwgKChjID4+IDYpICYgNjMpKSwgdygxMjggfCAoYyAmIDYzKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHcoMjI0IHwgKGMgPj4gMTIpKSwgdygxMjggfCAoKGMgPj4gNikgJiA2MykpLCB3KDEyOCB8IChjICYgNjMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHNsYyhhciwgMCwgYWkpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIFVpbnQ4QXJyYXkgdG8gYSBzdHJpbmdcbiAqIEBwYXJhbSBkYXQgVGhlIGRhdGEgdG8gZGVjb2RlIHRvIHN0cmluZ1xuICogQHBhcmFtIGxhdGluMSBXaGV0aGVyIG9yIG5vdCB0byBpbnRlcnByZXQgdGhlIGRhdGEgYXMgTGF0aW4tMS4gVGhpcyBzaG91bGRcbiAqICAgICAgICAgICAgICAgbm90IG5lZWQgdG8gYmUgdHJ1ZSB1bmxlc3MgZW5jb2RpbmcgdG8gYmluYXJ5IHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBvcmlnaW5hbCBVVEYtOC9MYXRpbi0xIHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyRnJvbVU4KGRhdCwgbGF0aW4xKSB7XG4gICAgaWYgKGxhdGluMSkge1xuICAgICAgICB2YXIgciA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdC5sZW5ndGg7IGkgKz0gMTYzODQpXG4gICAgICAgICAgICByICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgZGF0LnN1YmFycmF5KGksIGkgKyAxNjM4NCkpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgZWxzZSBpZiAodGQpXG4gICAgICAgIHJldHVybiB0ZC5kZWNvZGUoZGF0KTtcbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIF9hID0gZHV0ZjgoZGF0KSwgb3V0ID0gX2FbMF0sIGV4dCA9IF9hWzFdO1xuICAgICAgICBpZiAoZXh0Lmxlbmd0aClcbiAgICAgICAgICAgIHRocm93ICdpbnZhbGlkIHV0Zi04IGRhdGEnO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbn1cbjtcbi8vIGRlZmxhdGUgYml0IGZsYWdcbnZhciBkYmYgPSBmdW5jdGlvbiAobCkgeyByZXR1cm4gbCA9PSAxID8gMyA6IGwgPCA2ID8gMiA6IGwgPT0gOSA/IDEgOiAwOyB9O1xuLy8gc2tpcCBsb2NhbCB6aXAgaGVhZGVyXG52YXIgc2x6aCA9IGZ1bmN0aW9uIChkLCBiKSB7IHJldHVybiBiICsgMzAgKyBiMihkLCBiICsgMjYpICsgYjIoZCwgYiArIDI4KTsgfTtcbi8vIHJlYWQgemlwIGhlYWRlclxudmFyIHpoID0gZnVuY3Rpb24gKGQsIGIsIHopIHtcbiAgICB2YXIgZm5sID0gYjIoZCwgYiArIDI4KSwgZm4gPSBzdHJGcm9tVTgoZC5zdWJhcnJheShiICsgNDYsIGIgKyA0NiArIGZubCksICEoYjIoZCwgYiArIDgpICYgMjA0OCkpLCBlcyA9IGIgKyA0NiArIGZubCwgYnMgPSBiNChkLCBiICsgMjApO1xuICAgIHZhciBfYSA9IHogJiYgYnMgPT0gNDI5NDk2NzI5NSA/IHo2NGUoZCwgZXMpIDogW2JzLCBiNChkLCBiICsgMjQpLCBiNChkLCBiICsgNDIpXSwgc2MgPSBfYVswXSwgc3UgPSBfYVsxXSwgb2ZmID0gX2FbMl07XG4gICAgcmV0dXJuIFtiMihkLCBiICsgMTApLCBzYywgc3UsIGZuLCBlcyArIGIyKGQsIGIgKyAzMCkgKyBiMihkLCBiICsgMzIpLCBvZmZdO1xufTtcbi8vIHJlYWQgemlwNjQgZXh0cmEgZmllbGRcbnZhciB6NjRlID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKDsgYjIoZCwgYikgIT0gMTsgYiArPSA0ICsgYjIoZCwgYiArIDIpKVxuICAgICAgICA7XG4gICAgcmV0dXJuIFtiOChkLCBiICsgMTIpLCBiOChkLCBiICsgNCksIGI4KGQsIGIgKyAyMCldO1xufTtcbi8vIGV4dHJhIGZpZWxkIGxlbmd0aFxudmFyIGV4ZmwgPSBmdW5jdGlvbiAoZXgpIHtcbiAgICB2YXIgbGUgPSAwO1xuICAgIGlmIChleCkge1xuICAgICAgICBmb3IgKHZhciBrIGluIGV4KSB7XG4gICAgICAgICAgICB2YXIgbCA9IGV4W2tdLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsID4gNjU1MzUpXG4gICAgICAgICAgICAgICAgdGhyb3cgJ2V4dHJhIGZpZWxkIHRvbyBsb25nJztcbiAgICAgICAgICAgIGxlICs9IGwgKyA0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZTtcbn07XG4vLyB3cml0ZSB6aXAgaGVhZGVyXG52YXIgd3poID0gZnVuY3Rpb24gKGQsIGIsIGYsIGZuLCB1LCBjLCBjZSwgY28pIHtcbiAgICB2YXIgZmwgPSBmbi5sZW5ndGgsIGV4ID0gZi5leHRyYSwgY29sID0gY28gJiYgY28ubGVuZ3RoO1xuICAgIHZhciBleGwgPSBleGZsKGV4KTtcbiAgICB3Ynl0ZXMoZCwgYiwgY2UgIT0gbnVsbCA/IDB4MjAxNEI1MCA6IDB4NDAzNEI1MCksIGIgKz0gNDtcbiAgICBpZiAoY2UgIT0gbnVsbClcbiAgICAgICAgZFtiKytdID0gMjAsIGRbYisrXSA9IGYub3M7XG4gICAgZFtiXSA9IDIwLCBiICs9IDI7IC8vIHNwZWMgY29tcGxpYW5jZT8gd2hhdCdzIHRoYXQ/XG4gICAgZFtiKytdID0gKGYuZmxhZyA8PCAxKSB8IChjID09IG51bGwgJiYgOCksIGRbYisrXSA9IHUgJiYgODtcbiAgICBkW2IrK10gPSBmLmNvbXByZXNzaW9uICYgMjU1LCBkW2IrK10gPSBmLmNvbXByZXNzaW9uID4+IDg7XG4gICAgdmFyIGR0ID0gbmV3IERhdGUoZi5tdGltZSA9PSBudWxsID8gRGF0ZS5ub3coKSA6IGYubXRpbWUpLCB5ID0gZHQuZ2V0RnVsbFllYXIoKSAtIDE5ODA7XG4gICAgaWYgKHkgPCAwIHx8IHkgPiAxMTkpXG4gICAgICAgIHRocm93ICdkYXRlIG5vdCBpbiByYW5nZSAxOTgwLTIwOTknO1xuICAgIHdieXRlcyhkLCBiLCAoeSA8PCAyNSkgfCAoKGR0LmdldE1vbnRoKCkgKyAxKSA8PCAyMSkgfCAoZHQuZ2V0RGF0ZSgpIDw8IDE2KSB8IChkdC5nZXRIb3VycygpIDw8IDExKSB8IChkdC5nZXRNaW51dGVzKCkgPDwgNSkgfCAoZHQuZ2V0U2Vjb25kcygpID4+PiAxKSksIGIgKz0gNDtcbiAgICBpZiAoYyAhPSBudWxsKSB7XG4gICAgICAgIHdieXRlcyhkLCBiLCBmLmNyYyk7XG4gICAgICAgIHdieXRlcyhkLCBiICsgNCwgYyk7XG4gICAgICAgIHdieXRlcyhkLCBiICsgOCwgZi5zaXplKTtcbiAgICB9XG4gICAgd2J5dGVzKGQsIGIgKyAxMiwgZmwpO1xuICAgIHdieXRlcyhkLCBiICsgMTQsIGV4bCksIGIgKz0gMTY7XG4gICAgaWYgKGNlICE9IG51bGwpIHtcbiAgICAgICAgd2J5dGVzKGQsIGIsIGNvbCk7XG4gICAgICAgIHdieXRlcyhkLCBiICsgNiwgZi5hdHRycyk7XG4gICAgICAgIHdieXRlcyhkLCBiICsgMTAsIGNlKSwgYiArPSAxNDtcbiAgICB9XG4gICAgZC5zZXQoZm4sIGIpO1xuICAgIGIgKz0gZmw7XG4gICAgaWYgKGV4bCkge1xuICAgICAgICBmb3IgKHZhciBrIGluIGV4KSB7XG4gICAgICAgICAgICB2YXIgZXhmID0gZXhba10sIGwgPSBleGYubGVuZ3RoO1xuICAgICAgICAgICAgd2J5dGVzKGQsIGIsICtrKTtcbiAgICAgICAgICAgIHdieXRlcyhkLCBiICsgMiwgbCk7XG4gICAgICAgICAgICBkLnNldChleGYsIGIgKyA0KSwgYiArPSA0ICsgbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29sKVxuICAgICAgICBkLnNldChjbywgYiksIGIgKz0gY29sO1xuICAgIHJldHVybiBiO1xufTtcbi8vIHdyaXRlIHppcCBmb290ZXIgKGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSlcbnZhciB3emYgPSBmdW5jdGlvbiAobywgYiwgYywgZCwgZSkge1xuICAgIHdieXRlcyhvLCBiLCAweDYwNTRCNTApOyAvLyBza2lwIGRpc2tcbiAgICB3Ynl0ZXMobywgYiArIDgsIGMpO1xuICAgIHdieXRlcyhvLCBiICsgMTAsIGMpO1xuICAgIHdieXRlcyhvLCBiICsgMTIsIGQpO1xuICAgIHdieXRlcyhvLCBiICsgMTYsIGUpO1xufTtcbi8qKlxuICogQSBwYXNzLXRocm91Z2ggc3RyZWFtIHRvIGtlZXAgZGF0YSB1bmNvbXByZXNzZWQgaW4gYSBaSVAgYXJjaGl2ZS5cbiAqL1xudmFyIFppcFBhc3NUaHJvdWdoID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwYXNzLXRocm91Z2ggc3RyZWFtIHRoYXQgY2FuIGJlIGFkZGVkIHRvIFpJUCBhcmNoaXZlc1xuICAgICAqIEBwYXJhbSBmaWxlbmFtZSBUaGUgZmlsZW5hbWUgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBkYXRhIHN0cmVhbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFppcFBhc3NUaHJvdWdoKGZpbGVuYW1lKSB7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgICAgICAgdGhpcy5jID0gY3JjKCk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuY29tcHJlc3Npb24gPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzZXMgYSBjaHVuayBhbmQgcHVzaGVzIHRvIHRoZSBvdXRwdXQgc3RyZWFtLiBZb3UgY2FuIG92ZXJyaWRlIHRoaXNcbiAgICAgKiBtZXRob2QgaW4gYSBzdWJjbGFzcyBmb3IgY3VzdG9tIGJlaGF2aW9yLCBidXQgYnkgZGVmYXVsdCB0aGlzIHBhc3Nlc1xuICAgICAqIHRoZSBkYXRhIHRocm91Z2guIFlvdSBtdXN0IGNhbGwgdGhpcy5vbmRhdGEoZXJyLCBjaHVuaywgZmluYWwpIGF0IHNvbWVcbiAgICAgKiBwb2ludCBpbiB0aGlzIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHByb2Nlc3NcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgWmlwUGFzc1Rocm91Z2gucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIHRoaXMub25kYXRhKG51bGwsIGNodW5rLCBmaW5hbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBhZGRlZC4gSWYgeW91IGFyZSBzdWJjbGFzc2luZyB0aGlzIHdpdGggYSBjdXN0b21cbiAgICAgKiBjb21wcmVzc2lvbiBhbGdvcml0aG0sIG5vdGUgdGhhdCB5b3UgbXVzdCBwdXNoIGRhdGEgZnJvbSB0aGUgc291cmNlXG4gICAgICogZmlsZSBvbmx5LCBwcmUtY29tcHJlc3Npb24uXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIFppcFBhc3NUaHJvdWdoLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBpZiAoIXRoaXMub25kYXRhKVxuICAgICAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrIC0gYWRkIHRvIFpJUCBhcmNoaXZlIGJlZm9yZSBwdXNoaW5nJztcbiAgICAgICAgdGhpcy5jLnAoY2h1bmspO1xuICAgICAgICB0aGlzLnNpemUgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICBpZiAoZmluYWwpXG4gICAgICAgICAgICB0aGlzLmNyYyA9IHRoaXMuYy5kKCk7XG4gICAgICAgIHRoaXMucHJvY2VzcyhjaHVuaywgZmluYWwgfHwgZmFsc2UpO1xuICAgIH07XG4gICAgcmV0dXJuIFppcFBhc3NUaHJvdWdoO1xufSgpKTtcbmV4cG9ydCB7IFppcFBhc3NUaHJvdWdoIH07XG4vLyBJIGRvbid0IGV4dGVuZCBiZWNhdXNlIFR5cGVTY3JpcHQgZXh0ZW5zaW9uIGFkZHMgMWtCIG9mIHJ1bnRpbWUgYmxvYXRcbi8qKlxuICogU3RyZWFtaW5nIERFRkxBVEUgY29tcHJlc3Npb24gZm9yIFpJUCBhcmNoaXZlcy4gUHJlZmVyIHVzaW5nIEFzeW5jWmlwRGVmbGF0ZVxuICogZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuICovXG52YXIgWmlwRGVmbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgREVGTEFURSBzdHJlYW0gdGhhdCBjYW4gYmUgYWRkZWQgdG8gWklQIGFyY2hpdmVzXG4gICAgICogQHBhcmFtIGZpbGVuYW1lIFRoZSBmaWxlbmFtZSB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIGRhdGEgc3RyZWFtXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIGNvbXByZXNzaW9uIG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBaaXBEZWZsYXRlKGZpbGVuYW1lLCBvcHRzKSB7XG4gICAgICAgIHZhciBfdGhpc18xID0gdGhpcztcbiAgICAgICAgaWYgKCFvcHRzKVxuICAgICAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgICBaaXBQYXNzVGhyb3VnaC5jYWxsKHRoaXMsIGZpbGVuYW1lKTtcbiAgICAgICAgdGhpcy5kID0gbmV3IERlZmxhdGUob3B0cywgZnVuY3Rpb24gKGRhdCwgZmluYWwpIHtcbiAgICAgICAgICAgIF90aGlzXzEub25kYXRhKG51bGwsIGRhdCwgZmluYWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb21wcmVzc2lvbiA9IDg7XG4gICAgICAgIHRoaXMuZmxhZyA9IGRiZihvcHRzLmxldmVsKTtcbiAgICB9XG4gICAgWmlwRGVmbGF0ZS5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZC5wdXNoKGNodW5rLCBmaW5hbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMub25kYXRhKGUsIG51bGwsIGZpbmFsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgZGVmbGF0ZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgWmlwRGVmbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgWmlwUGFzc1Rocm91Z2gucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIFppcERlZmxhdGU7XG59KCkpO1xuZXhwb3J0IHsgWmlwRGVmbGF0ZSB9O1xuLyoqXG4gKiBBc3luY2hyb25vdXMgc3RyZWFtaW5nIERFRkxBVEUgY29tcHJlc3Npb24gZm9yIFpJUCBhcmNoaXZlc1xuICovXG52YXIgQXN5bmNaaXBEZWZsYXRlID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBERUZMQVRFIHN0cmVhbSB0aGF0IGNhbiBiZSBhZGRlZCB0byBaSVAgYXJjaGl2ZXNcbiAgICAgKiBAcGFyYW0gZmlsZW5hbWUgVGhlIGZpbGVuYW1lIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMgZGF0YSBzdHJlYW1cbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgY29tcHJlc3Npb24gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFzeW5jWmlwRGVmbGF0ZShmaWxlbmFtZSwgb3B0cykge1xuICAgICAgICB2YXIgX3RoaXNfMSA9IHRoaXM7XG4gICAgICAgIGlmICghb3B0cylcbiAgICAgICAgICAgIG9wdHMgPSB7fTtcbiAgICAgICAgWmlwUGFzc1Rocm91Z2guY2FsbCh0aGlzLCBmaWxlbmFtZSk7XG4gICAgICAgIHRoaXMuZCA9IG5ldyBBc3luY0RlZmxhdGUob3B0cywgZnVuY3Rpb24gKGVyciwgZGF0LCBmaW5hbCkge1xuICAgICAgICAgICAgX3RoaXNfMS5vbmRhdGEoZXJyLCBkYXQsIGZpbmFsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29tcHJlc3Npb24gPSA4O1xuICAgICAgICB0aGlzLmZsYWcgPSBkYmYob3B0cy5sZXZlbCk7XG4gICAgICAgIHRoaXMudGVybWluYXRlID0gdGhpcy5kLnRlcm1pbmF0ZTtcbiAgICB9XG4gICAgQXN5bmNaaXBEZWZsYXRlLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICB0aGlzLmQucHVzaChjaHVuaywgZmluYWwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgZGVmbGF0ZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgQXN5bmNaaXBEZWZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBaaXBQYXNzVGhyb3VnaC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBmaW5hbCk7XG4gICAgfTtcbiAgICByZXR1cm4gQXN5bmNaaXBEZWZsYXRlO1xufSgpKTtcbmV4cG9ydCB7IEFzeW5jWmlwRGVmbGF0ZSB9O1xuLy8gVE9ETzogQmV0dGVyIHRyZWUgc2hha2luZ1xuLyoqXG4gKiBBIHppcHBhYmxlIGFyY2hpdmUgdG8gd2hpY2ggZmlsZXMgY2FuIGluY3JlbWVudGFsbHkgYmUgYWRkZWRcbiAqL1xudmFyIFppcCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGVtcHR5IFpJUCBhcmNoaXZlIHRvIHdoaWNoIGZpbGVzIGNhbiBiZSBhZGRlZFxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuZXZlciBkYXRhIGZvciB0aGUgZ2VuZXJhdGVkIFpJUCBhcmNoaXZlXG4gICAgICogICAgICAgICAgIGlzIGF2YWlsYWJsZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFppcChjYikge1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgICAgICB0aGlzLnUgPSBbXTtcbiAgICAgICAgdGhpcy5kID0gMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGZpbGUgdG8gdGhlIFpJUCBhcmNoaXZlXG4gICAgICogQHBhcmFtIGZpbGUgVGhlIGZpbGUgc3RyZWFtIHRvIGFkZFxuICAgICAqL1xuICAgIFppcC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgdmFyIF90aGlzXzEgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5kICYgMilcbiAgICAgICAgICAgIHRocm93ICdzdHJlYW0gZmluaXNoZWQnO1xuICAgICAgICB2YXIgZiA9IHN0clRvVTgoZmlsZS5maWxlbmFtZSksIGZsID0gZi5sZW5ndGg7XG4gICAgICAgIHZhciBjb20gPSBmaWxlLmNvbW1lbnQsIG8gPSBjb20gJiYgc3RyVG9VOChjb20pO1xuICAgICAgICB2YXIgdSA9IGZsICE9IGZpbGUuZmlsZW5hbWUubGVuZ3RoIHx8IChvICYmIChjb20ubGVuZ3RoICE9IG8ubGVuZ3RoKSk7XG4gICAgICAgIHZhciBobCA9IGZsICsgZXhmbChmaWxlLmV4dHJhKSArIDMwO1xuICAgICAgICBpZiAoZmwgPiA2NTUzNSlcbiAgICAgICAgICAgIHRocm93ICdmaWxlbmFtZSB0b28gbG9uZyc7XG4gICAgICAgIHZhciBoZWFkZXIgPSBuZXcgdTgoaGwpO1xuICAgICAgICB3emgoaGVhZGVyLCAwLCBmaWxlLCBmLCB1KTtcbiAgICAgICAgdmFyIGNoa3MgPSBbaGVhZGVyXTtcbiAgICAgICAgdmFyIHBBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGNoa3NfMSA9IGNoa3M7IF9pIDwgY2hrc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGsgPSBjaGtzXzFbX2ldO1xuICAgICAgICAgICAgICAgIF90aGlzXzEub25kYXRhKG51bGwsIGNoaywgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hrcyA9IFtdO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdHIgPSB0aGlzLmQ7XG4gICAgICAgIHRoaXMuZCA9IDA7XG4gICAgICAgIHZhciBpbmQgPSB0aGlzLnUubGVuZ3RoO1xuICAgICAgICB2YXIgdWYgPSBtcmcoZmlsZSwge1xuICAgICAgICAgICAgZjogZixcbiAgICAgICAgICAgIHU6IHUsXG4gICAgICAgICAgICBvOiBvLFxuICAgICAgICAgICAgdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChmaWxlLnRlcm1pbmF0ZSlcbiAgICAgICAgICAgICAgICAgICAgZmlsZS50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcEFsbCgpO1xuICAgICAgICAgICAgICAgIGlmICh0cikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbnh0ID0gX3RoaXNfMS51W2luZCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobnh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgbnh0LnIoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXNfMS5kID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHIgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNsID0gMDtcbiAgICAgICAgZmlsZS5vbmRhdGEgPSBmdW5jdGlvbiAoZXJyLCBkYXQsIGZpbmFsKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXNfMS5vbmRhdGEoZXJyLCBkYXQsIGZpbmFsKTtcbiAgICAgICAgICAgICAgICBfdGhpc18xLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2wgKz0gZGF0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjaGtzLnB1c2goZGF0KTtcbiAgICAgICAgICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRkID0gbmV3IHU4KDE2KTtcbiAgICAgICAgICAgICAgICAgICAgd2J5dGVzKGRkLCAwLCAweDgwNzRCNTApO1xuICAgICAgICAgICAgICAgICAgICB3Ynl0ZXMoZGQsIDQsIGZpbGUuY3JjKTtcbiAgICAgICAgICAgICAgICAgICAgd2J5dGVzKGRkLCA4LCBjbCk7XG4gICAgICAgICAgICAgICAgICAgIHdieXRlcyhkZCwgMTIsIGZpbGUuc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNoa3MucHVzaChkZCk7XG4gICAgICAgICAgICAgICAgICAgIHVmLmMgPSBjbCwgdWYuYiA9IGhsICsgY2wgKyAxNiwgdWYuY3JjID0gZmlsZS5jcmMsIHVmLnNpemUgPSBmaWxlLnNpemU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cilcbiAgICAgICAgICAgICAgICAgICAgICAgIHVmLnIoKTtcbiAgICAgICAgICAgICAgICAgICAgdHIgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0cilcbiAgICAgICAgICAgICAgICAgICAgcEFsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnUucHVzaCh1Zik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFbmRzIHRoZSBwcm9jZXNzIG9mIGFkZGluZyBmaWxlcyBhbmQgcHJlcGFyZXMgdG8gZW1pdCB0aGUgZmluYWwgY2h1bmtzLlxuICAgICAqIFRoaXMgKm11c3QqIGJlIGNhbGxlZCBhZnRlciBhZGRpbmcgYWxsIGRlc2lyZWQgZmlsZXMgZm9yIHRoZSByZXN1bHRpbmdcbiAgICAgKiBaSVAgZmlsZSB0byB3b3JrIHByb3Blcmx5LlxuICAgICAqL1xuICAgIFppcC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXNfMSA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmQgJiAyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kICYgMSlcbiAgICAgICAgICAgICAgICB0aHJvdyAnc3RyZWFtIGZpbmlzaGluZyc7XG4gICAgICAgICAgICB0aHJvdyAnc3RyZWFtIGZpbmlzaGVkJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kKVxuICAgICAgICAgICAgdGhpcy5lKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMudS5wdXNoKHtcbiAgICAgICAgICAgICAgICByOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKF90aGlzXzEuZCAmIDEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBfdGhpc18xLnUuc3BsaWNlKC0xLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXNfMS5lKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0OiBmdW5jdGlvbiAoKSB7IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLmQgPSAzO1xuICAgIH07XG4gICAgWmlwLnByb3RvdHlwZS5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnQgPSAwLCBsID0gMCwgdGwgPSAwO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy51OyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGYgPSBfYVtfaV07XG4gICAgICAgICAgICB0bCArPSA0NiArIGYuZi5sZW5ndGggKyBleGZsKGYuZXh0cmEpICsgKGYubyA/IGYuby5sZW5ndGggOiAwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0ID0gbmV3IHU4KHRsICsgMjIpO1xuICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gdGhpcy51OyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgdmFyIGYgPSBfY1tfYl07XG4gICAgICAgICAgICB3emgob3V0LCBidCwgZiwgZi5mLCBmLnUsIGYuYywgbCwgZi5vKTtcbiAgICAgICAgICAgIGJ0ICs9IDQ2ICsgZi5mLmxlbmd0aCArIGV4ZmwoZi5leHRyYSkgKyAoZi5vID8gZi5vLmxlbmd0aCA6IDApLCBsICs9IGYuYjtcbiAgICAgICAgfVxuICAgICAgICB3emYob3V0LCBidCwgdGhpcy51Lmxlbmd0aCwgdGwsIGwpO1xuICAgICAgICB0aGlzLm9uZGF0YShudWxsLCBvdXQsIHRydWUpO1xuICAgICAgICB0aGlzLmQgPSAyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXRob2QgdG8gdGVybWluYXRlIGFueSBpbnRlcm5hbCB3b3JrZXJzIHVzZWQgYnkgdGhlIHN0cmVhbS4gU3Vic2VxdWVudFxuICAgICAqIGNhbGxzIHRvIGFkZCgpIHdpbGwgZmFpbC5cbiAgICAgKi9cbiAgICBaaXAucHJvdG90eXBlLnRlcm1pbmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMudTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBmID0gX2FbX2ldO1xuICAgICAgICAgICAgZi50KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kID0gMjtcbiAgICB9O1xuICAgIHJldHVybiBaaXA7XG59KCkpO1xuZXhwb3J0IHsgWmlwIH07XG5leHBvcnQgZnVuY3Rpb24gemlwKGRhdGEsIG9wdHMsIGNiKSB7XG4gICAgaWYgKCFjYilcbiAgICAgICAgY2IgPSBvcHRzLCBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBjYiAhPSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyAnbm8gY2FsbGJhY2snO1xuICAgIHZhciByID0ge307XG4gICAgZmx0bihkYXRhLCAnJywgciwgb3B0cyk7XG4gICAgdmFyIGsgPSBPYmplY3Qua2V5cyhyKTtcbiAgICB2YXIgbGZ0ID0gay5sZW5ndGgsIG8gPSAwLCB0b3QgPSAwO1xuICAgIHZhciBzbGZ0ID0gbGZ0LCBmaWxlcyA9IG5ldyBBcnJheShsZnQpO1xuICAgIHZhciB0ZXJtID0gW107XG4gICAgdmFyIHRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVybS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHRlcm1baV0oKTtcbiAgICB9O1xuICAgIHZhciBjYmYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdXQgPSBuZXcgdTgodG90ICsgMjIpLCBvZSA9IG8sIGNkbCA9IHRvdCAtIG87XG4gICAgICAgIHRvdCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xmdDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgZiA9IGZpbGVzW2ldO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IGYuYy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd3poKG91dCwgdG90LCBmLCBmLmYsIGYudSwgbCk7XG4gICAgICAgICAgICAgICAgdmFyIGJhZGQgPSAzMCArIGYuZi5sZW5ndGggKyBleGZsKGYuZXh0cmEpO1xuICAgICAgICAgICAgICAgIHZhciBsb2MgPSB0b3QgKyBiYWRkO1xuICAgICAgICAgICAgICAgIG91dC5zZXQoZi5jLCBsb2MpO1xuICAgICAgICAgICAgICAgIHd6aChvdXQsIG8sIGYsIGYuZiwgZi51LCBsLCB0b3QsIGYubSksIG8gKz0gMTYgKyBiYWRkICsgKGYubSA/IGYubS5sZW5ndGggOiAwKSwgdG90ID0gbG9jICsgbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKGUsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHd6ZihvdXQsIG8sIGZpbGVzLmxlbmd0aCwgY2RsLCBvZSk7XG4gICAgICAgIGNiKG51bGwsIG91dCk7XG4gICAgfTtcbiAgICBpZiAoIWxmdClcbiAgICAgICAgY2JmKCk7XG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgZm4gPSBrW2ldO1xuICAgICAgICB2YXIgX2EgPSByW2ZuXSwgZmlsZSA9IF9hWzBdLCBwID0gX2FbMV07XG4gICAgICAgIHZhciBjID0gY3JjKCksIHNpemUgPSBmaWxlLmxlbmd0aDtcbiAgICAgICAgYy5wKGZpbGUpO1xuICAgICAgICB2YXIgZiA9IHN0clRvVTgoZm4pLCBzID0gZi5sZW5ndGg7XG4gICAgICAgIHZhciBjb20gPSBwLmNvbW1lbnQsIG0gPSBjb20gJiYgc3RyVG9VOChjb20pLCBtcyA9IG0gJiYgbS5sZW5ndGg7XG4gICAgICAgIHZhciBleGwgPSBleGZsKHAuZXh0cmEpO1xuICAgICAgICB2YXIgY29tcHJlc3Npb24gPSBwLmxldmVsID09IDAgPyAwIDogODtcbiAgICAgICAgdmFyIGNibCA9IGZ1bmN0aW9uIChlLCBkKSB7XG4gICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgIHRBbGwoKTtcbiAgICAgICAgICAgICAgICBjYihlLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBsID0gZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZmlsZXNbaV0gPSBtcmcocCwge1xuICAgICAgICAgICAgICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICAgICAgICAgICAgICBjcmM6IGMuZCgpLFxuICAgICAgICAgICAgICAgICAgICBjOiBkLFxuICAgICAgICAgICAgICAgICAgICBmOiBmLFxuICAgICAgICAgICAgICAgICAgICBtOiBtLFxuICAgICAgICAgICAgICAgICAgICB1OiBzICE9IGZuLmxlbmd0aCB8fCAobSAmJiAoY29tLmxlbmd0aCAhPSBtcykpLFxuICAgICAgICAgICAgICAgICAgICBjb21wcmVzc2lvbjogY29tcHJlc3Npb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvICs9IDMwICsgcyArIGV4bCArIGw7XG4gICAgICAgICAgICAgICAgdG90ICs9IDc2ICsgMiAqIChzICsgZXhsKSArIChtcyB8fCAwKSArIGw7XG4gICAgICAgICAgICAgICAgaWYgKCEtLWxmdClcbiAgICAgICAgICAgICAgICAgICAgY2JmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzID4gNjU1MzUpXG4gICAgICAgICAgICBjYmwoJ2ZpbGVuYW1lIHRvbyBsb25nJywgbnVsbCk7XG4gICAgICAgIGlmICghY29tcHJlc3Npb24pXG4gICAgICAgICAgICBjYmwobnVsbCwgZmlsZSk7XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPCAxNjAwMDApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2JsKG51bGwsIGRlZmxhdGVTeW5jKGZpbGUsIHApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY2JsKGUsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRlcm0ucHVzaChkZWZsYXRlKGZpbGUsIHAsIGNibCkpO1xuICAgIH07XG4gICAgLy8gQ2Fubm90IHVzZSBsZnQgYmVjYXVzZSBpdCBjYW4gZGVjcmVhc2VcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsZnQ7ICsraSkge1xuICAgICAgICBfbG9vcF8xKGkpO1xuICAgIH1cbiAgICByZXR1cm4gdEFsbDtcbn1cbi8qKlxuICogU3luY2hyb25vdXNseSBjcmVhdGVzIGEgWklQIGZpbGUuIFByZWZlciB1c2luZyBgemlwYCBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXG4gKiB3aXRoIG1vcmUgdGhhbiBvbmUgZmlsZS5cbiAqIEBwYXJhbSBkYXRhIFRoZSBkaXJlY3Rvcnkgc3RydWN0dXJlIGZvciB0aGUgWklQIGFyY2hpdmVcbiAqIEBwYXJhbSBvcHRzIFRoZSBtYWluIG9wdGlvbnMsIG1lcmdlZCB3aXRoIHBlci1maWxlIG9wdGlvbnNcbiAqIEByZXR1cm5zIFRoZSBnZW5lcmF0ZWQgWklQIGFyY2hpdmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHppcFN5bmMoZGF0YSwgb3B0cykge1xuICAgIGlmICghb3B0cylcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgIHZhciByID0ge307XG4gICAgdmFyIGZpbGVzID0gW107XG4gICAgZmx0bihkYXRhLCAnJywgciwgb3B0cyk7XG4gICAgdmFyIG8gPSAwO1xuICAgIHZhciB0b3QgPSAwO1xuICAgIGZvciAodmFyIGZuIGluIHIpIHtcbiAgICAgICAgdmFyIF9hID0gcltmbl0sIGZpbGUgPSBfYVswXSwgcCA9IF9hWzFdO1xuICAgICAgICB2YXIgY29tcHJlc3Npb24gPSBwLmxldmVsID09IDAgPyAwIDogODtcbiAgICAgICAgdmFyIGYgPSBzdHJUb1U4KGZuKSwgcyA9IGYubGVuZ3RoO1xuICAgICAgICB2YXIgY29tID0gcC5jb21tZW50LCBtID0gY29tICYmIHN0clRvVTgoY29tKSwgbXMgPSBtICYmIG0ubGVuZ3RoO1xuICAgICAgICB2YXIgZXhsID0gZXhmbChwLmV4dHJhKTtcbiAgICAgICAgaWYgKHMgPiA2NTUzNSlcbiAgICAgICAgICAgIHRocm93ICdmaWxlbmFtZSB0b28gbG9uZyc7XG4gICAgICAgIHZhciBkID0gY29tcHJlc3Npb24gPyBkZWZsYXRlU3luYyhmaWxlLCBwKSA6IGZpbGUsIGwgPSBkLmxlbmd0aDtcbiAgICAgICAgdmFyIGMgPSBjcmMoKTtcbiAgICAgICAgYy5wKGZpbGUpO1xuICAgICAgICBmaWxlcy5wdXNoKG1yZyhwLCB7XG4gICAgICAgICAgICBzaXplOiBmaWxlLmxlbmd0aCxcbiAgICAgICAgICAgIGNyYzogYy5kKCksXG4gICAgICAgICAgICBjOiBkLFxuICAgICAgICAgICAgZjogZixcbiAgICAgICAgICAgIG06IG0sXG4gICAgICAgICAgICB1OiBzICE9IGZuLmxlbmd0aCB8fCAobSAmJiAoY29tLmxlbmd0aCAhPSBtcykpLFxuICAgICAgICAgICAgbzogbyxcbiAgICAgICAgICAgIGNvbXByZXNzaW9uOiBjb21wcmVzc2lvblxuICAgICAgICB9KSk7XG4gICAgICAgIG8gKz0gMzAgKyBzICsgZXhsICsgbDtcbiAgICAgICAgdG90ICs9IDc2ICsgMiAqIChzICsgZXhsKSArIChtcyB8fCAwKSArIGw7XG4gICAgfVxuICAgIHZhciBvdXQgPSBuZXcgdTgodG90ICsgMjIpLCBvZSA9IG8sIGNkbCA9IHRvdCAtIG87XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZiA9IGZpbGVzW2ldO1xuICAgICAgICB3emgob3V0LCBmLm8sIGYsIGYuZiwgZi51LCBmLmMubGVuZ3RoKTtcbiAgICAgICAgdmFyIGJhZGQgPSAzMCArIGYuZi5sZW5ndGggKyBleGZsKGYuZXh0cmEpO1xuICAgICAgICBvdXQuc2V0KGYuYywgZi5vICsgYmFkZCk7XG4gICAgICAgIHd6aChvdXQsIG8sIGYsIGYuZiwgZi51LCBmLmMubGVuZ3RoLCBmLm8sIGYubSksIG8gKz0gMTYgKyBiYWRkICsgKGYubSA/IGYubS5sZW5ndGggOiAwKTtcbiAgICB9XG4gICAgd3pmKG91dCwgbywgZmlsZXMubGVuZ3RoLCBjZGwsIG9lKTtcbiAgICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTdHJlYW1pbmcgcGFzcy10aHJvdWdoIGRlY29tcHJlc3Npb24gZm9yIFpJUCBhcmNoaXZlc1xuICovXG52YXIgVW56aXBQYXNzVGhyb3VnaCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVbnppcFBhc3NUaHJvdWdoKCkge1xuICAgIH1cbiAgICBVbnppcFBhc3NUaHJvdWdoLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIGZpbmFsKSB7XG4gICAgICAgIHRoaXMub25kYXRhKG51bGwsIGRhdGEsIGZpbmFsKTtcbiAgICB9O1xuICAgIFVuemlwUGFzc1Rocm91Z2guY29tcHJlc3Npb24gPSAwO1xuICAgIHJldHVybiBVbnppcFBhc3NUaHJvdWdoO1xufSgpKTtcbmV4cG9ydCB7IFVuemlwUGFzc1Rocm91Z2ggfTtcbi8qKlxuICogU3RyZWFtaW5nIERFRkxBVEUgZGVjb21wcmVzc2lvbiBmb3IgWklQIGFyY2hpdmVzLiBQcmVmZXIgQXN5bmNaaXBJbmZsYXRlIGZvclxuICogYmV0dGVyIHBlcmZvcm1hbmNlLlxuICovXG52YXIgVW56aXBJbmZsYXRlID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBERUZMQVRFIGRlY29tcHJlc3Npb24gdGhhdCBjYW4gYmUgdXNlZCBpbiBaSVAgYXJjaGl2ZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBVbnppcEluZmxhdGUoKSB7XG4gICAgICAgIHZhciBfdGhpc18xID0gdGhpcztcbiAgICAgICAgdGhpcy5pID0gbmV3IEluZmxhdGUoZnVuY3Rpb24gKGRhdCwgZmluYWwpIHtcbiAgICAgICAgICAgIF90aGlzXzEub25kYXRhKG51bGwsIGRhdCwgZmluYWwpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgVW56aXBJbmZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIGZpbmFsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmkucHVzaChkYXRhLCBmaW5hbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMub25kYXRhKGUsIGRhdGEsIGZpbmFsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVW56aXBJbmZsYXRlLmNvbXByZXNzaW9uID0gODtcbiAgICByZXR1cm4gVW56aXBJbmZsYXRlO1xufSgpKTtcbmV4cG9ydCB7IFVuemlwSW5mbGF0ZSB9O1xuLyoqXG4gKiBBc3luY2hyb25vdXMgc3RyZWFtaW5nIERFRkxBVEUgZGVjb21wcmVzc2lvbiBmb3IgWklQIGFyY2hpdmVzXG4gKi9cbnZhciBBc3luY1VuemlwSW5mbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgREVGTEFURSBkZWNvbXByZXNzaW9uIHRoYXQgY2FuIGJlIHVzZWQgaW4gWklQIGFyY2hpdmVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQXN5bmNVbnppcEluZmxhdGUoXywgc3opIHtcbiAgICAgICAgdmFyIF90aGlzXzEgPSB0aGlzO1xuICAgICAgICBpZiAoc3ogPCAzMjAwMDApIHtcbiAgICAgICAgICAgIHRoaXMuaSA9IG5ldyBJbmZsYXRlKGZ1bmN0aW9uIChkYXQsIGZpbmFsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXNfMS5vbmRhdGEobnVsbCwgZGF0LCBmaW5hbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaSA9IG5ldyBBc3luY0luZmxhdGUoZnVuY3Rpb24gKGVyciwgZGF0LCBmaW5hbCkge1xuICAgICAgICAgICAgICAgIF90aGlzXzEub25kYXRhKGVyciwgZGF0LCBmaW5hbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudGVybWluYXRlID0gdGhpcy5pLnRlcm1pbmF0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBc3luY1VuemlwSW5mbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBmaW5hbCkge1xuICAgICAgICBpZiAodGhpcy5pLnRlcm1pbmF0ZSlcbiAgICAgICAgICAgIGRhdGEgPSBzbGMoZGF0YSwgMCk7XG4gICAgICAgIHRoaXMuaS5wdXNoKGRhdGEsIGZpbmFsKTtcbiAgICB9O1xuICAgIEFzeW5jVW56aXBJbmZsYXRlLmNvbXByZXNzaW9uID0gODtcbiAgICByZXR1cm4gQXN5bmNVbnppcEluZmxhdGU7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNVbnppcEluZmxhdGUgfTtcbi8qKlxuICogQSBaSVAgYXJjaGl2ZSBkZWNvbXByZXNzaW9uIHN0cmVhbSB0aGF0IGVtaXRzIGZpbGVzIGFzIHRoZXkgYXJlIGRpc2NvdmVyZWRcbiAqL1xudmFyIFVuemlwID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBaSVAgZGVjb21wcmVzc2lvbiBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgYSBmaWxlIGluIHRoZSBaSVAgYXJjaGl2ZSBpcyBmb3VuZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFVuemlwKGNiKSB7XG4gICAgICAgIHRoaXMub25maWxlID0gY2I7XG4gICAgICAgIHRoaXMuayA9IFtdO1xuICAgICAgICB0aGlzLm8gPSB7XG4gICAgICAgICAgICAwOiBVbnppcFBhc3NUaHJvdWdoXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucCA9IGV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSB1bnppcHBlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBVbnppcC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgdmFyIF90aGlzXzEgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMub25maWxlKVxuICAgICAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICAgICAgaWYgKCF0aGlzLnApXG4gICAgICAgICAgICB0aHJvdyAnc3RyZWFtIGZpbmlzaGVkJztcbiAgICAgICAgaWYgKHRoaXMuYyA+IDApIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbih0aGlzLmMsIGNodW5rLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgdG9BZGQgPSBjaHVuay5zdWJhcnJheSgwLCBsZW4pO1xuICAgICAgICAgICAgdGhpcy5jIC09IGxlbjtcbiAgICAgICAgICAgIGlmICh0aGlzLmQpXG4gICAgICAgICAgICAgICAgdGhpcy5kLnB1c2godG9BZGQsICF0aGlzLmMpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMua1swXS5wdXNoKHRvQWRkKTtcbiAgICAgICAgICAgIGNodW5rID0gY2h1bmsuc3ViYXJyYXkobGVuKTtcbiAgICAgICAgICAgIGlmIChjaHVuay5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaChjaHVuaywgZmluYWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGYgPSAwLCBpID0gMCwgaXMgPSB2b2lkIDAsIGJ1ZiA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICghdGhpcy5wLmxlbmd0aClcbiAgICAgICAgICAgICAgICBidWYgPSBjaHVuaztcbiAgICAgICAgICAgIGVsc2UgaWYgKCFjaHVuay5sZW5ndGgpXG4gICAgICAgICAgICAgICAgYnVmID0gdGhpcy5wO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVmID0gbmV3IHU4KHRoaXMucC5sZW5ndGggKyBjaHVuay5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGJ1Zi5zZXQodGhpcy5wKSwgYnVmLnNldChjaHVuaywgdGhpcy5wLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbCA9IGJ1Zi5sZW5ndGgsIG9jID0gdGhpcy5jLCBhZGQgPSBvYyAmJiB0aGlzLmQ7XG4gICAgICAgICAgICB2YXIgX2xvb3BfMiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgdmFyIHNpZyA9IGI0KGJ1ZiwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKHNpZyA9PSAweDQwMzRCNTApIHtcbiAgICAgICAgICAgICAgICAgICAgZiA9IDEsIGlzID0gaTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc18xLmQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzXzEuYyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiZiA9IGIyKGJ1ZiwgaSArIDYpLCBjbXBfMSA9IGIyKGJ1ZiwgaSArIDgpLCB1ID0gYmYgJiAyMDQ4LCBkZCA9IGJmICYgOCwgZm5sID0gYjIoYnVmLCBpICsgMjYpLCBlcyA9IGIyKGJ1ZiwgaSArIDI4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGwgPiBpICsgMzAgKyBmbmwgKyBlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoa3NfMiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xLmsudW5zaGlmdChjaGtzXzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZiA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NfMSA9IGI0KGJ1ZiwgaSArIDE4KSwgc3VfMSA9IGI0KGJ1ZiwgaSArIDIyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbl8xID0gc3RyRnJvbVU4KGJ1Zi5zdWJhcnJheShpICsgMzAsIGkgKz0gMzAgKyBmbmwpLCAhdSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NfMSA9PSA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBkZCA/IFstMl0gOiB6NjRlKGJ1ZiwgaSksIHNjXzEgPSBfYVswXSwgc3VfMSA9IF9hWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NfMSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSBlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMS5jID0gc2NfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZV8xID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGZuXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHJlc3Npb246IGNtcF8xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmlsZV8xLm9uZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICdubyBjYWxsYmFjayc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2NfMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVfMS5vbmRhdGEobnVsbCwgZXQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdHIgPSBfdGhpc18xLm9bY21wXzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdHIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ3Vua25vd24gY29tcHJlc3Npb24gdHlwZSAnICsgY21wXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkXzEgPSBzY18xIDwgMCA/IG5ldyBjdHIoZm5fMSkgOiBuZXcgY3RyKGZuXzEsIHNjXzEsIHN1XzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZF8xLm9uZGF0YSA9IGZ1bmN0aW9uIChlcnIsIGRhdCwgZmluYWwpIHsgZmlsZV8xLm9uZGF0YShlcnIsIGRhdCwgZmluYWwpOyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBjaGtzXzMgPSBjaGtzXzI7IF9pIDwgY2hrc18zLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXQgPSBjaGtzXzNbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRfMS5wdXNoKGRhdCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzXzEua1swXSA9PSBjaGtzXzIgJiYgX3RoaXNfMS5jKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzXzEuZCA9IGRfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkXzEucHVzaChldCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZF8xICYmIGRfMS50ZXJtaW5hdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkXzEudGVybWluYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY18xID49IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZV8xLnNpemUgPSBzY18xLCBmaWxlXzEub3JpZ2luYWxTaXplID0gc3VfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMS5vbmZpbGUoZmlsZV8xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lnID09IDB4ODA3NEI1MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXMgPSBpICs9IDEyICsgKG9jID09IC0yICYmIDgpLCBmID0gMywgdGhpc18xLmMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzaWcgPT0gMHgyMDE0QjUwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcyA9IGkgLT0gNCwgZiA9IDMsIHRoaXNfMS5jID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGwgLSA0OyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGVfMSA9IF9sb29wXzIoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVfMSA9PT0gXCJicmVha1wiKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucCA9IGV0O1xuICAgICAgICAgICAgaWYgKG9jIDwgMCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXQgPSBmID8gYnVmLnN1YmFycmF5KDAsIGlzIC0gMTIgLSAob2MgPT0gLTIgJiYgOCkgLSAoYjQoYnVmLCBpcyAtIDE2KSA9PSAweDgwNzRCNTAgJiYgNCkpIDogYnVmLnN1YmFycmF5KDAsIGkpO1xuICAgICAgICAgICAgICAgIGlmIChhZGQpXG4gICAgICAgICAgICAgICAgICAgIGFkZC5wdXNoKGRhdCwgISFmKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMua1srKGYgPT0gMildLnB1c2goZGF0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmICYgMilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoKGJ1Zi5zdWJhcnJheShpKSwgZmluYWwpO1xuICAgICAgICAgICAgdGhpcy5wID0gYnVmLnN1YmFycmF5KGkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaW5hbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYylcbiAgICAgICAgICAgICAgICB0aHJvdyAnaW52YWxpZCB6aXAgZmlsZSc7XG4gICAgICAgICAgICB0aGlzLnAgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBkZWNvZGVyIHdpdGggdGhlIHN0cmVhbSwgYWxsb3dpbmcgZm9yIGZpbGVzIGNvbXByZXNzZWQgd2l0aFxuICAgICAqIHRoZSBjb21wcmVzc2lvbiB0eXBlIHByb3ZpZGVkIHRvIGJlIGV4cGFuZGVkIGNvcnJlY3RseVxuICAgICAqIEBwYXJhbSBkZWNvZGVyIFRoZSBkZWNvZGVyIGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgVW56aXAucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGRlY29kZXIpIHtcbiAgICAgICAgdGhpcy5vW2RlY29kZXIuY29tcHJlc3Npb25dID0gZGVjb2RlcjtcbiAgICB9O1xuICAgIHJldHVybiBVbnppcDtcbn0oKSk7XG5leHBvcnQgeyBVbnppcCB9O1xuLyoqXG4gKiBBc3luY2hyb25vdXNseSBkZWNvbXByZXNzZXMgYSBaSVAgYXJjaGl2ZVxuICogQHBhcmFtIGRhdGEgVGhlIHJhdyBjb21wcmVzc2VkIFpJUCBmaWxlXG4gKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2l0aCB0aGUgZGVjb21wcmVzc2VkIGZpbGVzXG4gKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gaW1tZWRpYXRlbHkgdGVybWluYXRlIHRoZSB1bnppcHBpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuemlwKGRhdGEsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBjYiAhPSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyAnbm8gY2FsbGJhY2snO1xuICAgIHZhciB0ZXJtID0gW107XG4gICAgdmFyIHRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVybS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHRlcm1baV0oKTtcbiAgICB9O1xuICAgIHZhciBmaWxlcyA9IHt9O1xuICAgIHZhciBlID0gZGF0YS5sZW5ndGggLSAyMjtcbiAgICBmb3IgKDsgYjQoZGF0YSwgZSkgIT0gMHg2MDU0QjUwOyAtLWUpIHtcbiAgICAgICAgaWYgKCFlIHx8IGRhdGEubGVuZ3RoIC0gZSA+IDY1NTU4KSB7XG4gICAgICAgICAgICBjYignaW52YWxpZCB6aXAgZmlsZScsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICB2YXIgbGZ0ID0gYjIoZGF0YSwgZSArIDgpO1xuICAgIGlmICghbGZ0KVxuICAgICAgICBjYihudWxsLCB7fSk7XG4gICAgdmFyIGMgPSBsZnQ7XG4gICAgdmFyIG8gPSBiNChkYXRhLCBlICsgMTYpO1xuICAgIHZhciB6ID0gbyA9PSA0Mjk0OTY3Mjk1O1xuICAgIGlmICh6KSB7XG4gICAgICAgIGUgPSBiNChkYXRhLCBlIC0gMTIpO1xuICAgICAgICBpZiAoYjQoZGF0YSwgZSkgIT0gMHg2MDY0QjUwKSB7XG4gICAgICAgICAgICBjYignaW52YWxpZCB6aXAgZmlsZScsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGMgPSBsZnQgPSBiNChkYXRhLCBlICsgMzIpO1xuICAgICAgICBvID0gYjQoZGF0YSwgZSArIDQ4KTtcbiAgICB9XG4gICAgdmFyIF9sb29wXzMgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgX2EgPSB6aChkYXRhLCBvLCB6KSwgY18xID0gX2FbMF0sIHNjID0gX2FbMV0sIHN1ID0gX2FbMl0sIGZuID0gX2FbM10sIG5vID0gX2FbNF0sIG9mZiA9IF9hWzVdLCBiID0gc2x6aChkYXRhLCBvZmYpO1xuICAgICAgICBvID0gbm87XG4gICAgICAgIHZhciBjYmwgPSBmdW5jdGlvbiAoZSwgZCkge1xuICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICB0QWxsKCk7XG4gICAgICAgICAgICAgICAgY2IoZSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWxlc1tmbl0gPSBkO1xuICAgICAgICAgICAgICAgIGlmICghLS1sZnQpXG4gICAgICAgICAgICAgICAgICAgIGNiKG51bGwsIGZpbGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFjXzEpXG4gICAgICAgICAgICBjYmwobnVsbCwgc2xjKGRhdGEsIGIsIGIgKyBzYykpO1xuICAgICAgICBlbHNlIGlmIChjXzEgPT0gOCkge1xuICAgICAgICAgICAgdmFyIGluZmwgPSBkYXRhLnN1YmFycmF5KGIsIGIgKyBzYyk7XG4gICAgICAgICAgICBpZiAoc2MgPCAzMjAwMDApIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjYmwobnVsbCwgaW5mbGF0ZVN5bmMoaW5mbCwgbmV3IHU4KHN1KSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjYmwoZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRlcm0ucHVzaChpbmZsYXRlKGluZmwsIHsgc2l6ZTogc3UgfSwgY2JsKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY2JsKCd1bmtub3duIGNvbXByZXNzaW9uIHR5cGUgJyArIGNfMSwgbnVsbCk7XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGM7ICsraSkge1xuICAgICAgICBfbG9vcF8zKGkpO1xuICAgIH1cbiAgICByZXR1cm4gdEFsbDtcbn1cbi8qKlxuICogU3luY2hyb25vdXNseSBkZWNvbXByZXNzZXMgYSBaSVAgYXJjaGl2ZS4gUHJlZmVyIHVzaW5nIGB1bnppcGAgZm9yIGJldHRlclxuICogcGVyZm9ybWFuY2Ugd2l0aCBtb3JlIHRoYW4gb25lIGZpbGUuXG4gKiBAcGFyYW0gZGF0YSBUaGUgcmF3IGNvbXByZXNzZWQgWklQIGZpbGVcbiAqIEByZXR1cm5zIFRoZSBkZWNvbXByZXNzZWQgZmlsZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuemlwU3luYyhkYXRhKSB7XG4gICAgdmFyIGZpbGVzID0ge307XG4gICAgdmFyIGUgPSBkYXRhLmxlbmd0aCAtIDIyO1xuICAgIGZvciAoOyBiNChkYXRhLCBlKSAhPSAweDYwNTRCNTA7IC0tZSkge1xuICAgICAgICBpZiAoIWUgfHwgZGF0YS5sZW5ndGggLSBlID4gNjU1NTgpXG4gICAgICAgICAgICB0aHJvdyAnaW52YWxpZCB6aXAgZmlsZSc7XG4gICAgfVxuICAgIDtcbiAgICB2YXIgYyA9IGIyKGRhdGEsIGUgKyA4KTtcbiAgICBpZiAoIWMpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB2YXIgbyA9IGI0KGRhdGEsIGUgKyAxNik7XG4gICAgdmFyIHogPSBvID09IDQyOTQ5NjcyOTU7XG4gICAgaWYgKHopIHtcbiAgICAgICAgZSA9IGI0KGRhdGEsIGUgLSAxMik7XG4gICAgICAgIGlmIChiNChkYXRhLCBlKSAhPSAweDYwNjRCNTApXG4gICAgICAgICAgICB0aHJvdyAnaW52YWxpZCB6aXAgZmlsZSc7XG4gICAgICAgIGMgPSBiNChkYXRhLCBlICsgMzIpO1xuICAgICAgICBvID0gYjQoZGF0YSwgZSArIDQ4KTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjOyArK2kpIHtcbiAgICAgICAgdmFyIF9hID0gemgoZGF0YSwgbywgeiksIGNfMiA9IF9hWzBdLCBzYyA9IF9hWzFdLCBzdSA9IF9hWzJdLCBmbiA9IF9hWzNdLCBubyA9IF9hWzRdLCBvZmYgPSBfYVs1XSwgYiA9IHNsemgoZGF0YSwgb2ZmKTtcbiAgICAgICAgbyA9IG5vO1xuICAgICAgICBpZiAoIWNfMilcbiAgICAgICAgICAgIGZpbGVzW2ZuXSA9IHNsYyhkYXRhLCBiLCBiICsgc2MpO1xuICAgICAgICBlbHNlIGlmIChjXzIgPT0gOClcbiAgICAgICAgICAgIGZpbGVzW2ZuXSA9IGluZmxhdGVTeW5jKGRhdGEuc3ViYXJyYXkoYiwgYiArIHNjKSwgbmV3IHU4KHN1KSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93ICd1bmtub3duIGNvbXByZXNzaW9uIHR5cGUgJyArIGNfMjtcbiAgICB9XG4gICAgcmV0dXJuIGZpbGVzO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/three/examples/jsm/libs/fflate.module.js\n"));

/***/ }),

/***/ "./node_modules/three/examples/jsm/loaders/EXRLoader.js":
/*!**************************************************************!*\
  !*** ./node_modules/three/examples/jsm/loaders/EXRLoader.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXRLoader: function() { return /* binding */ EXRLoader; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _libs_fflate_module_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../libs/fflate.module.js */ \"./node_modules/three/examples/jsm/libs/fflate.module.js\");\n\n\n\n/**\n * OpenEXR loader currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.\n * Supports reading as UnsignedByte, HalfFloat and Float type data texture.\n *\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n * implementation, so I have preserved their copyright notices.\n */\n\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n\n// // End of OpenEXR license -------------------------------------------------\n\nclass EXRLoader extends three__WEBPACK_IMPORTED_MODULE_0__.DataTextureLoader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.type = three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType;\n\n\t}\n\n\tparse( buffer ) {\n\n\t\tconst USHORT_RANGE = ( 1 << 16 );\n\t\tconst BITMAP_SIZE = ( USHORT_RANGE >> 3 );\n\n\t\tconst HUF_ENCBITS = 16; // literal (value) bit length\n\t\tconst HUF_DECBITS = 14; // decoding bit size (>= 8)\n\n\t\tconst HUF_ENCSIZE = ( 1 << HUF_ENCBITS ) + 1; // encoding table size\n\t\tconst HUF_DECSIZE = 1 << HUF_DECBITS; // decoding table size\n\t\tconst HUF_DECMASK = HUF_DECSIZE - 1;\n\n\t\tconst NBITS = 16;\n\t\tconst A_OFFSET = 1 << ( NBITS - 1 );\n\t\tconst MOD_MASK = ( 1 << NBITS ) - 1;\n\n\t\tconst SHORT_ZEROCODE_RUN = 59;\n\t\tconst LONG_ZEROCODE_RUN = 63;\n\t\tconst SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n\n\t\tconst ULONG_SIZE = 8;\n\t\tconst FLOAT32_SIZE = 4;\n\t\tconst INT32_SIZE = 4;\n\t\tconst INT16_SIZE = 2;\n\t\tconst INT8_SIZE = 1;\n\n\t\tconst STATIC_HUFFMAN = 0;\n\t\tconst DEFLATE = 1;\n\n\t\tconst UNKNOWN = 0;\n\t\tconst LOSSY_DCT = 1;\n\t\tconst RLE = 2;\n\n\t\tconst logBase = Math.pow( 2.7182818, 2.2 );\n\n\t\tfunction reverseLutFromBitmap( bitmap, lut ) {\n\n\t\t\tlet k = 0;\n\n\t\t\tfor ( let i = 0; i < USHORT_RANGE; ++ i ) {\n\n\t\t\t\tif ( ( i == 0 ) || ( bitmap[ i >> 3 ] & ( 1 << ( i & 7 ) ) ) ) {\n\n\t\t\t\t\tlut[ k ++ ] = i;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst n = k - 1;\n\n\t\t\twhile ( k < USHORT_RANGE ) lut[ k ++ ] = 0;\n\n\t\t\treturn n;\n\n\t\t}\n\n\t\tfunction hufClearDecTable( hdec ) {\n\n\t\t\tfor ( let i = 0; i < HUF_DECSIZE; i ++ ) {\n\n\t\t\t\thdec[ i ] = {};\n\t\t\t\thdec[ i ].len = 0;\n\t\t\t\thdec[ i ].lit = 0;\n\t\t\t\thdec[ i ].p = null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst getBitsReturn = { l: 0, c: 0, lc: 0 };\n\n\t\tfunction getBits( nBits, c, lc, uInt8Array, inOffset ) {\n\n\t\t\twhile ( lc < nBits ) {\n\n\t\t\t\tc = ( c << 8 ) | parseUint8Array( uInt8Array, inOffset );\n\t\t\t\tlc += 8;\n\n\t\t\t}\n\n\t\t\tlc -= nBits;\n\n\t\t\tgetBitsReturn.l = ( c >> lc ) & ( ( 1 << nBits ) - 1 );\n\t\t\tgetBitsReturn.c = c;\n\t\t\tgetBitsReturn.lc = lc;\n\n\t\t}\n\n\t\tconst hufTableBuffer = new Array( 59 );\n\n\t\tfunction hufCanonicalCodeTable( hcode ) {\n\n\t\t\tfor ( let i = 0; i <= 58; ++ i ) hufTableBuffer[ i ] = 0;\n\t\t\tfor ( let i = 0; i < HUF_ENCSIZE; ++ i ) hufTableBuffer[ hcode[ i ] ] += 1;\n\n\t\t\tlet c = 0;\n\n\t\t\tfor ( let i = 58; i > 0; -- i ) {\n\n\t\t\t\tconst nc = ( ( c + hufTableBuffer[ i ] ) >> 1 );\n\t\t\t\thufTableBuffer[ i ] = c;\n\t\t\t\tc = nc;\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < HUF_ENCSIZE; ++ i ) {\n\n\t\t\t\tconst l = hcode[ i ];\n\t\t\t\tif ( l > 0 ) hcode[ i ] = l | ( hufTableBuffer[ l ] ++ << 6 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction hufUnpackEncTable( uInt8Array, inOffset, ni, im, iM, hcode ) {\n\n\t\t\tconst p = inOffset;\n\t\t\tlet c = 0;\n\t\t\tlet lc = 0;\n\n\t\t\tfor ( ; im <= iM; im ++ ) {\n\n\t\t\t\tif ( p.value - inOffset.value > ni ) return false;\n\n\t\t\t\tgetBits( 6, c, lc, uInt8Array, p );\n\n\t\t\t\tconst l = getBitsReturn.l;\n\t\t\t\tc = getBitsReturn.c;\n\t\t\t\tlc = getBitsReturn.lc;\n\n\t\t\t\thcode[ im ] = l;\n\n\t\t\t\tif ( l == LONG_ZEROCODE_RUN ) {\n\n\t\t\t\t\tif ( p.value - inOffset.value > ni ) {\n\n\t\t\t\t\t\tthrow new Error( 'Something wrong with hufUnpackEncTable' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgetBits( 8, c, lc, uInt8Array, p );\n\n\t\t\t\t\tlet zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n\t\t\t\t\tc = getBitsReturn.c;\n\t\t\t\t\tlc = getBitsReturn.lc;\n\n\t\t\t\t\tif ( im + zerun > iM + 1 ) {\n\n\t\t\t\t\t\tthrow new Error( 'Something wrong with hufUnpackEncTable' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\twhile ( zerun -- ) hcode[ im ++ ] = 0;\n\n\t\t\t\t\tim --;\n\n\t\t\t\t} else if ( l >= SHORT_ZEROCODE_RUN ) {\n\n\t\t\t\t\tlet zerun = l - SHORT_ZEROCODE_RUN + 2;\n\n\t\t\t\t\tif ( im + zerun > iM + 1 ) {\n\n\t\t\t\t\t\tthrow new Error( 'Something wrong with hufUnpackEncTable' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\twhile ( zerun -- ) hcode[ im ++ ] = 0;\n\n\t\t\t\t\tim --;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thufCanonicalCodeTable( hcode );\n\n\t\t}\n\n\t\tfunction hufLength( code ) {\n\n\t\t\treturn code & 63;\n\n\t\t}\n\n\t\tfunction hufCode( code ) {\n\n\t\t\treturn code >> 6;\n\n\t\t}\n\n\t\tfunction hufBuildDecTable( hcode, im, iM, hdecod ) {\n\n\t\t\tfor ( ; im <= iM; im ++ ) {\n\n\t\t\t\tconst c = hufCode( hcode[ im ] );\n\t\t\t\tconst l = hufLength( hcode[ im ] );\n\n\t\t\t\tif ( c >> l ) {\n\n\t\t\t\t\tthrow new Error( 'Invalid table entry' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( l > HUF_DECBITS ) {\n\n\t\t\t\t\tconst pl = hdecod[ ( c >> ( l - HUF_DECBITS ) ) ];\n\n\t\t\t\t\tif ( pl.len ) {\n\n\t\t\t\t\t\tthrow new Error( 'Invalid table entry' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpl.lit ++;\n\n\t\t\t\t\tif ( pl.p ) {\n\n\t\t\t\t\t\tconst p = pl.p;\n\t\t\t\t\t\tpl.p = new Array( pl.lit );\n\n\t\t\t\t\t\tfor ( let i = 0; i < pl.lit - 1; ++ i ) {\n\n\t\t\t\t\t\t\tpl.p[ i ] = p[ i ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpl.p = new Array( 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpl.p[ pl.lit - 1 ] = im;\n\n\t\t\t\t} else if ( l ) {\n\n\t\t\t\t\tlet plOffset = 0;\n\n\t\t\t\t\tfor ( let i = 1 << ( HUF_DECBITS - l ); i > 0; i -- ) {\n\n\t\t\t\t\t\tconst pl = hdecod[ ( c << ( HUF_DECBITS - l ) ) + plOffset ];\n\n\t\t\t\t\t\tif ( pl.len || pl.p ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'Invalid table entry' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpl.len = l;\n\t\t\t\t\t\tpl.lit = im;\n\n\t\t\t\t\t\tplOffset ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tconst getCharReturn = { c: 0, lc: 0 };\n\n\t\tfunction getChar( c, lc, uInt8Array, inOffset ) {\n\n\t\t\tc = ( c << 8 ) | parseUint8Array( uInt8Array, inOffset );\n\t\t\tlc += 8;\n\n\t\t\tgetCharReturn.c = c;\n\t\t\tgetCharReturn.lc = lc;\n\n\t\t}\n\n\t\tconst getCodeReturn = { c: 0, lc: 0 };\n\n\t\tfunction getCode( po, rlc, c, lc, uInt8Array, inOffset, outBuffer, outBufferOffset, outBufferEndOffset ) {\n\n\t\t\tif ( po == rlc ) {\n\n\t\t\t\tif ( lc < 8 ) {\n\n\t\t\t\t\tgetChar( c, lc, uInt8Array, inOffset );\n\t\t\t\t\tc = getCharReturn.c;\n\t\t\t\t\tlc = getCharReturn.lc;\n\n\t\t\t\t}\n\n\t\t\t\tlc -= 8;\n\n\t\t\t\tlet cs = ( c >> lc );\n\t\t\t\tcs = new Uint8Array( [ cs ] )[ 0 ];\n\n\t\t\t\tif ( outBufferOffset.value + cs > outBufferEndOffset ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\tconst s = outBuffer[ outBufferOffset.value - 1 ];\n\n\t\t\t\twhile ( cs -- > 0 ) {\n\n\t\t\t\t\toutBuffer[ outBufferOffset.value ++ ] = s;\n\n\t\t\t\t}\n\n\t\t\t} else if ( outBufferOffset.value < outBufferEndOffset ) {\n\n\t\t\t\toutBuffer[ outBufferOffset.value ++ ] = po;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\tgetCodeReturn.c = c;\n\t\t\tgetCodeReturn.lc = lc;\n\n\t\t}\n\n\t\tfunction UInt16( value ) {\n\n\t\t\treturn ( value & 0xFFFF );\n\n\t\t}\n\n\t\tfunction Int16( value ) {\n\n\t\t\tconst ref = UInt16( value );\n\t\t\treturn ( ref > 0x7FFF ) ? ref - 0x10000 : ref;\n\n\t\t}\n\n\t\tconst wdec14Return = { a: 0, b: 0 };\n\n\t\tfunction wdec14( l, h ) {\n\n\t\t\tconst ls = Int16( l );\n\t\t\tconst hs = Int16( h );\n\n\t\t\tconst hi = hs;\n\t\t\tconst ai = ls + ( hi & 1 ) + ( hi >> 1 );\n\n\t\t\tconst as = ai;\n\t\t\tconst bs = ai - hi;\n\n\t\t\twdec14Return.a = as;\n\t\t\twdec14Return.b = bs;\n\n\t\t}\n\n\t\tfunction wdec16( l, h ) {\n\n\t\t\tconst m = UInt16( l );\n\t\t\tconst d = UInt16( h );\n\n\t\t\tconst bb = ( m - ( d >> 1 ) ) & MOD_MASK;\n\t\t\tconst aa = ( d + bb - A_OFFSET ) & MOD_MASK;\n\n\t\t\twdec14Return.a = aa;\n\t\t\twdec14Return.b = bb;\n\n\t\t}\n\n\t\tfunction wav2Decode( buffer, j, nx, ox, ny, oy, mx ) {\n\n\t\t\tconst w14 = mx < ( 1 << 14 );\n\t\t\tconst n = ( nx > ny ) ? ny : nx;\n\t\t\tlet p = 1;\n\t\t\tlet p2;\n\t\t\tlet py;\n\n\t\t\twhile ( p <= n ) p <<= 1;\n\n\t\t\tp >>= 1;\n\t\t\tp2 = p;\n\t\t\tp >>= 1;\n\n\t\t\twhile ( p >= 1 ) {\n\n\t\t\t\tpy = 0;\n\t\t\t\tconst ey = py + oy * ( ny - p2 );\n\t\t\t\tconst oy1 = oy * p;\n\t\t\t\tconst oy2 = oy * p2;\n\t\t\t\tconst ox1 = ox * p;\n\t\t\t\tconst ox2 = ox * p2;\n\t\t\t\tlet i00, i01, i10, i11;\n\n\t\t\t\tfor ( ; py <= ey; py += oy2 ) {\n\n\t\t\t\t\tlet px = py;\n\t\t\t\t\tconst ex = py + ox * ( nx - p2 );\n\n\t\t\t\t\tfor ( ; px <= ex; px += ox2 ) {\n\n\t\t\t\t\t\tconst p01 = px + ox1;\n\t\t\t\t\t\tconst p10 = px + oy1;\n\t\t\t\t\t\tconst p11 = p10 + ox1;\n\n\t\t\t\t\t\tif ( w14 ) {\n\n\t\t\t\t\t\t\twdec14( buffer[ px + j ], buffer[ p10 + j ] );\n\n\t\t\t\t\t\t\ti00 = wdec14Return.a;\n\t\t\t\t\t\t\ti10 = wdec14Return.b;\n\n\t\t\t\t\t\t\twdec14( buffer[ p01 + j ], buffer[ p11 + j ] );\n\n\t\t\t\t\t\t\ti01 = wdec14Return.a;\n\t\t\t\t\t\t\ti11 = wdec14Return.b;\n\n\t\t\t\t\t\t\twdec14( i00, i01 );\n\n\t\t\t\t\t\t\tbuffer[ px + j ] = wdec14Return.a;\n\t\t\t\t\t\t\tbuffer[ p01 + j ] = wdec14Return.b;\n\n\t\t\t\t\t\t\twdec14( i10, i11 );\n\n\t\t\t\t\t\t\tbuffer[ p10 + j ] = wdec14Return.a;\n\t\t\t\t\t\t\tbuffer[ p11 + j ] = wdec14Return.b;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\twdec16( buffer[ px + j ], buffer[ p10 + j ] );\n\n\t\t\t\t\t\t\ti00 = wdec14Return.a;\n\t\t\t\t\t\t\ti10 = wdec14Return.b;\n\n\t\t\t\t\t\t\twdec16( buffer[ p01 + j ], buffer[ p11 + j ] );\n\n\t\t\t\t\t\t\ti01 = wdec14Return.a;\n\t\t\t\t\t\t\ti11 = wdec14Return.b;\n\n\t\t\t\t\t\t\twdec16( i00, i01 );\n\n\t\t\t\t\t\t\tbuffer[ px + j ] = wdec14Return.a;\n\t\t\t\t\t\t\tbuffer[ p01 + j ] = wdec14Return.b;\n\n\t\t\t\t\t\t\twdec16( i10, i11 );\n\n\t\t\t\t\t\t\tbuffer[ p10 + j ] = wdec14Return.a;\n\t\t\t\t\t\t\tbuffer[ p11 + j ] = wdec14Return.b;\n\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( nx & p ) {\n\n\t\t\t\t\t\tconst p10 = px + oy1;\n\n\t\t\t\t\t\tif ( w14 )\n\t\t\t\t\t\t\twdec14( buffer[ px + j ], buffer[ p10 + j ] );\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\twdec16( buffer[ px + j ], buffer[ p10 + j ] );\n\n\t\t\t\t\t\ti00 = wdec14Return.a;\n\t\t\t\t\t\tbuffer[ p10 + j ] = wdec14Return.b;\n\n\t\t\t\t\t\tbuffer[ px + j ] = i00;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ny & p ) {\n\n\t\t\t\t\tlet px = py;\n\t\t\t\t\tconst ex = py + ox * ( nx - p2 );\n\n\t\t\t\t\tfor ( ; px <= ex; px += ox2 ) {\n\n\t\t\t\t\t\tconst p01 = px + ox1;\n\n\t\t\t\t\t\tif ( w14 )\n\t\t\t\t\t\t\twdec14( buffer[ px + j ], buffer[ p01 + j ] );\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\twdec16( buffer[ px + j ], buffer[ p01 + j ] );\n\n\t\t\t\t\t\ti00 = wdec14Return.a;\n\t\t\t\t\t\tbuffer[ p01 + j ] = wdec14Return.b;\n\n\t\t\t\t\t\tbuffer[ px + j ] = i00;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tp2 = p;\n\t\t\t\tp >>= 1;\n\n\t\t\t}\n\n\t\t\treturn py;\n\n\t\t}\n\n\t\tfunction hufDecode( encodingTable, decodingTable, uInt8Array, inOffset, ni, rlc, no, outBuffer, outOffset ) {\n\n\t\t\tlet c = 0;\n\t\t\tlet lc = 0;\n\t\t\tconst outBufferEndOffset = no;\n\t\t\tconst inOffsetEnd = Math.trunc( inOffset.value + ( ni + 7 ) / 8 );\n\n\t\t\twhile ( inOffset.value < inOffsetEnd ) {\n\n\t\t\t\tgetChar( c, lc, uInt8Array, inOffset );\n\n\t\t\t\tc = getCharReturn.c;\n\t\t\t\tlc = getCharReturn.lc;\n\n\t\t\t\twhile ( lc >= HUF_DECBITS ) {\n\n\t\t\t\t\tconst index = ( c >> ( lc - HUF_DECBITS ) ) & HUF_DECMASK;\n\t\t\t\t\tconst pl = decodingTable[ index ];\n\n\t\t\t\t\tif ( pl.len ) {\n\n\t\t\t\t\t\tlc -= pl.len;\n\n\t\t\t\t\t\tgetCode( pl.lit, rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );\n\n\t\t\t\t\t\tc = getCodeReturn.c;\n\t\t\t\t\t\tlc = getCodeReturn.lc;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( ! pl.p ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'hufDecode issues' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet j;\n\n\t\t\t\t\t\tfor ( j = 0; j < pl.lit; j ++ ) {\n\n\t\t\t\t\t\t\tconst l = hufLength( encodingTable[ pl.p[ j ] ] );\n\n\t\t\t\t\t\t\twhile ( lc < l && inOffset.value < inOffsetEnd ) {\n\n\t\t\t\t\t\t\t\tgetChar( c, lc, uInt8Array, inOffset );\n\n\t\t\t\t\t\t\t\tc = getCharReturn.c;\n\t\t\t\t\t\t\t\tlc = getCharReturn.lc;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( lc >= l ) {\n\n\t\t\t\t\t\t\t\tif ( hufCode( encodingTable[ pl.p[ j ] ] ) == ( ( c >> ( lc - l ) ) & ( ( 1 << l ) - 1 ) ) ) {\n\n\t\t\t\t\t\t\t\t\tlc -= l;\n\n\t\t\t\t\t\t\t\t\tgetCode( pl.p[ j ], rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );\n\n\t\t\t\t\t\t\t\t\tc = getCodeReturn.c;\n\t\t\t\t\t\t\t\t\tlc = getCodeReturn.lc;\n\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( j == pl.lit ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'hufDecode issues' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst i = ( 8 - ni ) & 7;\n\n\t\t\tc >>= i;\n\t\t\tlc -= i;\n\n\t\t\twhile ( lc > 0 ) {\n\n\t\t\t\tconst pl = decodingTable[ ( c << ( HUF_DECBITS - lc ) ) & HUF_DECMASK ];\n\n\t\t\t\tif ( pl.len ) {\n\n\t\t\t\t\tlc -= pl.len;\n\n\t\t\t\t\tgetCode( pl.lit, rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );\n\n\t\t\t\t\tc = getCodeReturn.c;\n\t\t\t\t\tlc = getCodeReturn.lc;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'hufDecode issues' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tfunction hufUncompress( uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw ) {\n\n\t\t\tconst outOffset = { value: 0 };\n\t\t\tconst initialInOffset = inOffset.value;\n\n\t\t\tconst im = parseUint32( inDataView, inOffset );\n\t\t\tconst iM = parseUint32( inDataView, inOffset );\n\n\t\t\tinOffset.value += 4;\n\n\t\t\tconst nBits = parseUint32( inDataView, inOffset );\n\n\t\t\tinOffset.value += 4;\n\n\t\t\tif ( im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE ) {\n\n\t\t\t\tthrow new Error( 'Something wrong with HUF_ENCSIZE' );\n\n\t\t\t}\n\n\t\t\tconst freq = new Array( HUF_ENCSIZE );\n\t\t\tconst hdec = new Array( HUF_DECSIZE );\n\n\t\t\thufClearDecTable( hdec );\n\n\t\t\tconst ni = nCompressed - ( inOffset.value - initialInOffset );\n\n\t\t\thufUnpackEncTable( uInt8Array, inOffset, ni, im, iM, freq );\n\n\t\t\tif ( nBits > 8 * ( nCompressed - ( inOffset.value - initialInOffset ) ) ) {\n\n\t\t\t\tthrow new Error( 'Something wrong with hufUncompress' );\n\n\t\t\t}\n\n\t\t\thufBuildDecTable( freq, im, iM, hdec );\n\n\t\t\thufDecode( freq, hdec, uInt8Array, inOffset, nBits, iM, nRaw, outBuffer, outOffset );\n\n\t\t}\n\n\t\tfunction applyLut( lut, data, nData ) {\n\n\t\t\tfor ( let i = 0; i < nData; ++ i ) {\n\n\t\t\t\tdata[ i ] = lut[ data[ i ] ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction predictor( source ) {\n\n\t\t\tfor ( let t = 1; t < source.length; t ++ ) {\n\n\t\t\t\tconst d = source[ t - 1 ] + source[ t ] - 128;\n\t\t\t\tsource[ t ] = d;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction interleaveScalar( source, out ) {\n\n\t\t\tlet t1 = 0;\n\t\t\tlet t2 = Math.floor( ( source.length + 1 ) / 2 );\n\t\t\tlet s = 0;\n\t\t\tconst stop = source.length - 1;\n\n\t\t\twhile ( true ) {\n\n\t\t\t\tif ( s > stop ) break;\n\t\t\t\tout[ s ++ ] = source[ t1 ++ ];\n\n\t\t\t\tif ( s > stop ) break;\n\t\t\t\tout[ s ++ ] = source[ t2 ++ ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction decodeRunLength( source ) {\n\n\t\t\tlet size = source.byteLength;\n\t\t\tconst out = new Array();\n\t\t\tlet p = 0;\n\n\t\t\tconst reader = new DataView( source );\n\n\t\t\twhile ( size > 0 ) {\n\n\t\t\t\tconst l = reader.getInt8( p ++ );\n\n\t\t\t\tif ( l < 0 ) {\n\n\t\t\t\t\tconst count = - l;\n\t\t\t\t\tsize -= count + 1;\n\n\t\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\tout.push( reader.getUint8( p ++ ) );\n\n\t\t\t\t\t}\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst count = l;\n\t\t\t\t\tsize -= 2;\n\n\t\t\t\t\tconst value = reader.getUint8( p ++ );\n\n\t\t\t\t\tfor ( let i = 0; i < count + 1; i ++ ) {\n\n\t\t\t\t\t\tout.push( value );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn out;\n\n\t\t}\n\n\t\tfunction lossyDctDecode( cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer ) {\n\n\t\t\tlet dataView = new DataView( outBuffer.buffer );\n\n\t\t\tconst width = channelData[ cscSet.idx[ 0 ] ].width;\n\t\t\tconst height = channelData[ cscSet.idx[ 0 ] ].height;\n\n\t\t\tconst numComp = 3;\n\n\t\t\tconst numFullBlocksX = Math.floor( width / 8.0 );\n\t\t\tconst numBlocksX = Math.ceil( width / 8.0 );\n\t\t\tconst numBlocksY = Math.ceil( height / 8.0 );\n\t\t\tconst leftoverX = width - ( numBlocksX - 1 ) * 8;\n\t\t\tconst leftoverY = height - ( numBlocksY - 1 ) * 8;\n\n\t\t\tconst currAcComp = { value: 0 };\n\t\t\tconst currDcComp = new Array( numComp );\n\t\t\tconst dctData = new Array( numComp );\n\t\t\tconst halfZigBlock = new Array( numComp );\n\t\t\tconst rowBlock = new Array( numComp );\n\t\t\tconst rowOffsets = new Array( numComp );\n\n\t\t\tfor ( let comp = 0; comp < numComp; ++ comp ) {\n\n\t\t\t\trowOffsets[ comp ] = rowPtrs[ cscSet.idx[ comp ] ];\n\t\t\t\tcurrDcComp[ comp ] = ( comp < 1 ) ? 0 : currDcComp[ comp - 1 ] + numBlocksX * numBlocksY;\n\t\t\t\tdctData[ comp ] = new Float32Array( 64 );\n\t\t\t\thalfZigBlock[ comp ] = new Uint16Array( 64 );\n\t\t\t\trowBlock[ comp ] = new Uint16Array( numBlocksX * 64 );\n\n\t\t\t}\n\n\t\t\tfor ( let blocky = 0; blocky < numBlocksY; ++ blocky ) {\n\n\t\t\t\tlet maxY = 8;\n\n\t\t\t\tif ( blocky == numBlocksY - 1 )\n\t\t\t\t\tmaxY = leftoverY;\n\n\t\t\t\tlet maxX = 8;\n\n\t\t\t\tfor ( let blockx = 0; blockx < numBlocksX; ++ blockx ) {\n\n\t\t\t\t\tif ( blockx == numBlocksX - 1 )\n\t\t\t\t\t\tmaxX = leftoverX;\n\n\t\t\t\t\tfor ( let comp = 0; comp < numComp; ++ comp ) {\n\n\t\t\t\t\t\thalfZigBlock[ comp ].fill( 0 );\n\n\t\t\t\t\t\t// set block DC component\n\t\t\t\t\t\thalfZigBlock[ comp ][ 0 ] = dcBuffer[ currDcComp[ comp ] ++ ];\n\t\t\t\t\t\t// set block AC components\n\t\t\t\t\t\tunRleAC( currAcComp, acBuffer, halfZigBlock[ comp ] );\n\n\t\t\t\t\t\t// UnZigZag block to float\n\t\t\t\t\t\tunZigZag( halfZigBlock[ comp ], dctData[ comp ] );\n\t\t\t\t\t\t// decode float dct\n\t\t\t\t\t\tdctInverse( dctData[ comp ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( numComp == 3 ) {\n\n\t\t\t\t\t\tcsc709Inverse( dctData );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let comp = 0; comp < numComp; ++ comp ) {\n\n\t\t\t\t\t\tconvertToHalf( dctData[ comp ], rowBlock[ comp ], blockx * 64 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} // blockx\n\n\t\t\t\tlet offset = 0;\n\n\t\t\t\tfor ( let comp = 0; comp < numComp; ++ comp ) {\n\n\t\t\t\t\tconst type = channelData[ cscSet.idx[ comp ] ].type;\n\n\t\t\t\t\tfor ( let y = 8 * blocky; y < 8 * blocky + maxY; ++ y ) {\n\n\t\t\t\t\t\toffset = rowOffsets[ comp ][ y ];\n\n\t\t\t\t\t\tfor ( let blockx = 0; blockx < numFullBlocksX; ++ blockx ) {\n\n\t\t\t\t\t\t\tconst src = blockx * 64 + ( ( y & 0x7 ) * 8 );\n\n\t\t\t\t\t\t\tdataView.setUint16( offset + 0 * INT16_SIZE * type, rowBlock[ comp ][ src + 0 ], true );\n\t\t\t\t\t\t\tdataView.setUint16( offset + 1 * INT16_SIZE * type, rowBlock[ comp ][ src + 1 ], true );\n\t\t\t\t\t\t\tdataView.setUint16( offset + 2 * INT16_SIZE * type, rowBlock[ comp ][ src + 2 ], true );\n\t\t\t\t\t\t\tdataView.setUint16( offset + 3 * INT16_SIZE * type, rowBlock[ comp ][ src + 3 ], true );\n\n\t\t\t\t\t\t\tdataView.setUint16( offset + 4 * INT16_SIZE * type, rowBlock[ comp ][ src + 4 ], true );\n\t\t\t\t\t\t\tdataView.setUint16( offset + 5 * INT16_SIZE * type, rowBlock[ comp ][ src + 5 ], true );\n\t\t\t\t\t\t\tdataView.setUint16( offset + 6 * INT16_SIZE * type, rowBlock[ comp ][ src + 6 ], true );\n\t\t\t\t\t\t\tdataView.setUint16( offset + 7 * INT16_SIZE * type, rowBlock[ comp ][ src + 7 ], true );\n\n\t\t\t\t\t\t\toffset += 8 * INT16_SIZE * type;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// handle partial X blocks\n\t\t\t\t\tif ( numFullBlocksX != numBlocksX ) {\n\n\t\t\t\t\t\tfor ( let y = 8 * blocky; y < 8 * blocky + maxY; ++ y ) {\n\n\t\t\t\t\t\t\tconst offset = rowOffsets[ comp ][ y ] + 8 * numFullBlocksX * INT16_SIZE * type;\n\t\t\t\t\t\t\tconst src = numFullBlocksX * 64 + ( ( y & 0x7 ) * 8 );\n\n\t\t\t\t\t\t\tfor ( let x = 0; x < maxX; ++ x ) {\n\n\t\t\t\t\t\t\t\tdataView.setUint16( offset + x * INT16_SIZE * type, rowBlock[ comp ][ src + x ], true );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} // comp\n\n\t\t\t} // blocky\n\n\t\t\tconst halfRow = new Uint16Array( width );\n\t\t\tdataView = new DataView( outBuffer.buffer );\n\n\t\t\t// convert channels back to float, if needed\n\t\t\tfor ( let comp = 0; comp < numComp; ++ comp ) {\n\n\t\t\t\tchannelData[ cscSet.idx[ comp ] ].decoded = true;\n\t\t\t\tconst type = channelData[ cscSet.idx[ comp ] ].type;\n\n\t\t\t\tif ( channelData[ comp ].type != 2 ) continue;\n\n\t\t\t\tfor ( let y = 0; y < height; ++ y ) {\n\n\t\t\t\t\tconst offset = rowOffsets[ comp ][ y ];\n\n\t\t\t\t\tfor ( let x = 0; x < width; ++ x ) {\n\n\t\t\t\t\t\thalfRow[ x ] = dataView.getUint16( offset + x * INT16_SIZE * type, true );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let x = 0; x < width; ++ x ) {\n\n\t\t\t\t\t\tdataView.setFloat32( offset + x * INT16_SIZE * type, decodeFloat16( halfRow[ x ] ), true );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction unRleAC( currAcComp, acBuffer, halfZigBlock ) {\n\n\t\t\tlet acValue;\n\t\t\tlet dctComp = 1;\n\n\t\t\twhile ( dctComp < 64 ) {\n\n\t\t\t\tacValue = acBuffer[ currAcComp.value ];\n\n\t\t\t\tif ( acValue == 0xff00 ) {\n\n\t\t\t\t\tdctComp = 64;\n\n\t\t\t\t} else if ( acValue >> 8 == 0xff ) {\n\n\t\t\t\t\tdctComp += acValue & 0xff;\n\n\t\t\t\t} else {\n\n\t\t\t\t\thalfZigBlock[ dctComp ] = acValue;\n\t\t\t\t\tdctComp ++;\n\n\t\t\t\t}\n\n\t\t\t\tcurrAcComp.value ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction unZigZag( src, dst ) {\n\n\t\t\tdst[ 0 ] = decodeFloat16( src[ 0 ] );\n\t\t\tdst[ 1 ] = decodeFloat16( src[ 1 ] );\n\t\t\tdst[ 2 ] = decodeFloat16( src[ 5 ] );\n\t\t\tdst[ 3 ] = decodeFloat16( src[ 6 ] );\n\t\t\tdst[ 4 ] = decodeFloat16( src[ 14 ] );\n\t\t\tdst[ 5 ] = decodeFloat16( src[ 15 ] );\n\t\t\tdst[ 6 ] = decodeFloat16( src[ 27 ] );\n\t\t\tdst[ 7 ] = decodeFloat16( src[ 28 ] );\n\t\t\tdst[ 8 ] = decodeFloat16( src[ 2 ] );\n\t\t\tdst[ 9 ] = decodeFloat16( src[ 4 ] );\n\n\t\t\tdst[ 10 ] = decodeFloat16( src[ 7 ] );\n\t\t\tdst[ 11 ] = decodeFloat16( src[ 13 ] );\n\t\t\tdst[ 12 ] = decodeFloat16( src[ 16 ] );\n\t\t\tdst[ 13 ] = decodeFloat16( src[ 26 ] );\n\t\t\tdst[ 14 ] = decodeFloat16( src[ 29 ] );\n\t\t\tdst[ 15 ] = decodeFloat16( src[ 42 ] );\n\t\t\tdst[ 16 ] = decodeFloat16( src[ 3 ] );\n\t\t\tdst[ 17 ] = decodeFloat16( src[ 8 ] );\n\t\t\tdst[ 18 ] = decodeFloat16( src[ 12 ] );\n\t\t\tdst[ 19 ] = decodeFloat16( src[ 17 ] );\n\n\t\t\tdst[ 20 ] = decodeFloat16( src[ 25 ] );\n\t\t\tdst[ 21 ] = decodeFloat16( src[ 30 ] );\n\t\t\tdst[ 22 ] = decodeFloat16( src[ 41 ] );\n\t\t\tdst[ 23 ] = decodeFloat16( src[ 43 ] );\n\t\t\tdst[ 24 ] = decodeFloat16( src[ 9 ] );\n\t\t\tdst[ 25 ] = decodeFloat16( src[ 11 ] );\n\t\t\tdst[ 26 ] = decodeFloat16( src[ 18 ] );\n\t\t\tdst[ 27 ] = decodeFloat16( src[ 24 ] );\n\t\t\tdst[ 28 ] = decodeFloat16( src[ 31 ] );\n\t\t\tdst[ 29 ] = decodeFloat16( src[ 40 ] );\n\n\t\t\tdst[ 30 ] = decodeFloat16( src[ 44 ] );\n\t\t\tdst[ 31 ] = decodeFloat16( src[ 53 ] );\n\t\t\tdst[ 32 ] = decodeFloat16( src[ 10 ] );\n\t\t\tdst[ 33 ] = decodeFloat16( src[ 19 ] );\n\t\t\tdst[ 34 ] = decodeFloat16( src[ 23 ] );\n\t\t\tdst[ 35 ] = decodeFloat16( src[ 32 ] );\n\t\t\tdst[ 36 ] = decodeFloat16( src[ 39 ] );\n\t\t\tdst[ 37 ] = decodeFloat16( src[ 45 ] );\n\t\t\tdst[ 38 ] = decodeFloat16( src[ 52 ] );\n\t\t\tdst[ 39 ] = decodeFloat16( src[ 54 ] );\n\n\t\t\tdst[ 40 ] = decodeFloat16( src[ 20 ] );\n\t\t\tdst[ 41 ] = decodeFloat16( src[ 22 ] );\n\t\t\tdst[ 42 ] = decodeFloat16( src[ 33 ] );\n\t\t\tdst[ 43 ] = decodeFloat16( src[ 38 ] );\n\t\t\tdst[ 44 ] = decodeFloat16( src[ 46 ] );\n\t\t\tdst[ 45 ] = decodeFloat16( src[ 51 ] );\n\t\t\tdst[ 46 ] = decodeFloat16( src[ 55 ] );\n\t\t\tdst[ 47 ] = decodeFloat16( src[ 60 ] );\n\t\t\tdst[ 48 ] = decodeFloat16( src[ 21 ] );\n\t\t\tdst[ 49 ] = decodeFloat16( src[ 34 ] );\n\n\t\t\tdst[ 50 ] = decodeFloat16( src[ 37 ] );\n\t\t\tdst[ 51 ] = decodeFloat16( src[ 47 ] );\n\t\t\tdst[ 52 ] = decodeFloat16( src[ 50 ] );\n\t\t\tdst[ 53 ] = decodeFloat16( src[ 56 ] );\n\t\t\tdst[ 54 ] = decodeFloat16( src[ 59 ] );\n\t\t\tdst[ 55 ] = decodeFloat16( src[ 61 ] );\n\t\t\tdst[ 56 ] = decodeFloat16( src[ 35 ] );\n\t\t\tdst[ 57 ] = decodeFloat16( src[ 36 ] );\n\t\t\tdst[ 58 ] = decodeFloat16( src[ 48 ] );\n\t\t\tdst[ 59 ] = decodeFloat16( src[ 49 ] );\n\n\t\t\tdst[ 60 ] = decodeFloat16( src[ 57 ] );\n\t\t\tdst[ 61 ] = decodeFloat16( src[ 58 ] );\n\t\t\tdst[ 62 ] = decodeFloat16( src[ 62 ] );\n\t\t\tdst[ 63 ] = decodeFloat16( src[ 63 ] );\n\n\t\t}\n\n\t\tfunction dctInverse( data ) {\n\n\t\t\tconst a = 0.5 * Math.cos( 3.14159 / 4.0 );\n\t\t\tconst b = 0.5 * Math.cos( 3.14159 / 16.0 );\n\t\t\tconst c = 0.5 * Math.cos( 3.14159 / 8.0 );\n\t\t\tconst d = 0.5 * Math.cos( 3.0 * 3.14159 / 16.0 );\n\t\t\tconst e = 0.5 * Math.cos( 5.0 * 3.14159 / 16.0 );\n\t\t\tconst f = 0.5 * Math.cos( 3.0 * 3.14159 / 8.0 );\n\t\t\tconst g = 0.5 * Math.cos( 7.0 * 3.14159 / 16.0 );\n\n\t\t\tconst alpha = new Array( 4 );\n\t\t\tconst beta = new Array( 4 );\n\t\t\tconst theta = new Array( 4 );\n\t\t\tconst gamma = new Array( 4 );\n\n\t\t\tfor ( let row = 0; row < 8; ++ row ) {\n\n\t\t\t\tconst rowPtr = row * 8;\n\n\t\t\t\talpha[ 0 ] = c * data[ rowPtr + 2 ];\n\t\t\t\talpha[ 1 ] = f * data[ rowPtr + 2 ];\n\t\t\t\talpha[ 2 ] = c * data[ rowPtr + 6 ];\n\t\t\t\talpha[ 3 ] = f * data[ rowPtr + 6 ];\n\n\t\t\t\tbeta[ 0 ] = b * data[ rowPtr + 1 ] + d * data[ rowPtr + 3 ] + e * data[ rowPtr + 5 ] + g * data[ rowPtr + 7 ];\n\t\t\t\tbeta[ 1 ] = d * data[ rowPtr + 1 ] - g * data[ rowPtr + 3 ] - b * data[ rowPtr + 5 ] - e * data[ rowPtr + 7 ];\n\t\t\t\tbeta[ 2 ] = e * data[ rowPtr + 1 ] - b * data[ rowPtr + 3 ] + g * data[ rowPtr + 5 ] + d * data[ rowPtr + 7 ];\n\t\t\t\tbeta[ 3 ] = g * data[ rowPtr + 1 ] - e * data[ rowPtr + 3 ] + d * data[ rowPtr + 5 ] - b * data[ rowPtr + 7 ];\n\n\t\t\t\ttheta[ 0 ] = a * ( data[ rowPtr + 0 ] + data[ rowPtr + 4 ] );\n\t\t\t\ttheta[ 3 ] = a * ( data[ rowPtr + 0 ] - data[ rowPtr + 4 ] );\n\t\t\t\ttheta[ 1 ] = alpha[ 0 ] + alpha[ 3 ];\n\t\t\t\ttheta[ 2 ] = alpha[ 1 ] - alpha[ 2 ];\n\n\t\t\t\tgamma[ 0 ] = theta[ 0 ] + theta[ 1 ];\n\t\t\t\tgamma[ 1 ] = theta[ 3 ] + theta[ 2 ];\n\t\t\t\tgamma[ 2 ] = theta[ 3 ] - theta[ 2 ];\n\t\t\t\tgamma[ 3 ] = theta[ 0 ] - theta[ 1 ];\n\n\t\t\t\tdata[ rowPtr + 0 ] = gamma[ 0 ] + beta[ 0 ];\n\t\t\t\tdata[ rowPtr + 1 ] = gamma[ 1 ] + beta[ 1 ];\n\t\t\t\tdata[ rowPtr + 2 ] = gamma[ 2 ] + beta[ 2 ];\n\t\t\t\tdata[ rowPtr + 3 ] = gamma[ 3 ] + beta[ 3 ];\n\n\t\t\t\tdata[ rowPtr + 4 ] = gamma[ 3 ] - beta[ 3 ];\n\t\t\t\tdata[ rowPtr + 5 ] = gamma[ 2 ] - beta[ 2 ];\n\t\t\t\tdata[ rowPtr + 6 ] = gamma[ 1 ] - beta[ 1 ];\n\t\t\t\tdata[ rowPtr + 7 ] = gamma[ 0 ] - beta[ 0 ];\n\n\t\t\t}\n\n\t\t\tfor ( let column = 0; column < 8; ++ column ) {\n\n\t\t\t\talpha[ 0 ] = c * data[ 16 + column ];\n\t\t\t\talpha[ 1 ] = f * data[ 16 + column ];\n\t\t\t\talpha[ 2 ] = c * data[ 48 + column ];\n\t\t\t\talpha[ 3 ] = f * data[ 48 + column ];\n\n\t\t\t\tbeta[ 0 ] = b * data[ 8 + column ] + d * data[ 24 + column ] + e * data[ 40 + column ] + g * data[ 56 + column ];\n\t\t\t\tbeta[ 1 ] = d * data[ 8 + column ] - g * data[ 24 + column ] - b * data[ 40 + column ] - e * data[ 56 + column ];\n\t\t\t\tbeta[ 2 ] = e * data[ 8 + column ] - b * data[ 24 + column ] + g * data[ 40 + column ] + d * data[ 56 + column ];\n\t\t\t\tbeta[ 3 ] = g * data[ 8 + column ] - e * data[ 24 + column ] + d * data[ 40 + column ] - b * data[ 56 + column ];\n\n\t\t\t\ttheta[ 0 ] = a * ( data[ column ] + data[ 32 + column ] );\n\t\t\t\ttheta[ 3 ] = a * ( data[ column ] - data[ 32 + column ] );\n\n\t\t\t\ttheta[ 1 ] = alpha[ 0 ] + alpha[ 3 ];\n\t\t\t\ttheta[ 2 ] = alpha[ 1 ] - alpha[ 2 ];\n\n\t\t\t\tgamma[ 0 ] = theta[ 0 ] + theta[ 1 ];\n\t\t\t\tgamma[ 1 ] = theta[ 3 ] + theta[ 2 ];\n\t\t\t\tgamma[ 2 ] = theta[ 3 ] - theta[ 2 ];\n\t\t\t\tgamma[ 3 ] = theta[ 0 ] - theta[ 1 ];\n\n\t\t\t\tdata[ 0 + column ] = gamma[ 0 ] + beta[ 0 ];\n\t\t\t\tdata[ 8 + column ] = gamma[ 1 ] + beta[ 1 ];\n\t\t\t\tdata[ 16 + column ] = gamma[ 2 ] + beta[ 2 ];\n\t\t\t\tdata[ 24 + column ] = gamma[ 3 ] + beta[ 3 ];\n\n\t\t\t\tdata[ 32 + column ] = gamma[ 3 ] - beta[ 3 ];\n\t\t\t\tdata[ 40 + column ] = gamma[ 2 ] - beta[ 2 ];\n\t\t\t\tdata[ 48 + column ] = gamma[ 1 ] - beta[ 1 ];\n\t\t\t\tdata[ 56 + column ] = gamma[ 0 ] - beta[ 0 ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction csc709Inverse( data ) {\n\n\t\t\tfor ( let i = 0; i < 64; ++ i ) {\n\n\t\t\t\tconst y = data[ 0 ][ i ];\n\t\t\t\tconst cb = data[ 1 ][ i ];\n\t\t\t\tconst cr = data[ 2 ][ i ];\n\n\t\t\t\tdata[ 0 ][ i ] = y + 1.5747 * cr;\n\t\t\t\tdata[ 1 ][ i ] = y - 0.1873 * cb - 0.4682 * cr;\n\t\t\t\tdata[ 2 ][ i ] = y + 1.8556 * cb;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction convertToHalf( src, dst, idx ) {\n\n\t\t\tfor ( let i = 0; i < 64; ++ i ) {\n\n\t\t\t\tdst[ idx + i ] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat( toLinear( src[ i ] ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction toLinear( float ) {\n\n\t\t\tif ( float <= 1 ) {\n\n\t\t\t\treturn Math.sign( float ) * Math.pow( Math.abs( float ), 2.2 );\n\n\t\t\t} else {\n\n\t\t\t\treturn Math.sign( float ) * Math.pow( logBase, Math.abs( float ) - 1.0 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction uncompressRAW( info ) {\n\n\t\t\treturn new DataView( info.array.buffer, info.offset.value, info.size );\n\n\t\t}\n\n\t\tfunction uncompressRLE( info ) {\n\n\t\t\tconst compressed = info.viewer.buffer.slice( info.offset.value, info.offset.value + info.size );\n\n\t\t\tconst rawBuffer = new Uint8Array( decodeRunLength( compressed ) );\n\t\t\tconst tmpBuffer = new Uint8Array( rawBuffer.length );\n\n\t\t\tpredictor( rawBuffer ); // revert predictor\n\n\t\t\tinterleaveScalar( rawBuffer, tmpBuffer ); // interleave pixels\n\n\t\t\treturn new DataView( tmpBuffer.buffer );\n\n\t\t}\n\n\t\tfunction uncompressZIP( info ) {\n\n\t\t\tconst compressed = info.array.slice( info.offset.value, info.offset.value + info.size );\n\n\t\t\tconst rawBuffer = _libs_fflate_module_js__WEBPACK_IMPORTED_MODULE_1__.unzlibSync( compressed );\n\t\t\tconst tmpBuffer = new Uint8Array( rawBuffer.length );\n\n\t\t\tpredictor( rawBuffer ); // revert predictor\n\n\t\t\tinterleaveScalar( rawBuffer, tmpBuffer ); // interleave pixels\n\n\t\t\treturn new DataView( tmpBuffer.buffer );\n\n\t\t}\n\n\t\tfunction uncompressPIZ( info ) {\n\n\t\t\tconst inDataView = info.viewer;\n\t\t\tconst inOffset = { value: info.offset.value };\n\n\t\t\tconst outBuffer = new Uint16Array( info.width * info.scanlineBlockSize * ( info.channels * info.type ) );\n\t\t\tconst bitmap = new Uint8Array( BITMAP_SIZE );\n\n\t\t\t// Setup channel info\n\t\t\tlet outBufferEnd = 0;\n\t\t\tconst pizChannelData = new Array( info.channels );\n\t\t\tfor ( let i = 0; i < info.channels; i ++ ) {\n\n\t\t\t\tpizChannelData[ i ] = {};\n\t\t\t\tpizChannelData[ i ][ 'start' ] = outBufferEnd;\n\t\t\t\tpizChannelData[ i ][ 'end' ] = pizChannelData[ i ][ 'start' ];\n\t\t\t\tpizChannelData[ i ][ 'nx' ] = info.width;\n\t\t\t\tpizChannelData[ i ][ 'ny' ] = info.lines;\n\t\t\t\tpizChannelData[ i ][ 'size' ] = info.type;\n\n\t\t\t\toutBufferEnd += pizChannelData[ i ].nx * pizChannelData[ i ].ny * pizChannelData[ i ].size;\n\n\t\t\t}\n\n\t\t\t// Read range compression data\n\n\t\t\tconst minNonZero = parseUint16( inDataView, inOffset );\n\t\t\tconst maxNonZero = parseUint16( inDataView, inOffset );\n\n\t\t\tif ( maxNonZero >= BITMAP_SIZE ) {\n\n\t\t\t\tthrow new Error( 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE' );\n\n\t\t\t}\n\n\t\t\tif ( minNonZero <= maxNonZero ) {\n\n\t\t\t\tfor ( let i = 0; i < maxNonZero - minNonZero + 1; i ++ ) {\n\n\t\t\t\t\tbitmap[ i + minNonZero ] = parseUint8( inDataView, inOffset );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Reverse LUT\n\t\t\tconst lut = new Uint16Array( USHORT_RANGE );\n\t\t\tconst maxValue = reverseLutFromBitmap( bitmap, lut );\n\n\t\t\tconst length = parseUint32( inDataView, inOffset );\n\n\t\t\t// Huffman decoding\n\t\t\thufUncompress( info.array, inDataView, inOffset, length, outBuffer, outBufferEnd );\n\n\t\t\t// Wavelet decoding\n\t\t\tfor ( let i = 0; i < info.channels; ++ i ) {\n\n\t\t\t\tconst cd = pizChannelData[ i ];\n\n\t\t\t\tfor ( let j = 0; j < pizChannelData[ i ].size; ++ j ) {\n\n\t\t\t\t\twav2Decode(\n\t\t\t\t\t\toutBuffer,\n\t\t\t\t\t\tcd.start + j,\n\t\t\t\t\t\tcd.nx,\n\t\t\t\t\t\tcd.size,\n\t\t\t\t\t\tcd.ny,\n\t\t\t\t\t\tcd.nx * cd.size,\n\t\t\t\t\t\tmaxValue\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Expand the pixel data to their original range\n\t\t\tapplyLut( lut, outBuffer, outBufferEnd );\n\n\t\t\t// Rearrange the pixel data into the format expected by the caller.\n\t\t\tlet tmpOffset = 0;\n\t\t\tconst tmpBuffer = new Uint8Array( outBuffer.buffer.byteLength );\n\t\t\tfor ( let y = 0; y < info.lines; y ++ ) {\n\n\t\t\t\tfor ( let c = 0; c < info.channels; c ++ ) {\n\n\t\t\t\t\tconst cd = pizChannelData[ c ];\n\n\t\t\t\t\tconst n = cd.nx * cd.size;\n\t\t\t\t\tconst cp = new Uint8Array( outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE );\n\n\t\t\t\t\ttmpBuffer.set( cp, tmpOffset );\n\t\t\t\t\ttmpOffset += n * INT16_SIZE;\n\t\t\t\t\tcd.end += n;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new DataView( tmpBuffer.buffer );\n\n\t\t}\n\n\t\tfunction uncompressPXR( info ) {\n\n\t\t\tconst compressed = info.array.slice( info.offset.value, info.offset.value + info.size );\n\n\t\t\tconst rawBuffer = _libs_fflate_module_js__WEBPACK_IMPORTED_MODULE_1__.unzlibSync( compressed );\n\n\t\t\tconst sz = info.lines * info.channels * info.width;\n\t\t\tconst tmpBuffer = ( info.type == 1 ) ? new Uint16Array( sz ) : new Uint32Array( sz );\n\n\t\t\tlet tmpBufferEnd = 0;\n\t\t\tlet writePtr = 0;\n\t\t\tconst ptr = new Array( 4 );\n\n\t\t\tfor ( let y = 0; y < info.lines; y ++ ) {\n\n\t\t\t\tfor ( let c = 0; c < info.channels; c ++ ) {\n\n\t\t\t\t\tlet pixel = 0;\n\n\t\t\t\t\tswitch ( info.type ) {\n\n\t\t\t\t\t\tcase 1:\n\n\t\t\t\t\t\t\tptr[ 0 ] = tmpBufferEnd;\n\t\t\t\t\t\t\tptr[ 1 ] = ptr[ 0 ] + info.width;\n\t\t\t\t\t\t\ttmpBufferEnd = ptr[ 1 ] + info.width;\n\n\t\t\t\t\t\t\tfor ( let j = 0; j < info.width; ++ j ) {\n\n\t\t\t\t\t\t\t\tconst diff = ( rawBuffer[ ptr[ 0 ] ++ ] << 8 ) | rawBuffer[ ptr[ 1 ] ++ ];\n\n\t\t\t\t\t\t\t\tpixel += diff;\n\n\t\t\t\t\t\t\t\ttmpBuffer[ writePtr ] = pixel;\n\t\t\t\t\t\t\t\twritePtr ++;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 2:\n\n\t\t\t\t\t\t\tptr[ 0 ] = tmpBufferEnd;\n\t\t\t\t\t\t\tptr[ 1 ] = ptr[ 0 ] + info.width;\n\t\t\t\t\t\t\tptr[ 2 ] = ptr[ 1 ] + info.width;\n\t\t\t\t\t\t\ttmpBufferEnd = ptr[ 2 ] + info.width;\n\n\t\t\t\t\t\t\tfor ( let j = 0; j < info.width; ++ j ) {\n\n\t\t\t\t\t\t\t\tconst diff = ( rawBuffer[ ptr[ 0 ] ++ ] << 24 ) | ( rawBuffer[ ptr[ 1 ] ++ ] << 16 ) | ( rawBuffer[ ptr[ 2 ] ++ ] << 8 );\n\n\t\t\t\t\t\t\t\tpixel += diff;\n\n\t\t\t\t\t\t\t\ttmpBuffer[ writePtr ] = pixel;\n\t\t\t\t\t\t\t\twritePtr ++;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new DataView( tmpBuffer.buffer );\n\n\t\t}\n\n\t\tfunction uncompressDWA( info ) {\n\n\t\t\tconst inDataView = info.viewer;\n\t\t\tconst inOffset = { value: info.offset.value };\n\t\t\tconst outBuffer = new Uint8Array( info.width * info.lines * ( info.channels * info.type * INT16_SIZE ) );\n\n\t\t\t// Read compression header information\n\t\t\tconst dwaHeader = {\n\n\t\t\t\tversion: parseInt64( inDataView, inOffset ),\n\t\t\t\tunknownUncompressedSize: parseInt64( inDataView, inOffset ),\n\t\t\t\tunknownCompressedSize: parseInt64( inDataView, inOffset ),\n\t\t\t\tacCompressedSize: parseInt64( inDataView, inOffset ),\n\t\t\t\tdcCompressedSize: parseInt64( inDataView, inOffset ),\n\t\t\t\trleCompressedSize: parseInt64( inDataView, inOffset ),\n\t\t\t\trleUncompressedSize: parseInt64( inDataView, inOffset ),\n\t\t\t\trleRawSize: parseInt64( inDataView, inOffset ),\n\t\t\t\ttotalAcUncompressedCount: parseInt64( inDataView, inOffset ),\n\t\t\t\ttotalDcUncompressedCount: parseInt64( inDataView, inOffset ),\n\t\t\t\tacCompression: parseInt64( inDataView, inOffset )\n\n\t\t\t};\n\n\t\t\tif ( dwaHeader.version < 2 )\n\t\t\t\tthrow new Error( 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported' );\n\n\t\t\t// Read channel ruleset information\n\t\t\tconst channelRules = new Array();\n\t\t\tlet ruleSize = parseUint16( inDataView, inOffset ) - INT16_SIZE;\n\n\t\t\twhile ( ruleSize > 0 ) {\n\n\t\t\t\tconst name = parseNullTerminatedString( inDataView.buffer, inOffset );\n\t\t\t\tconst value = parseUint8( inDataView, inOffset );\n\t\t\t\tconst compression = ( value >> 2 ) & 3;\n\t\t\t\tconst csc = ( value >> 4 ) - 1;\n\t\t\t\tconst index = new Int8Array( [ csc ] )[ 0 ];\n\t\t\t\tconst type = parseUint8( inDataView, inOffset );\n\n\t\t\t\tchannelRules.push( {\n\t\t\t\t\tname: name,\n\t\t\t\t\tindex: index,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tcompression: compression,\n\t\t\t\t} );\n\n\t\t\t\truleSize -= name.length + 3;\n\n\t\t\t}\n\n\t\t\t// Classify channels\n\t\t\tconst channels = EXRHeader.channels;\n\t\t\tconst channelData = new Array( info.channels );\n\n\t\t\tfor ( let i = 0; i < info.channels; ++ i ) {\n\n\t\t\t\tconst cd = channelData[ i ] = {};\n\t\t\t\tconst channel = channels[ i ];\n\n\t\t\t\tcd.name = channel.name;\n\t\t\t\tcd.compression = UNKNOWN;\n\t\t\t\tcd.decoded = false;\n\t\t\t\tcd.type = channel.pixelType;\n\t\t\t\tcd.pLinear = channel.pLinear;\n\t\t\t\tcd.width = info.width;\n\t\t\t\tcd.height = info.lines;\n\n\t\t\t}\n\n\t\t\tconst cscSet = {\n\t\t\t\tidx: new Array( 3 )\n\t\t\t};\n\n\t\t\tfor ( let offset = 0; offset < info.channels; ++ offset ) {\n\n\t\t\t\tconst cd = channelData[ offset ];\n\n\t\t\t\tfor ( let i = 0; i < channelRules.length; ++ i ) {\n\n\t\t\t\t\tconst rule = channelRules[ i ];\n\n\t\t\t\t\tif ( cd.name == rule.name ) {\n\n\t\t\t\t\t\tcd.compression = rule.compression;\n\n\t\t\t\t\t\tif ( rule.index >= 0 ) {\n\n\t\t\t\t\t\t\tcscSet.idx[ rule.index ] = offset;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcd.offset = offset;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet acBuffer, dcBuffer, rleBuffer;\n\n\t\t\t// Read DCT - AC component data\n\t\t\tif ( dwaHeader.acCompressedSize > 0 ) {\n\n\t\t\t\tswitch ( dwaHeader.acCompression ) {\n\n\t\t\t\t\tcase STATIC_HUFFMAN:\n\n\t\t\t\t\t\tacBuffer = new Uint16Array( dwaHeader.totalAcUncompressedCount );\n\t\t\t\t\t\thufUncompress( info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DEFLATE:\n\n\t\t\t\t\t\tconst compressed = info.array.slice( inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount );\n\t\t\t\t\t\tconst data = _libs_fflate_module_js__WEBPACK_IMPORTED_MODULE_1__.unzlibSync( compressed );\n\t\t\t\t\t\tacBuffer = new Uint16Array( data.buffer );\n\t\t\t\t\t\tinOffset.value += dwaHeader.totalAcUncompressedCount;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t\t\t// Read DCT - DC component data\n\t\t\tif ( dwaHeader.dcCompressedSize > 0 ) {\n\n\t\t\t\tconst zlibInfo = {\n\t\t\t\t\tarray: info.array,\n\t\t\t\t\toffset: inOffset,\n\t\t\t\t\tsize: dwaHeader.dcCompressedSize\n\t\t\t\t};\n\t\t\t\tdcBuffer = new Uint16Array( uncompressZIP( zlibInfo ).buffer );\n\t\t\t\tinOffset.value += dwaHeader.dcCompressedSize;\n\n\t\t\t}\n\n\t\t\t// Read RLE compressed data\n\t\t\tif ( dwaHeader.rleRawSize > 0 ) {\n\n\t\t\t\tconst compressed = info.array.slice( inOffset.value, inOffset.value + dwaHeader.rleCompressedSize );\n\t\t\t\tconst data = _libs_fflate_module_js__WEBPACK_IMPORTED_MODULE_1__.unzlibSync( compressed );\n\t\t\t\trleBuffer = decodeRunLength( data.buffer );\n\n\t\t\t\tinOffset.value += dwaHeader.rleCompressedSize;\n\n\t\t\t}\n\n\t\t\t// Prepare outbuffer data offset\n\t\t\tlet outBufferEnd = 0;\n\t\t\tconst rowOffsets = new Array( channelData.length );\n\t\t\tfor ( let i = 0; i < rowOffsets.length; ++ i ) {\n\n\t\t\t\trowOffsets[ i ] = new Array();\n\n\t\t\t}\n\n\t\t\tfor ( let y = 0; y < info.lines; ++ y ) {\n\n\t\t\t\tfor ( let chan = 0; chan < channelData.length; ++ chan ) {\n\n\t\t\t\t\trowOffsets[ chan ].push( outBufferEnd );\n\t\t\t\t\toutBufferEnd += channelData[ chan ].width * info.type * INT16_SIZE;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Lossy DCT decode RGB channels\n\t\t\tlossyDctDecode( cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer );\n\n\t\t\t// Decode other channels\n\t\t\tfor ( let i = 0; i < channelData.length; ++ i ) {\n\n\t\t\t\tconst cd = channelData[ i ];\n\n\t\t\t\tif ( cd.decoded ) continue;\n\n\t\t\t\tswitch ( cd.compression ) {\n\n\t\t\t\t\tcase RLE:\n\n\t\t\t\t\t\tlet row = 0;\n\t\t\t\t\t\tlet rleOffset = 0;\n\n\t\t\t\t\t\tfor ( let y = 0; y < info.lines; ++ y ) {\n\n\t\t\t\t\t\t\tlet rowOffsetBytes = rowOffsets[ i ][ row ];\n\n\t\t\t\t\t\t\tfor ( let x = 0; x < cd.width; ++ x ) {\n\n\t\t\t\t\t\t\t\tfor ( let byte = 0; byte < INT16_SIZE * cd.type; ++ byte ) {\n\n\t\t\t\t\t\t\t\t\toutBuffer[ rowOffsetBytes ++ ] = rleBuffer[ rleOffset + byte * cd.width * cd.height ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\trleOffset ++;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\trow ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase LOSSY_DCT: // skip\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error( 'EXRLoader.parse: unsupported channel compression' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new DataView( outBuffer.buffer );\n\n\t\t}\n\n\t\tfunction parseNullTerminatedString( buffer, offset ) {\n\n\t\t\tconst uintBuffer = new Uint8Array( buffer );\n\t\t\tlet endOffset = 0;\n\n\t\t\twhile ( uintBuffer[ offset.value + endOffset ] != 0 ) {\n\n\t\t\t\tendOffset += 1;\n\n\t\t\t}\n\n\t\t\tconst stringValue = new TextDecoder().decode(\n\t\t\t\tuintBuffer.slice( offset.value, offset.value + endOffset )\n\t\t\t);\n\n\t\t\toffset.value = offset.value + endOffset + 1;\n\n\t\t\treturn stringValue;\n\n\t\t}\n\n\t\tfunction parseFixedLengthString( buffer, offset, size ) {\n\n\t\t\tconst stringValue = new TextDecoder().decode(\n\t\t\t\tnew Uint8Array( buffer ).slice( offset.value, offset.value + size )\n\t\t\t);\n\n\t\t\toffset.value = offset.value + size;\n\n\t\t\treturn stringValue;\n\n\t\t}\n\n\t\tfunction parseRational( dataView, offset ) {\n\n\t\t\tconst x = parseInt32( dataView, offset );\n\t\t\tconst y = parseUint32( dataView, offset );\n\n\t\t\treturn [ x, y ];\n\n\t\t}\n\n\t\tfunction parseTimecode( dataView, offset ) {\n\n\t\t\tconst x = parseUint32( dataView, offset );\n\t\t\tconst y = parseUint32( dataView, offset );\n\n\t\t\treturn [ x, y ];\n\n\t\t}\n\n\t\tfunction parseInt32( dataView, offset ) {\n\n\t\t\tconst Int32 = dataView.getInt32( offset.value, true );\n\n\t\t\toffset.value = offset.value + INT32_SIZE;\n\n\t\t\treturn Int32;\n\n\t\t}\n\n\t\tfunction parseUint32( dataView, offset ) {\n\n\t\t\tconst Uint32 = dataView.getUint32( offset.value, true );\n\n\t\t\toffset.value = offset.value + INT32_SIZE;\n\n\t\t\treturn Uint32;\n\n\t\t}\n\n\t\tfunction parseUint8Array( uInt8Array, offset ) {\n\n\t\t\tconst Uint8 = uInt8Array[ offset.value ];\n\n\t\t\toffset.value = offset.value + INT8_SIZE;\n\n\t\t\treturn Uint8;\n\n\t\t}\n\n\t\tfunction parseUint8( dataView, offset ) {\n\n\t\t\tconst Uint8 = dataView.getUint8( offset.value );\n\n\t\t\toffset.value = offset.value + INT8_SIZE;\n\n\t\t\treturn Uint8;\n\n\t\t}\n\n\t\tconst parseInt64 = function ( dataView, offset ) {\n\n\t\t\tlet int;\n\n\t\t\tif ( 'getBigInt64' in DataView.prototype ) {\n\n\t\t\t\tint = Number( dataView.getBigInt64( offset.value, true ) );\n\n\t\t\t} else {\n\n\t\t\t\tint = dataView.getUint32( offset.value + 4, true ) + Number( dataView.getUint32( offset.value, true ) << 32 );\n\n\t\t\t}\n\n\t\t\toffset.value += ULONG_SIZE;\n\n\t\t\treturn int;\n\n\t\t};\n\n\t\tfunction parseFloat32( dataView, offset ) {\n\n\t\t\tconst float = dataView.getFloat32( offset.value, true );\n\n\t\t\toffset.value += FLOAT32_SIZE;\n\n\t\t\treturn float;\n\n\t\t}\n\n\t\tfunction decodeFloat32( dataView, offset ) {\n\n\t\t\treturn three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat( parseFloat32( dataView, offset ) );\n\n\t\t}\n\n\t\t// https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\n\t\tfunction decodeFloat16( binary ) {\n\n\t\t\tconst exponent = ( binary & 0x7C00 ) >> 10,\n\t\t\t\tfraction = binary & 0x03FF;\n\n\t\t\treturn ( binary >> 15 ? - 1 : 1 ) * (\n\t\t\t\texponent ?\n\t\t\t\t\t(\n\t\t\t\t\t\texponent === 0x1F ?\n\t\t\t\t\t\t\tfraction ? NaN : Infinity :\n\t\t\t\t\t\t\tMath.pow( 2, exponent - 15 ) * ( 1 + fraction / 0x400 )\n\t\t\t\t\t) :\n\t\t\t\t\t6.103515625e-5 * ( fraction / 0x400 )\n\t\t\t);\n\n\t\t}\n\n\t\tfunction parseUint16( dataView, offset ) {\n\n\t\t\tconst Uint16 = dataView.getUint16( offset.value, true );\n\n\t\t\toffset.value += INT16_SIZE;\n\n\t\t\treturn Uint16;\n\n\t\t}\n\n\t\tfunction parseFloat16( buffer, offset ) {\n\n\t\t\treturn decodeFloat16( parseUint16( buffer, offset ) );\n\n\t\t}\n\n\t\tfunction parseChlist( dataView, buffer, offset, size ) {\n\n\t\t\tconst startOffset = offset.value;\n\t\t\tconst channels = [];\n\n\t\t\twhile ( offset.value < ( startOffset + size - 1 ) ) {\n\n\t\t\t\tconst name = parseNullTerminatedString( buffer, offset );\n\t\t\t\tconst pixelType = parseInt32( dataView, offset );\n\t\t\t\tconst pLinear = parseUint8( dataView, offset );\n\t\t\t\toffset.value += 3; // reserved, three chars\n\t\t\t\tconst xSampling = parseInt32( dataView, offset );\n\t\t\t\tconst ySampling = parseInt32( dataView, offset );\n\n\t\t\t\tchannels.push( {\n\t\t\t\t\tname: name,\n\t\t\t\t\tpixelType: pixelType,\n\t\t\t\t\tpLinear: pLinear,\n\t\t\t\t\txSampling: xSampling,\n\t\t\t\t\tySampling: ySampling\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\toffset.value += 1;\n\n\t\t\treturn channels;\n\n\t\t}\n\n\t\tfunction parseChromaticities( dataView, offset ) {\n\n\t\t\tconst redX = parseFloat32( dataView, offset );\n\t\t\tconst redY = parseFloat32( dataView, offset );\n\t\t\tconst greenX = parseFloat32( dataView, offset );\n\t\t\tconst greenY = parseFloat32( dataView, offset );\n\t\t\tconst blueX = parseFloat32( dataView, offset );\n\t\t\tconst blueY = parseFloat32( dataView, offset );\n\t\t\tconst whiteX = parseFloat32( dataView, offset );\n\t\t\tconst whiteY = parseFloat32( dataView, offset );\n\n\t\t\treturn { redX: redX, redY: redY, greenX: greenX, greenY: greenY, blueX: blueX, blueY: blueY, whiteX: whiteX, whiteY: whiteY };\n\n\t\t}\n\n\t\tfunction parseCompression( dataView, offset ) {\n\n\t\t\tconst compressionCodes = [\n\t\t\t\t'NO_COMPRESSION',\n\t\t\t\t'RLE_COMPRESSION',\n\t\t\t\t'ZIPS_COMPRESSION',\n\t\t\t\t'ZIP_COMPRESSION',\n\t\t\t\t'PIZ_COMPRESSION',\n\t\t\t\t'PXR24_COMPRESSION',\n\t\t\t\t'B44_COMPRESSION',\n\t\t\t\t'B44A_COMPRESSION',\n\t\t\t\t'DWAA_COMPRESSION',\n\t\t\t\t'DWAB_COMPRESSION'\n\t\t\t];\n\n\t\t\tconst compression = parseUint8( dataView, offset );\n\n\t\t\treturn compressionCodes[ compression ];\n\n\t\t}\n\n\t\tfunction parseBox2i( dataView, offset ) {\n\n\t\t\tconst xMin = parseUint32( dataView, offset );\n\t\t\tconst yMin = parseUint32( dataView, offset );\n\t\t\tconst xMax = parseUint32( dataView, offset );\n\t\t\tconst yMax = parseUint32( dataView, offset );\n\n\t\t\treturn { xMin: xMin, yMin: yMin, xMax: xMax, yMax: yMax };\n\n\t\t}\n\n\t\tfunction parseLineOrder( dataView, offset ) {\n\n\t\t\tconst lineOrders = [\n\t\t\t\t'INCREASING_Y'\n\t\t\t];\n\n\t\t\tconst lineOrder = parseUint8( dataView, offset );\n\n\t\t\treturn lineOrders[ lineOrder ];\n\n\t\t}\n\n\t\tfunction parseV2f( dataView, offset ) {\n\n\t\t\tconst x = parseFloat32( dataView, offset );\n\t\t\tconst y = parseFloat32( dataView, offset );\n\n\t\t\treturn [ x, y ];\n\n\t\t}\n\n\t\tfunction parseV3f( dataView, offset ) {\n\n\t\t\tconst x = parseFloat32( dataView, offset );\n\t\t\tconst y = parseFloat32( dataView, offset );\n\t\t\tconst z = parseFloat32( dataView, offset );\n\n\t\t\treturn [ x, y, z ];\n\n\t\t}\n\n\t\tfunction parseValue( dataView, buffer, offset, type, size ) {\n\n\t\t\tif ( type === 'string' || type === 'stringvector' || type === 'iccProfile' ) {\n\n\t\t\t\treturn parseFixedLengthString( buffer, offset, size );\n\n\t\t\t} else if ( type === 'chlist' ) {\n\n\t\t\t\treturn parseChlist( dataView, buffer, offset, size );\n\n\t\t\t} else if ( type === 'chromaticities' ) {\n\n\t\t\t\treturn parseChromaticities( dataView, offset );\n\n\t\t\t} else if ( type === 'compression' ) {\n\n\t\t\t\treturn parseCompression( dataView, offset );\n\n\t\t\t} else if ( type === 'box2i' ) {\n\n\t\t\t\treturn parseBox2i( dataView, offset );\n\n\t\t\t} else if ( type === 'lineOrder' ) {\n\n\t\t\t\treturn parseLineOrder( dataView, offset );\n\n\t\t\t} else if ( type === 'float' ) {\n\n\t\t\t\treturn parseFloat32( dataView, offset );\n\n\t\t\t} else if ( type === 'v2f' ) {\n\n\t\t\t\treturn parseV2f( dataView, offset );\n\n\t\t\t} else if ( type === 'v3f' ) {\n\n\t\t\t\treturn parseV3f( dataView, offset );\n\n\t\t\t} else if ( type === 'int' ) {\n\n\t\t\t\treturn parseInt32( dataView, offset );\n\n\t\t\t} else if ( type === 'rational' ) {\n\n\t\t\t\treturn parseRational( dataView, offset );\n\n\t\t\t} else if ( type === 'timecode' ) {\n\n\t\t\t\treturn parseTimecode( dataView, offset );\n\n\t\t\t} else if ( type === 'preview' ) {\n\n\t\t\t\toffset.value += size;\n\t\t\t\treturn 'skipped';\n\n\t\t\t} else {\n\n\t\t\t\toffset.value += size;\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseHeader( dataView, buffer, offset ) {\n\n\t\t\tconst EXRHeader = {};\n\n\t\t\tif ( dataView.getUint32( 0, true ) != 20000630 ) { // magic\n\n\t\t\t\tthrow new Error( 'THREE.EXRLoader: provided file doesn\\'t appear to be in OpenEXR format.' );\n\n\t\t\t}\n\n\t\t\tEXRHeader.version = dataView.getUint8( 4 );\n\n\t\t\tconst spec = dataView.getUint8( 5 ); // fullMask\n\n\t\t\tEXRHeader.spec = {\n\t\t\t\tsingleTile: !! ( spec & 2 ),\n\t\t\t\tlongName: !! ( spec & 4 ),\n\t\t\t\tdeepFormat: !! ( spec & 8 ),\n\t\t\t\tmultiPart: !! ( spec & 16 ),\n\t\t\t};\n\n\t\t\t// start of header\n\n\t\t\toffset.value = 8; // start at 8 - after pre-amble\n\n\t\t\tlet keepReading = true;\n\n\t\t\twhile ( keepReading ) {\n\n\t\t\t\tconst attributeName = parseNullTerminatedString( buffer, offset );\n\n\t\t\t\tif ( attributeName == 0 ) {\n\n\t\t\t\t\tkeepReading = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst attributeType = parseNullTerminatedString( buffer, offset );\n\t\t\t\t\tconst attributeSize = parseUint32( dataView, offset );\n\t\t\t\t\tconst attributeValue = parseValue( dataView, buffer, offset, attributeType, attributeSize );\n\n\t\t\t\t\tif ( attributeValue === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( `EXRLoader.parse: skipped unknown header attribute type \\'${attributeType}\\'.` );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tEXRHeader[ attributeName ] = attributeValue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ( spec & ~ 0x04 ) != 0 ) { // unsupported tiled, deep-image, multi-part\n\n\t\t\t\tconsole.error( 'EXRHeader:', EXRHeader );\n\t\t\t\tthrow new Error( 'THREE.EXRLoader: provided file is currently unsupported.' );\n\n\t\t\t}\n\n\t\t\treturn EXRHeader;\n\n\t\t}\n\n\t\tfunction setupDecoder( EXRHeader, dataView, uInt8Array, offset, outputType ) {\n\n\t\t\tconst EXRDecoder = {\n\t\t\t\tsize: 0,\n\t\t\t\tviewer: dataView,\n\t\t\t\tarray: uInt8Array,\n\t\t\t\toffset: offset,\n\t\t\t\twidth: EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1,\n\t\t\t\theight: EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1,\n\t\t\t\tchannels: EXRHeader.channels.length,\n\t\t\t\tbytesPerLine: null,\n\t\t\t\tlines: null,\n\t\t\t\tinputSize: null,\n\t\t\t\ttype: EXRHeader.channels[ 0 ].pixelType,\n\t\t\t\tuncompress: null,\n\t\t\t\tgetter: null,\n\t\t\t\tformat: null,\n\t\t\t\tcolorSpace: three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace,\n\t\t\t};\n\n\t\t\tswitch ( EXRHeader.compression ) {\n\n\t\t\t\tcase 'NO_COMPRESSION':\n\t\t\t\t\tEXRDecoder.lines = 1;\n\t\t\t\t\tEXRDecoder.uncompress = uncompressRAW;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'RLE_COMPRESSION':\n\t\t\t\t\tEXRDecoder.lines = 1;\n\t\t\t\t\tEXRDecoder.uncompress = uncompressRLE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ZIPS_COMPRESSION':\n\t\t\t\t\tEXRDecoder.lines = 1;\n\t\t\t\t\tEXRDecoder.uncompress = uncompressZIP;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ZIP_COMPRESSION':\n\t\t\t\t\tEXRDecoder.lines = 16;\n\t\t\t\t\tEXRDecoder.uncompress = uncompressZIP;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PIZ_COMPRESSION':\n\t\t\t\t\tEXRDecoder.lines = 32;\n\t\t\t\t\tEXRDecoder.uncompress = uncompressPIZ;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PXR24_COMPRESSION':\n\t\t\t\t\tEXRDecoder.lines = 16;\n\t\t\t\t\tEXRDecoder.uncompress = uncompressPXR;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DWAA_COMPRESSION':\n\t\t\t\t\tEXRDecoder.lines = 32;\n\t\t\t\t\tEXRDecoder.uncompress = uncompressDWA;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DWAB_COMPRESSION':\n\t\t\t\t\tEXRDecoder.lines = 256;\n\t\t\t\t\tEXRDecoder.uncompress = uncompressDWA;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported' );\n\n\t\t\t}\n\n\t\t\tEXRDecoder.scanlineBlockSize = EXRDecoder.lines;\n\n\t\t\tif ( EXRDecoder.type == 1 ) {\n\n\t\t\t\t// half\n\t\t\t\tswitch ( outputType ) {\n\n\t\t\t\t\tcase three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n\t\t\t\t\t\tEXRDecoder.getter = parseFloat16;\n\t\t\t\t\t\tEXRDecoder.inputSize = INT16_SIZE;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n\t\t\t\t\t\tEXRDecoder.getter = parseUint16;\n\t\t\t\t\t\tEXRDecoder.inputSize = INT16_SIZE;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} else if ( EXRDecoder.type == 2 ) {\n\n\t\t\t\t// float\n\t\t\t\tswitch ( outputType ) {\n\n\t\t\t\t\tcase three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n\t\t\t\t\t\tEXRDecoder.getter = parseFloat32;\n\t\t\t\t\t\tEXRDecoder.inputSize = FLOAT32_SIZE;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n\t\t\t\t\t\tEXRDecoder.getter = decodeFloat32;\n\t\t\t\t\t\tEXRDecoder.inputSize = FLOAT32_SIZE;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( 'EXRLoader.parse: unsupported pixelType ' + EXRDecoder.type + ' for ' + EXRHeader.compression + '.' );\n\n\t\t\t}\n\n\t\t\tEXRDecoder.blockCount = ( EXRHeader.dataWindow.yMax + 1 ) / EXRDecoder.scanlineBlockSize;\n\n\t\t\tfor ( let i = 0; i < EXRDecoder.blockCount; i ++ )\n\t\t\t\tparseInt64( dataView, offset ); // scanlineOffset\n\n\t\t\t// we should be passed the scanline offset table, ready to start reading pixel data.\n\n\t\t\t// RGB images will be converted to RGBA format, preventing software emulation in select devices.\n\t\t\tEXRDecoder.outputChannels = ( ( EXRDecoder.channels == 3 ) ? 4 : EXRDecoder.channels );\n\t\t\tconst size = EXRDecoder.width * EXRDecoder.height * EXRDecoder.outputChannels;\n\n\t\t\tswitch ( outputType ) {\n\n\t\t\t\tcase three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n\t\t\t\t\tEXRDecoder.byteArray = new Float32Array( size );\n\n\t\t\t\t\t// Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\n\t\t\t\t\tif ( EXRDecoder.channels < EXRDecoder.outputChannels )\n\t\t\t\t\t\tEXRDecoder.byteArray.fill( 1, 0, size );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n\t\t\t\t\tEXRDecoder.byteArray = new Uint16Array( size );\n\n\t\t\t\t\tif ( EXRDecoder.channels < EXRDecoder.outputChannels )\n\t\t\t\t\t\tEXRDecoder.byteArray.fill( 0x3C00, 0, size ); // Uint16Array holds half float data, 0x3C00 is 1\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.error( 'THREE.EXRLoader: unsupported type: ', outputType );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tEXRDecoder.bytesPerLine = EXRDecoder.width * EXRDecoder.inputSize * EXRDecoder.channels;\n\n\t\t\tif ( EXRDecoder.outputChannels == 4 ) {\n\n\t\t\t\tEXRDecoder.format = three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat;\n\t\t\t\tEXRDecoder.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace;\n\n\t\t\t} else {\n\n\t\t\t\tEXRDecoder.format = three__WEBPACK_IMPORTED_MODULE_0__.RedFormat;\n\t\t\t\tEXRDecoder.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.NoColorSpace;\n\n\t\t\t}\n\n\t\t\treturn EXRDecoder;\n\n\t\t}\n\n\t\t// start parsing file [START]\n\n\t\tconst bufferDataView = new DataView( buffer );\n\t\tconst uInt8Array = new Uint8Array( buffer );\n\t\tconst offset = { value: 0 };\n\n\t\t// get header information and validate format.\n\t\tconst EXRHeader = parseHeader( bufferDataView, buffer, offset );\n\n\t\t// get input compression information and prepare decoding.\n\t\tconst EXRDecoder = setupDecoder( EXRHeader, bufferDataView, uInt8Array, offset, this.type );\n\n\t\tconst tmpOffset = { value: 0 };\n\t\tconst channelOffsets = { R: 0, G: 1, B: 2, A: 3, Y: 0 };\n\n\t\tfor ( let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx ++ ) {\n\n\t\t\tconst line = parseUint32( bufferDataView, offset ); // line_no\n\t\t\tEXRDecoder.size = parseUint32( bufferDataView, offset ); // data_len\n\t\t\tEXRDecoder.lines = ( ( line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ) ? ( EXRDecoder.height - line ) : EXRDecoder.scanlineBlockSize );\n\n\t\t\tconst isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;\n\t\t\tconst viewer = isCompressed ? EXRDecoder.uncompress( EXRDecoder ) : uncompressRAW( EXRDecoder );\n\n\t\t\toffset.value += EXRDecoder.size;\n\n\t\t\tfor ( let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y ++ ) {\n\n\t\t\t\tconst true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;\n\t\t\t\tif ( true_y >= EXRDecoder.height ) break;\n\n\t\t\t\tfor ( let channelID = 0; channelID < EXRDecoder.channels; channelID ++ ) {\n\n\t\t\t\t\tconst cOff = channelOffsets[ EXRHeader.channels[ channelID ].name ];\n\n\t\t\t\t\tfor ( let x = 0; x < EXRDecoder.width; x ++ ) {\n\n\t\t\t\t\t\ttmpOffset.value = ( line_y * ( EXRDecoder.channels * EXRDecoder.width ) + channelID * EXRDecoder.width + x ) * EXRDecoder.inputSize;\n\t\t\t\t\t\tconst outIndex = ( EXRDecoder.height - 1 - true_y ) * ( EXRDecoder.width * EXRDecoder.outputChannels ) + x * EXRDecoder.outputChannels + cOff;\n\t\t\t\t\t\tEXRDecoder.byteArray[ outIndex ] = EXRDecoder.getter( viewer, tmpOffset );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\theader: EXRHeader,\n\t\t\twidth: EXRDecoder.width,\n\t\t\theight: EXRDecoder.height,\n\t\t\tdata: EXRDecoder.byteArray,\n\t\t\tformat: EXRDecoder.format,\n\t\t\tcolorSpace: EXRDecoder.colorSpace,\n\t\t\ttype: this.type,\n\t\t};\n\n\t}\n\n\tsetDataType( value ) {\n\n\t\tthis.type = value;\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tfunction onLoadCallback( texture, texData ) {\n\n\t\t\ttexture.colorSpace = texData.colorSpace;\n\t\t\ttexture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n\t\t\ttexture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n\t\t\ttexture.generateMipmaps = false;\n\t\t\ttexture.flipY = false;\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}\n\n\t\treturn super.load( url, onLoadCallback, onProgress, onError );\n\n\t}\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvRVhSTG9hZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQVVlO0FBQ29DOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Qsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsd0JBQXdCLG9EQUFpQjs7QUFFekM7O0FBRUE7O0FBRUEsY0FBYyxnREFBYTs7QUFFM0I7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUIsMEJBQTBCOztBQUUxQixnREFBZ0Q7QUFDaEQsd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0Isa0JBQWtCOztBQUV0Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IsaUJBQWlCOztBQUVyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSwwQkFBMEI7O0FBRTFCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCLG9CQUFvQixpQkFBaUI7O0FBRXJDOztBQUVBLHFCQUFxQixPQUFPOztBQUU1QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLGlCQUFpQjs7QUFFckM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxVQUFVOztBQUVyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsV0FBVyxVQUFVOztBQUVyQjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLGdCQUFnQjs7QUFFdkM7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBLDZDQUE2QyxPQUFPOztBQUVwRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDBCQUEwQjs7QUFFMUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDBCQUEwQjs7QUFFMUI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx5QkFBeUI7O0FBRXpCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxVQUFVOztBQUV0QjtBQUNBOztBQUVBLGFBQWEsVUFBVTs7QUFFdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsUUFBUTs7QUFFUjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSxVQUFVOztBQUV2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsWUFBWTs7QUFFL0I7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztB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OztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsVUFBVSw0Q0FBUzs7QUFFbkI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZOztBQUVaOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZOztBQUVaOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBLEtBQUs7O0FBRUw7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSxLQUFLOztBQUVMOztBQUVBLEtBQUs7O0FBRUw7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSxLQUFLOztBQUVMOztBQUVBLEtBQUs7O0FBRUw7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSxLQUFLOztBQUVMOztBQUVBLEtBQUs7O0FBRUw7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzREFBc0Q7O0FBRXREOztBQUVBOztBQUVBOztBQUVBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQjs7QUFFckI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0ZBQWdGLGNBQWM7O0FBRTlGLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUNBQW1DOztBQUVuQztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1REFBb0I7QUFDcEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLFVBQVUsNENBQVM7QUFDbkI7QUFDQTtBQUNBOztBQUVBLFVBQVUsZ0RBQWE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQSxVQUFVLDRDQUFTO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGdEQUFhO0FBQ3ZCO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IsMkJBQTJCO0FBQy9DLG9DQUFvQzs7QUFFcEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVMsNENBQVM7QUFDbEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVMsZ0RBQWE7QUFDdEI7O0FBRUE7QUFDQSxvREFBb0Q7O0FBRXBEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3QkFBd0IsNkNBQVU7QUFDbEMsNEJBQTRCLHVEQUFvQjs7QUFFaEQsS0FBSzs7QUFFTCx3QkFBd0IsNENBQVM7QUFDakMsNEJBQTRCLCtDQUFZOztBQUV4Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCLDJCQUEyQjs7QUFFM0Isa0NBQWtDLHFFQUFxRTs7QUFFdkcsdURBQXVEO0FBQ3ZELDREQUE0RDtBQUM1RDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHlCQUF5Qix1Q0FBdUM7O0FBRWhFO0FBQ0E7O0FBRUEsNkJBQTZCLGlDQUFpQzs7QUFFOUQ7O0FBRUEsc0JBQXNCLHNCQUFzQjs7QUFFNUM7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsdUJBQXVCLCtDQUFZO0FBQ25DLHVCQUF1QiwrQ0FBWTtBQUNuQztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVxQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvRVhSTG9hZGVyLmpzPzk4NzQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcblx0RGF0YVRleHR1cmVMb2FkZXIsXG5cdERhdGFVdGlscyxcblx0RmxvYXRUeXBlLFxuXHRIYWxmRmxvYXRUeXBlLFxuXHROb0NvbG9yU3BhY2UsXG5cdExpbmVhckZpbHRlcixcblx0TGluZWFyU1JHQkNvbG9yU3BhY2UsXG5cdFJlZEZvcm1hdCxcblx0UkdCQUZvcm1hdFxufSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgKiBhcyBmZmxhdGUgZnJvbSAnLi4vbGlicy9mZmxhdGUubW9kdWxlLmpzJztcblxuLyoqXG4gKiBPcGVuRVhSIGxvYWRlciBjdXJyZW50bHkgc3VwcG9ydHMgdW5jb21wcmVzc2VkLCBaSVAoUyksIFJMRSwgUElaIGFuZCBEV0EvQiBjb21wcmVzc2lvbi5cbiAqIFN1cHBvcnRzIHJlYWRpbmcgYXMgVW5zaWduZWRCeXRlLCBIYWxmRmxvYXQgYW5kIEZsb2F0IHR5cGUgZGF0YSB0ZXh0dXJlLlxuICpcbiAqIFJlZmVycmVkIHRvIHRoZSBvcmlnaW5hbCBJbmR1c3RyaWFsIExpZ2h0ICYgTWFnaWMgT3BlbkVYUiBpbXBsZW1lbnRhdGlvbiBhbmQgdGhlIFRpbnlFWFIgLyBTeW95byBGdWppdGFcbiAqIGltcGxlbWVudGF0aW9uLCBzbyBJIGhhdmUgcHJlc2VydmVkIHRoZWlyIGNvcHlyaWdodCBub3RpY2VzLlxuICovXG5cbi8vIC8qXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTQgLSAyMDE3LCBTeW95byBGdWppdGFcbi8vIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbi8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuLy8gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4vLyAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuLy8gICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbi8vICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbi8vICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4vLyAgICAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBTeW95byBGdWppdGEgbm9yIHRoZVxuLy8gICAgICAgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHNcbi8vICAgICAgIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbi8vIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4vLyBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4vLyBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbi8vIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4vLyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4vLyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbi8vIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4vLyAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuLy8gU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4vLyAqL1xuXG4vLyAvLyBUaW55RVhSIGNvbnRhaW5zIHNvbWUgT3BlbkVYUiBjb2RlLCB3aGljaCBpcyBsaWNlbnNlZCB1bmRlciAtLS0tLS0tLS0tLS1cblxuLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyAvL1xuLy8gLy8gQ29weXJpZ2h0IChjKSAyMDAyLCBJbmR1c3RyaWFsIExpZ2h0ICYgTWFnaWMsIGEgZGl2aXNpb24gb2YgTHVjYXNcbi8vIC8vIERpZ2l0YWwgTHRkLiBMTENcbi8vIC8vXG4vLyAvLyBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gLy9cbi8vIC8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuLy8gLy8gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuLy8gLy8gbWV0OlxuLy8gLy8gKiAgICAgICBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gLy8gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuLy8gLy8gKiAgICAgICBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4vLyAvLyBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyXG4vLyAvLyBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4vLyAvLyBkaXN0cmlidXRpb24uXG4vLyAvLyAqICAgICAgIE5laXRoZXIgdGhlIG5hbWUgb2YgSW5kdXN0cmlhbCBMaWdodCAmIE1hZ2ljIG5vciB0aGUgbmFtZXMgb2Zcbi8vIC8vIGl0cyBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWRcbi8vIC8vIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbi8vIC8vXG4vLyAvLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4vLyAvLyBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4vLyAvLyBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1Jcbi8vIC8vIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4vLyAvLyBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbi8vIC8vIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIC8vIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuLy8gLy8gREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4vLyAvLyBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4vLyAvLyAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0Vcbi8vIC8vIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4vLyAvL1xuLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vIC8vIEVuZCBvZiBPcGVuRVhSIGxpY2Vuc2UgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jbGFzcyBFWFJMb2FkZXIgZXh0ZW5kcyBEYXRhVGV4dHVyZUxvYWRlciB7XG5cblx0Y29uc3RydWN0b3IoIG1hbmFnZXIgKSB7XG5cblx0XHRzdXBlciggbWFuYWdlciApO1xuXG5cdFx0dGhpcy50eXBlID0gSGFsZkZsb2F0VHlwZTtcblxuXHR9XG5cblx0cGFyc2UoIGJ1ZmZlciApIHtcblxuXHRcdGNvbnN0IFVTSE9SVF9SQU5HRSA9ICggMSA8PCAxNiApO1xuXHRcdGNvbnN0IEJJVE1BUF9TSVpFID0gKCBVU0hPUlRfUkFOR0UgPj4gMyApO1xuXG5cdFx0Y29uc3QgSFVGX0VOQ0JJVFMgPSAxNjsgLy8gbGl0ZXJhbCAodmFsdWUpIGJpdCBsZW5ndGhcblx0XHRjb25zdCBIVUZfREVDQklUUyA9IDE0OyAvLyBkZWNvZGluZyBiaXQgc2l6ZSAoPj0gOClcblxuXHRcdGNvbnN0IEhVRl9FTkNTSVpFID0gKCAxIDw8IEhVRl9FTkNCSVRTICkgKyAxOyAvLyBlbmNvZGluZyB0YWJsZSBzaXplXG5cdFx0Y29uc3QgSFVGX0RFQ1NJWkUgPSAxIDw8IEhVRl9ERUNCSVRTOyAvLyBkZWNvZGluZyB0YWJsZSBzaXplXG5cdFx0Y29uc3QgSFVGX0RFQ01BU0sgPSBIVUZfREVDU0laRSAtIDE7XG5cblx0XHRjb25zdCBOQklUUyA9IDE2O1xuXHRcdGNvbnN0IEFfT0ZGU0VUID0gMSA8PCAoIE5CSVRTIC0gMSApO1xuXHRcdGNvbnN0IE1PRF9NQVNLID0gKCAxIDw8IE5CSVRTICkgLSAxO1xuXG5cdFx0Y29uc3QgU0hPUlRfWkVST0NPREVfUlVOID0gNTk7XG5cdFx0Y29uc3QgTE9OR19aRVJPQ09ERV9SVU4gPSA2Mztcblx0XHRjb25zdCBTSE9SVEVTVF9MT05HX1JVTiA9IDIgKyBMT05HX1pFUk9DT0RFX1JVTiAtIFNIT1JUX1pFUk9DT0RFX1JVTjtcblxuXHRcdGNvbnN0IFVMT05HX1NJWkUgPSA4O1xuXHRcdGNvbnN0IEZMT0FUMzJfU0laRSA9IDQ7XG5cdFx0Y29uc3QgSU5UMzJfU0laRSA9IDQ7XG5cdFx0Y29uc3QgSU5UMTZfU0laRSA9IDI7XG5cdFx0Y29uc3QgSU5UOF9TSVpFID0gMTtcblxuXHRcdGNvbnN0IFNUQVRJQ19IVUZGTUFOID0gMDtcblx0XHRjb25zdCBERUZMQVRFID0gMTtcblxuXHRcdGNvbnN0IFVOS05PV04gPSAwO1xuXHRcdGNvbnN0IExPU1NZX0RDVCA9IDE7XG5cdFx0Y29uc3QgUkxFID0gMjtcblxuXHRcdGNvbnN0IGxvZ0Jhc2UgPSBNYXRoLnBvdyggMi43MTgyODE4LCAyLjIgKTtcblxuXHRcdGZ1bmN0aW9uIHJldmVyc2VMdXRGcm9tQml0bWFwKCBiaXRtYXAsIGx1dCApIHtcblxuXHRcdFx0bGV0IGsgPSAwO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBVU0hPUlRfUkFOR0U7ICsrIGkgKSB7XG5cblx0XHRcdFx0aWYgKCAoIGkgPT0gMCApIHx8ICggYml0bWFwWyBpID4+IDMgXSAmICggMSA8PCAoIGkgJiA3ICkgKSApICkge1xuXG5cdFx0XHRcdFx0bHV0WyBrICsrIF0gPSBpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBuID0gayAtIDE7XG5cblx0XHRcdHdoaWxlICggayA8IFVTSE9SVF9SQU5HRSApIGx1dFsgayArKyBdID0gMDtcblxuXHRcdFx0cmV0dXJuIG47XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBodWZDbGVhckRlY1RhYmxlKCBoZGVjICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBIVUZfREVDU0laRTsgaSArKyApIHtcblxuXHRcdFx0XHRoZGVjWyBpIF0gPSB7fTtcblx0XHRcdFx0aGRlY1sgaSBdLmxlbiA9IDA7XG5cdFx0XHRcdGhkZWNbIGkgXS5saXQgPSAwO1xuXHRcdFx0XHRoZGVjWyBpIF0ucCA9IG51bGw7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGNvbnN0IGdldEJpdHNSZXR1cm4gPSB7IGw6IDAsIGM6IDAsIGxjOiAwIH07XG5cblx0XHRmdW5jdGlvbiBnZXRCaXRzKCBuQml0cywgYywgbGMsIHVJbnQ4QXJyYXksIGluT2Zmc2V0ICkge1xuXG5cdFx0XHR3aGlsZSAoIGxjIDwgbkJpdHMgKSB7XG5cblx0XHRcdFx0YyA9ICggYyA8PCA4ICkgfCBwYXJzZVVpbnQ4QXJyYXkoIHVJbnQ4QXJyYXksIGluT2Zmc2V0ICk7XG5cdFx0XHRcdGxjICs9IDg7XG5cblx0XHRcdH1cblxuXHRcdFx0bGMgLT0gbkJpdHM7XG5cblx0XHRcdGdldEJpdHNSZXR1cm4ubCA9ICggYyA+PiBsYyApICYgKCAoIDEgPDwgbkJpdHMgKSAtIDEgKTtcblx0XHRcdGdldEJpdHNSZXR1cm4uYyA9IGM7XG5cdFx0XHRnZXRCaXRzUmV0dXJuLmxjID0gbGM7XG5cblx0XHR9XG5cblx0XHRjb25zdCBodWZUYWJsZUJ1ZmZlciA9IG5ldyBBcnJheSggNTkgKTtcblxuXHRcdGZ1bmN0aW9uIGh1ZkNhbm9uaWNhbENvZGVUYWJsZSggaGNvZGUgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8PSA1ODsgKysgaSApIGh1ZlRhYmxlQnVmZmVyWyBpIF0gPSAwO1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgSFVGX0VOQ1NJWkU7ICsrIGkgKSBodWZUYWJsZUJ1ZmZlclsgaGNvZGVbIGkgXSBdICs9IDE7XG5cblx0XHRcdGxldCBjID0gMDtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSA1ODsgaSA+IDA7IC0tIGkgKSB7XG5cblx0XHRcdFx0Y29uc3QgbmMgPSAoICggYyArIGh1ZlRhYmxlQnVmZmVyWyBpIF0gKSA+PiAxICk7XG5cdFx0XHRcdGh1ZlRhYmxlQnVmZmVyWyBpIF0gPSBjO1xuXHRcdFx0XHRjID0gbmM7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgSFVGX0VOQ1NJWkU7ICsrIGkgKSB7XG5cblx0XHRcdFx0Y29uc3QgbCA9IGhjb2RlWyBpIF07XG5cdFx0XHRcdGlmICggbCA+IDAgKSBoY29kZVsgaSBdID0gbCB8ICggaHVmVGFibGVCdWZmZXJbIGwgXSArKyA8PCA2ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGh1ZlVucGFja0VuY1RhYmxlKCB1SW50OEFycmF5LCBpbk9mZnNldCwgbmksIGltLCBpTSwgaGNvZGUgKSB7XG5cblx0XHRcdGNvbnN0IHAgPSBpbk9mZnNldDtcblx0XHRcdGxldCBjID0gMDtcblx0XHRcdGxldCBsYyA9IDA7XG5cblx0XHRcdGZvciAoIDsgaW0gPD0gaU07IGltICsrICkge1xuXG5cdFx0XHRcdGlmICggcC52YWx1ZSAtIGluT2Zmc2V0LnZhbHVlID4gbmkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdFx0Z2V0Qml0cyggNiwgYywgbGMsIHVJbnQ4QXJyYXksIHAgKTtcblxuXHRcdFx0XHRjb25zdCBsID0gZ2V0Qml0c1JldHVybi5sO1xuXHRcdFx0XHRjID0gZ2V0Qml0c1JldHVybi5jO1xuXHRcdFx0XHRsYyA9IGdldEJpdHNSZXR1cm4ubGM7XG5cblx0XHRcdFx0aGNvZGVbIGltIF0gPSBsO1xuXG5cdFx0XHRcdGlmICggbCA9PSBMT05HX1pFUk9DT0RFX1JVTiApIHtcblxuXHRcdFx0XHRcdGlmICggcC52YWx1ZSAtIGluT2Zmc2V0LnZhbHVlID4gbmkgKSB7XG5cblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1NvbWV0aGluZyB3cm9uZyB3aXRoIGh1ZlVucGFja0VuY1RhYmxlJyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Z2V0Qml0cyggOCwgYywgbGMsIHVJbnQ4QXJyYXksIHAgKTtcblxuXHRcdFx0XHRcdGxldCB6ZXJ1biA9IGdldEJpdHNSZXR1cm4ubCArIFNIT1JURVNUX0xPTkdfUlVOO1xuXHRcdFx0XHRcdGMgPSBnZXRCaXRzUmV0dXJuLmM7XG5cdFx0XHRcdFx0bGMgPSBnZXRCaXRzUmV0dXJuLmxjO1xuXG5cdFx0XHRcdFx0aWYgKCBpbSArIHplcnVuID4gaU0gKyAxICkge1xuXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdTb21ldGhpbmcgd3Jvbmcgd2l0aCBodWZVbnBhY2tFbmNUYWJsZScgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHdoaWxlICggemVydW4gLS0gKSBoY29kZVsgaW0gKysgXSA9IDA7XG5cblx0XHRcdFx0XHRpbSAtLTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBsID49IFNIT1JUX1pFUk9DT0RFX1JVTiApIHtcblxuXHRcdFx0XHRcdGxldCB6ZXJ1biA9IGwgLSBTSE9SVF9aRVJPQ09ERV9SVU4gKyAyO1xuXG5cdFx0XHRcdFx0aWYgKCBpbSArIHplcnVuID4gaU0gKyAxICkge1xuXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdTb21ldGhpbmcgd3Jvbmcgd2l0aCBodWZVbnBhY2tFbmNUYWJsZScgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHdoaWxlICggemVydW4gLS0gKSBoY29kZVsgaW0gKysgXSA9IDA7XG5cblx0XHRcdFx0XHRpbSAtLTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aHVmQ2Fub25pY2FsQ29kZVRhYmxlKCBoY29kZSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaHVmTGVuZ3RoKCBjb2RlICkge1xuXG5cdFx0XHRyZXR1cm4gY29kZSAmIDYzO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaHVmQ29kZSggY29kZSApIHtcblxuXHRcdFx0cmV0dXJuIGNvZGUgPj4gNjtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGh1ZkJ1aWxkRGVjVGFibGUoIGhjb2RlLCBpbSwgaU0sIGhkZWNvZCApIHtcblxuXHRcdFx0Zm9yICggOyBpbSA8PSBpTTsgaW0gKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYyA9IGh1ZkNvZGUoIGhjb2RlWyBpbSBdICk7XG5cdFx0XHRcdGNvbnN0IGwgPSBodWZMZW5ndGgoIGhjb2RlWyBpbSBdICk7XG5cblx0XHRcdFx0aWYgKCBjID4+IGwgKSB7XG5cblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdJbnZhbGlkIHRhYmxlIGVudHJ5JyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGwgPiBIVUZfREVDQklUUyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHBsID0gaGRlY29kWyAoIGMgPj4gKCBsIC0gSFVGX0RFQ0JJVFMgKSApIF07XG5cblx0XHRcdFx0XHRpZiAoIHBsLmxlbiApIHtcblxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnSW52YWxpZCB0YWJsZSBlbnRyeScgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHBsLmxpdCArKztcblxuXHRcdFx0XHRcdGlmICggcGwucCApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgcCA9IHBsLnA7XG5cdFx0XHRcdFx0XHRwbC5wID0gbmV3IEFycmF5KCBwbC5saXQgKTtcblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgcGwubGl0IC0gMTsgKysgaSApIHtcblxuXHRcdFx0XHRcdFx0XHRwbC5wWyBpIF0gPSBwWyBpIF07XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHBsLnAgPSBuZXcgQXJyYXkoIDEgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHBsLnBbIHBsLmxpdCAtIDEgXSA9IGltO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGwgKSB7XG5cblx0XHRcdFx0XHRsZXQgcGxPZmZzZXQgPSAwO1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAxIDw8ICggSFVGX0RFQ0JJVFMgLSBsICk7IGkgPiAwOyBpIC0tICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBwbCA9IGhkZWNvZFsgKCBjIDw8ICggSFVGX0RFQ0JJVFMgLSBsICkgKSArIHBsT2Zmc2V0IF07XG5cblx0XHRcdFx0XHRcdGlmICggcGwubGVuIHx8IHBsLnAgKSB7XG5cblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnSW52YWxpZCB0YWJsZSBlbnRyeScgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRwbC5sZW4gPSBsO1xuXHRcdFx0XHRcdFx0cGwubGl0ID0gaW07XG5cblx0XHRcdFx0XHRcdHBsT2Zmc2V0ICsrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGdldENoYXJSZXR1cm4gPSB7IGM6IDAsIGxjOiAwIH07XG5cblx0XHRmdW5jdGlvbiBnZXRDaGFyKCBjLCBsYywgdUludDhBcnJheSwgaW5PZmZzZXQgKSB7XG5cblx0XHRcdGMgPSAoIGMgPDwgOCApIHwgcGFyc2VVaW50OEFycmF5KCB1SW50OEFycmF5LCBpbk9mZnNldCApO1xuXHRcdFx0bGMgKz0gODtcblxuXHRcdFx0Z2V0Q2hhclJldHVybi5jID0gYztcblx0XHRcdGdldENoYXJSZXR1cm4ubGMgPSBsYztcblxuXHRcdH1cblxuXHRcdGNvbnN0IGdldENvZGVSZXR1cm4gPSB7IGM6IDAsIGxjOiAwIH07XG5cblx0XHRmdW5jdGlvbiBnZXRDb2RlKCBwbywgcmxjLCBjLCBsYywgdUludDhBcnJheSwgaW5PZmZzZXQsIG91dEJ1ZmZlciwgb3V0QnVmZmVyT2Zmc2V0LCBvdXRCdWZmZXJFbmRPZmZzZXQgKSB7XG5cblx0XHRcdGlmICggcG8gPT0gcmxjICkge1xuXG5cdFx0XHRcdGlmICggbGMgPCA4ICkge1xuXG5cdFx0XHRcdFx0Z2V0Q2hhciggYywgbGMsIHVJbnQ4QXJyYXksIGluT2Zmc2V0ICk7XG5cdFx0XHRcdFx0YyA9IGdldENoYXJSZXR1cm4uYztcblx0XHRcdFx0XHRsYyA9IGdldENoYXJSZXR1cm4ubGM7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxjIC09IDg7XG5cblx0XHRcdFx0bGV0IGNzID0gKCBjID4+IGxjICk7XG5cdFx0XHRcdGNzID0gbmV3IFVpbnQ4QXJyYXkoIFsgY3MgXSApWyAwIF07XG5cblx0XHRcdFx0aWYgKCBvdXRCdWZmZXJPZmZzZXQudmFsdWUgKyBjcyA+IG91dEJ1ZmZlckVuZE9mZnNldCApIHtcblxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgcyA9IG91dEJ1ZmZlclsgb3V0QnVmZmVyT2Zmc2V0LnZhbHVlIC0gMSBdO1xuXG5cdFx0XHRcdHdoaWxlICggY3MgLS0gPiAwICkge1xuXG5cdFx0XHRcdFx0b3V0QnVmZmVyWyBvdXRCdWZmZXJPZmZzZXQudmFsdWUgKysgXSA9IHM7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBvdXRCdWZmZXJPZmZzZXQudmFsdWUgPCBvdXRCdWZmZXJFbmRPZmZzZXQgKSB7XG5cblx0XHRcdFx0b3V0QnVmZmVyWyBvdXRCdWZmZXJPZmZzZXQudmFsdWUgKysgXSA9IHBvO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRnZXRDb2RlUmV0dXJuLmMgPSBjO1xuXHRcdFx0Z2V0Q29kZVJldHVybi5sYyA9IGxjO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gVUludDE2KCB2YWx1ZSApIHtcblxuXHRcdFx0cmV0dXJuICggdmFsdWUgJiAweEZGRkYgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIEludDE2KCB2YWx1ZSApIHtcblxuXHRcdFx0Y29uc3QgcmVmID0gVUludDE2KCB2YWx1ZSApO1xuXHRcdFx0cmV0dXJuICggcmVmID4gMHg3RkZGICkgPyByZWYgLSAweDEwMDAwIDogcmVmO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgd2RlYzE0UmV0dXJuID0geyBhOiAwLCBiOiAwIH07XG5cblx0XHRmdW5jdGlvbiB3ZGVjMTQoIGwsIGggKSB7XG5cblx0XHRcdGNvbnN0IGxzID0gSW50MTYoIGwgKTtcblx0XHRcdGNvbnN0IGhzID0gSW50MTYoIGggKTtcblxuXHRcdFx0Y29uc3QgaGkgPSBocztcblx0XHRcdGNvbnN0IGFpID0gbHMgKyAoIGhpICYgMSApICsgKCBoaSA+PiAxICk7XG5cblx0XHRcdGNvbnN0IGFzID0gYWk7XG5cdFx0XHRjb25zdCBicyA9IGFpIC0gaGk7XG5cblx0XHRcdHdkZWMxNFJldHVybi5hID0gYXM7XG5cdFx0XHR3ZGVjMTRSZXR1cm4uYiA9IGJzO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gd2RlYzE2KCBsLCBoICkge1xuXG5cdFx0XHRjb25zdCBtID0gVUludDE2KCBsICk7XG5cdFx0XHRjb25zdCBkID0gVUludDE2KCBoICk7XG5cblx0XHRcdGNvbnN0IGJiID0gKCBtIC0gKCBkID4+IDEgKSApICYgTU9EX01BU0s7XG5cdFx0XHRjb25zdCBhYSA9ICggZCArIGJiIC0gQV9PRkZTRVQgKSAmIE1PRF9NQVNLO1xuXG5cdFx0XHR3ZGVjMTRSZXR1cm4uYSA9IGFhO1xuXHRcdFx0d2RlYzE0UmV0dXJuLmIgPSBiYjtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHdhdjJEZWNvZGUoIGJ1ZmZlciwgaiwgbngsIG94LCBueSwgb3ksIG14ICkge1xuXG5cdFx0XHRjb25zdCB3MTQgPSBteCA8ICggMSA8PCAxNCApO1xuXHRcdFx0Y29uc3QgbiA9ICggbnggPiBueSApID8gbnkgOiBueDtcblx0XHRcdGxldCBwID0gMTtcblx0XHRcdGxldCBwMjtcblx0XHRcdGxldCBweTtcblxuXHRcdFx0d2hpbGUgKCBwIDw9IG4gKSBwIDw8PSAxO1xuXG5cdFx0XHRwID4+PSAxO1xuXHRcdFx0cDIgPSBwO1xuXHRcdFx0cCA+Pj0gMTtcblxuXHRcdFx0d2hpbGUgKCBwID49IDEgKSB7XG5cblx0XHRcdFx0cHkgPSAwO1xuXHRcdFx0XHRjb25zdCBleSA9IHB5ICsgb3kgKiAoIG55IC0gcDIgKTtcblx0XHRcdFx0Y29uc3Qgb3kxID0gb3kgKiBwO1xuXHRcdFx0XHRjb25zdCBveTIgPSBveSAqIHAyO1xuXHRcdFx0XHRjb25zdCBveDEgPSBveCAqIHA7XG5cdFx0XHRcdGNvbnN0IG94MiA9IG94ICogcDI7XG5cdFx0XHRcdGxldCBpMDAsIGkwMSwgaTEwLCBpMTE7XG5cblx0XHRcdFx0Zm9yICggOyBweSA8PSBleTsgcHkgKz0gb3kyICkge1xuXG5cdFx0XHRcdFx0bGV0IHB4ID0gcHk7XG5cdFx0XHRcdFx0Y29uc3QgZXggPSBweSArIG94ICogKCBueCAtIHAyICk7XG5cblx0XHRcdFx0XHRmb3IgKCA7IHB4IDw9IGV4OyBweCArPSBveDIgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHAwMSA9IHB4ICsgb3gxO1xuXHRcdFx0XHRcdFx0Y29uc3QgcDEwID0gcHggKyBveTE7XG5cdFx0XHRcdFx0XHRjb25zdCBwMTEgPSBwMTAgKyBveDE7XG5cblx0XHRcdFx0XHRcdGlmICggdzE0ICkge1xuXG5cdFx0XHRcdFx0XHRcdHdkZWMxNCggYnVmZmVyWyBweCArIGogXSwgYnVmZmVyWyBwMTAgKyBqIF0gKTtcblxuXHRcdFx0XHRcdFx0XHRpMDAgPSB3ZGVjMTRSZXR1cm4uYTtcblx0XHRcdFx0XHRcdFx0aTEwID0gd2RlYzE0UmV0dXJuLmI7XG5cblx0XHRcdFx0XHRcdFx0d2RlYzE0KCBidWZmZXJbIHAwMSArIGogXSwgYnVmZmVyWyBwMTEgKyBqIF0gKTtcblxuXHRcdFx0XHRcdFx0XHRpMDEgPSB3ZGVjMTRSZXR1cm4uYTtcblx0XHRcdFx0XHRcdFx0aTExID0gd2RlYzE0UmV0dXJuLmI7XG5cblx0XHRcdFx0XHRcdFx0d2RlYzE0KCBpMDAsIGkwMSApO1xuXG5cdFx0XHRcdFx0XHRcdGJ1ZmZlclsgcHggKyBqIF0gPSB3ZGVjMTRSZXR1cm4uYTtcblx0XHRcdFx0XHRcdFx0YnVmZmVyWyBwMDEgKyBqIF0gPSB3ZGVjMTRSZXR1cm4uYjtcblxuXHRcdFx0XHRcdFx0XHR3ZGVjMTQoIGkxMCwgaTExICk7XG5cblx0XHRcdFx0XHRcdFx0YnVmZmVyWyBwMTAgKyBqIF0gPSB3ZGVjMTRSZXR1cm4uYTtcblx0XHRcdFx0XHRcdFx0YnVmZmVyWyBwMTEgKyBqIF0gPSB3ZGVjMTRSZXR1cm4uYjtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHR3ZGVjMTYoIGJ1ZmZlclsgcHggKyBqIF0sIGJ1ZmZlclsgcDEwICsgaiBdICk7XG5cblx0XHRcdFx0XHRcdFx0aTAwID0gd2RlYzE0UmV0dXJuLmE7XG5cdFx0XHRcdFx0XHRcdGkxMCA9IHdkZWMxNFJldHVybi5iO1xuXG5cdFx0XHRcdFx0XHRcdHdkZWMxNiggYnVmZmVyWyBwMDEgKyBqIF0sIGJ1ZmZlclsgcDExICsgaiBdICk7XG5cblx0XHRcdFx0XHRcdFx0aTAxID0gd2RlYzE0UmV0dXJuLmE7XG5cdFx0XHRcdFx0XHRcdGkxMSA9IHdkZWMxNFJldHVybi5iO1xuXG5cdFx0XHRcdFx0XHRcdHdkZWMxNiggaTAwLCBpMDEgKTtcblxuXHRcdFx0XHRcdFx0XHRidWZmZXJbIHB4ICsgaiBdID0gd2RlYzE0UmV0dXJuLmE7XG5cdFx0XHRcdFx0XHRcdGJ1ZmZlclsgcDAxICsgaiBdID0gd2RlYzE0UmV0dXJuLmI7XG5cblx0XHRcdFx0XHRcdFx0d2RlYzE2KCBpMTAsIGkxMSApO1xuXG5cdFx0XHRcdFx0XHRcdGJ1ZmZlclsgcDEwICsgaiBdID0gd2RlYzE0UmV0dXJuLmE7XG5cdFx0XHRcdFx0XHRcdGJ1ZmZlclsgcDExICsgaiBdID0gd2RlYzE0UmV0dXJuLmI7XG5cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBueCAmIHAgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHAxMCA9IHB4ICsgb3kxO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHcxNCApXG5cdFx0XHRcdFx0XHRcdHdkZWMxNCggYnVmZmVyWyBweCArIGogXSwgYnVmZmVyWyBwMTAgKyBqIF0gKTtcblx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0d2RlYzE2KCBidWZmZXJbIHB4ICsgaiBdLCBidWZmZXJbIHAxMCArIGogXSApO1xuXG5cdFx0XHRcdFx0XHRpMDAgPSB3ZGVjMTRSZXR1cm4uYTtcblx0XHRcdFx0XHRcdGJ1ZmZlclsgcDEwICsgaiBdID0gd2RlYzE0UmV0dXJuLmI7XG5cblx0XHRcdFx0XHRcdGJ1ZmZlclsgcHggKyBqIF0gPSBpMDA7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbnkgJiBwICkge1xuXG5cdFx0XHRcdFx0bGV0IHB4ID0gcHk7XG5cdFx0XHRcdFx0Y29uc3QgZXggPSBweSArIG94ICogKCBueCAtIHAyICk7XG5cblx0XHRcdFx0XHRmb3IgKCA7IHB4IDw9IGV4OyBweCArPSBveDIgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHAwMSA9IHB4ICsgb3gxO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHcxNCApXG5cdFx0XHRcdFx0XHRcdHdkZWMxNCggYnVmZmVyWyBweCArIGogXSwgYnVmZmVyWyBwMDEgKyBqIF0gKTtcblx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0d2RlYzE2KCBidWZmZXJbIHB4ICsgaiBdLCBidWZmZXJbIHAwMSArIGogXSApO1xuXG5cdFx0XHRcdFx0XHRpMDAgPSB3ZGVjMTRSZXR1cm4uYTtcblx0XHRcdFx0XHRcdGJ1ZmZlclsgcDAxICsgaiBdID0gd2RlYzE0UmV0dXJuLmI7XG5cblx0XHRcdFx0XHRcdGJ1ZmZlclsgcHggKyBqIF0gPSBpMDA7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHAyID0gcDtcblx0XHRcdFx0cCA+Pj0gMTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcHk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBodWZEZWNvZGUoIGVuY29kaW5nVGFibGUsIGRlY29kaW5nVGFibGUsIHVJbnQ4QXJyYXksIGluT2Zmc2V0LCBuaSwgcmxjLCBubywgb3V0QnVmZmVyLCBvdXRPZmZzZXQgKSB7XG5cblx0XHRcdGxldCBjID0gMDtcblx0XHRcdGxldCBsYyA9IDA7XG5cdFx0XHRjb25zdCBvdXRCdWZmZXJFbmRPZmZzZXQgPSBubztcblx0XHRcdGNvbnN0IGluT2Zmc2V0RW5kID0gTWF0aC50cnVuYyggaW5PZmZzZXQudmFsdWUgKyAoIG5pICsgNyApIC8gOCApO1xuXG5cdFx0XHR3aGlsZSAoIGluT2Zmc2V0LnZhbHVlIDwgaW5PZmZzZXRFbmQgKSB7XG5cblx0XHRcdFx0Z2V0Q2hhciggYywgbGMsIHVJbnQ4QXJyYXksIGluT2Zmc2V0ICk7XG5cblx0XHRcdFx0YyA9IGdldENoYXJSZXR1cm4uYztcblx0XHRcdFx0bGMgPSBnZXRDaGFyUmV0dXJuLmxjO1xuXG5cdFx0XHRcdHdoaWxlICggbGMgPj0gSFVGX0RFQ0JJVFMgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBpbmRleCA9ICggYyA+PiAoIGxjIC0gSFVGX0RFQ0JJVFMgKSApICYgSFVGX0RFQ01BU0s7XG5cdFx0XHRcdFx0Y29uc3QgcGwgPSBkZWNvZGluZ1RhYmxlWyBpbmRleCBdO1xuXG5cdFx0XHRcdFx0aWYgKCBwbC5sZW4gKSB7XG5cblx0XHRcdFx0XHRcdGxjIC09IHBsLmxlbjtcblxuXHRcdFx0XHRcdFx0Z2V0Q29kZSggcGwubGl0LCBybGMsIGMsIGxjLCB1SW50OEFycmF5LCBpbk9mZnNldCwgb3V0QnVmZmVyLCBvdXRPZmZzZXQsIG91dEJ1ZmZlckVuZE9mZnNldCApO1xuXG5cdFx0XHRcdFx0XHRjID0gZ2V0Q29kZVJldHVybi5jO1xuXHRcdFx0XHRcdFx0bGMgPSBnZXRDb2RlUmV0dXJuLmxjO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0aWYgKCAhIHBsLnAgKSB7XG5cblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnaHVmRGVjb2RlIGlzc3VlcycgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRsZXQgajtcblxuXHRcdFx0XHRcdFx0Zm9yICggaiA9IDA7IGogPCBwbC5saXQ7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc3QgbCA9IGh1Zkxlbmd0aCggZW5jb2RpbmdUYWJsZVsgcGwucFsgaiBdIF0gKTtcblxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIGxjIDwgbCAmJiBpbk9mZnNldC52YWx1ZSA8IGluT2Zmc2V0RW5kICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Z2V0Q2hhciggYywgbGMsIHVJbnQ4QXJyYXksIGluT2Zmc2V0ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRjID0gZ2V0Q2hhclJldHVybi5jO1xuXHRcdFx0XHRcdFx0XHRcdGxjID0gZ2V0Q2hhclJldHVybi5sYztcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBsYyA+PSBsICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBodWZDb2RlKCBlbmNvZGluZ1RhYmxlWyBwbC5wWyBqIF0gXSApID09ICggKCBjID4+ICggbGMgLSBsICkgKSAmICggKCAxIDw8IGwgKSAtIDEgKSApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRsYyAtPSBsO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRnZXRDb2RlKCBwbC5wWyBqIF0sIHJsYywgYywgbGMsIHVJbnQ4QXJyYXksIGluT2Zmc2V0LCBvdXRCdWZmZXIsIG91dE9mZnNldCwgb3V0QnVmZmVyRW5kT2Zmc2V0ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGMgPSBnZXRDb2RlUmV0dXJuLmM7XG5cdFx0XHRcdFx0XHRcdFx0XHRsYyA9IGdldENvZGVSZXR1cm4ubGM7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoIGogPT0gcGwubGl0ICkge1xuXG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ2h1ZkRlY29kZSBpc3N1ZXMnICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgaSA9ICggOCAtIG5pICkgJiA3O1xuXG5cdFx0XHRjID4+PSBpO1xuXHRcdFx0bGMgLT0gaTtcblxuXHRcdFx0d2hpbGUgKCBsYyA+IDAgKSB7XG5cblx0XHRcdFx0Y29uc3QgcGwgPSBkZWNvZGluZ1RhYmxlWyAoIGMgPDwgKCBIVUZfREVDQklUUyAtIGxjICkgKSAmIEhVRl9ERUNNQVNLIF07XG5cblx0XHRcdFx0aWYgKCBwbC5sZW4gKSB7XG5cblx0XHRcdFx0XHRsYyAtPSBwbC5sZW47XG5cblx0XHRcdFx0XHRnZXRDb2RlKCBwbC5saXQsIHJsYywgYywgbGMsIHVJbnQ4QXJyYXksIGluT2Zmc2V0LCBvdXRCdWZmZXIsIG91dE9mZnNldCwgb3V0QnVmZmVyRW5kT2Zmc2V0ICk7XG5cblx0XHRcdFx0XHRjID0gZ2V0Q29kZVJldHVybi5jO1xuXHRcdFx0XHRcdGxjID0gZ2V0Q29kZVJldHVybi5sYztcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnaHVmRGVjb2RlIGlzc3VlcycgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBodWZVbmNvbXByZXNzKCB1SW50OEFycmF5LCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgbkNvbXByZXNzZWQsIG91dEJ1ZmZlciwgblJhdyApIHtcblxuXHRcdFx0Y29uc3Qgb3V0T2Zmc2V0ID0geyB2YWx1ZTogMCB9O1xuXHRcdFx0Y29uc3QgaW5pdGlhbEluT2Zmc2V0ID0gaW5PZmZzZXQudmFsdWU7XG5cblx0XHRcdGNvbnN0IGltID0gcGFyc2VVaW50MzIoIGluRGF0YVZpZXcsIGluT2Zmc2V0ICk7XG5cdFx0XHRjb25zdCBpTSA9IHBhcnNlVWludDMyKCBpbkRhdGFWaWV3LCBpbk9mZnNldCApO1xuXG5cdFx0XHRpbk9mZnNldC52YWx1ZSArPSA0O1xuXG5cdFx0XHRjb25zdCBuQml0cyA9IHBhcnNlVWludDMyKCBpbkRhdGFWaWV3LCBpbk9mZnNldCApO1xuXG5cdFx0XHRpbk9mZnNldC52YWx1ZSArPSA0O1xuXG5cdFx0XHRpZiAoIGltIDwgMCB8fCBpbSA+PSBIVUZfRU5DU0laRSB8fCBpTSA8IDAgfHwgaU0gPj0gSFVGX0VOQ1NJWkUgKSB7XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnU29tZXRoaW5nIHdyb25nIHdpdGggSFVGX0VOQ1NJWkUnICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZnJlcSA9IG5ldyBBcnJheSggSFVGX0VOQ1NJWkUgKTtcblx0XHRcdGNvbnN0IGhkZWMgPSBuZXcgQXJyYXkoIEhVRl9ERUNTSVpFICk7XG5cblx0XHRcdGh1ZkNsZWFyRGVjVGFibGUoIGhkZWMgKTtcblxuXHRcdFx0Y29uc3QgbmkgPSBuQ29tcHJlc3NlZCAtICggaW5PZmZzZXQudmFsdWUgLSBpbml0aWFsSW5PZmZzZXQgKTtcblxuXHRcdFx0aHVmVW5wYWNrRW5jVGFibGUoIHVJbnQ4QXJyYXksIGluT2Zmc2V0LCBuaSwgaW0sIGlNLCBmcmVxICk7XG5cblx0XHRcdGlmICggbkJpdHMgPiA4ICogKCBuQ29tcHJlc3NlZCAtICggaW5PZmZzZXQudmFsdWUgLSBpbml0aWFsSW5PZmZzZXQgKSApICkge1xuXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1NvbWV0aGluZyB3cm9uZyB3aXRoIGh1ZlVuY29tcHJlc3MnICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aHVmQnVpbGREZWNUYWJsZSggZnJlcSwgaW0sIGlNLCBoZGVjICk7XG5cblx0XHRcdGh1ZkRlY29kZSggZnJlcSwgaGRlYywgdUludDhBcnJheSwgaW5PZmZzZXQsIG5CaXRzLCBpTSwgblJhdywgb3V0QnVmZmVyLCBvdXRPZmZzZXQgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFwcGx5THV0KCBsdXQsIGRhdGEsIG5EYXRhICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBuRGF0YTsgKysgaSApIHtcblxuXHRcdFx0XHRkYXRhWyBpIF0gPSBsdXRbIGRhdGFbIGkgXSBdO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwcmVkaWN0b3IoIHNvdXJjZSApIHtcblxuXHRcdFx0Zm9yICggbGV0IHQgPSAxOyB0IDwgc291cmNlLmxlbmd0aDsgdCArKyApIHtcblxuXHRcdFx0XHRjb25zdCBkID0gc291cmNlWyB0IC0gMSBdICsgc291cmNlWyB0IF0gLSAxMjg7XG5cdFx0XHRcdHNvdXJjZVsgdCBdID0gZDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaW50ZXJsZWF2ZVNjYWxhciggc291cmNlLCBvdXQgKSB7XG5cblx0XHRcdGxldCB0MSA9IDA7XG5cdFx0XHRsZXQgdDIgPSBNYXRoLmZsb29yKCAoIHNvdXJjZS5sZW5ndGggKyAxICkgLyAyICk7XG5cdFx0XHRsZXQgcyA9IDA7XG5cdFx0XHRjb25zdCBzdG9wID0gc291cmNlLmxlbmd0aCAtIDE7XG5cblx0XHRcdHdoaWxlICggdHJ1ZSApIHtcblxuXHRcdFx0XHRpZiAoIHMgPiBzdG9wICkgYnJlYWs7XG5cdFx0XHRcdG91dFsgcyArKyBdID0gc291cmNlWyB0MSArKyBdO1xuXG5cdFx0XHRcdGlmICggcyA+IHN0b3AgKSBicmVhaztcblx0XHRcdFx0b3V0WyBzICsrIF0gPSBzb3VyY2VbIHQyICsrIF07XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRlY29kZVJ1bkxlbmd0aCggc291cmNlICkge1xuXG5cdFx0XHRsZXQgc2l6ZSA9IHNvdXJjZS5ieXRlTGVuZ3RoO1xuXHRcdFx0Y29uc3Qgb3V0ID0gbmV3IEFycmF5KCk7XG5cdFx0XHRsZXQgcCA9IDA7XG5cblx0XHRcdGNvbnN0IHJlYWRlciA9IG5ldyBEYXRhVmlldyggc291cmNlICk7XG5cblx0XHRcdHdoaWxlICggc2l6ZSA+IDAgKSB7XG5cblx0XHRcdFx0Y29uc3QgbCA9IHJlYWRlci5nZXRJbnQ4KCBwICsrICk7XG5cblx0XHRcdFx0aWYgKCBsIDwgMCApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGNvdW50ID0gLSBsO1xuXHRcdFx0XHRcdHNpemUgLT0gY291bnQgKyAxO1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY291bnQ7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdG91dC5wdXNoKCByZWFkZXIuZ2V0VWludDgoIHAgKysgKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnN0IGNvdW50ID0gbDtcblx0XHRcdFx0XHRzaXplIC09IDI7XG5cblx0XHRcdFx0XHRjb25zdCB2YWx1ZSA9IHJlYWRlci5nZXRVaW50OCggcCArKyApO1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY291bnQgKyAxOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRvdXQucHVzaCggdmFsdWUgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG91dDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGxvc3N5RGN0RGVjb2RlKCBjc2NTZXQsIHJvd1B0cnMsIGNoYW5uZWxEYXRhLCBhY0J1ZmZlciwgZGNCdWZmZXIsIG91dEJ1ZmZlciApIHtcblxuXHRcdFx0bGV0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KCBvdXRCdWZmZXIuYnVmZmVyICk7XG5cblx0XHRcdGNvbnN0IHdpZHRoID0gY2hhbm5lbERhdGFbIGNzY1NldC5pZHhbIDAgXSBdLndpZHRoO1xuXHRcdFx0Y29uc3QgaGVpZ2h0ID0gY2hhbm5lbERhdGFbIGNzY1NldC5pZHhbIDAgXSBdLmhlaWdodDtcblxuXHRcdFx0Y29uc3QgbnVtQ29tcCA9IDM7XG5cblx0XHRcdGNvbnN0IG51bUZ1bGxCbG9ja3NYID0gTWF0aC5mbG9vciggd2lkdGggLyA4LjAgKTtcblx0XHRcdGNvbnN0IG51bUJsb2Nrc1ggPSBNYXRoLmNlaWwoIHdpZHRoIC8gOC4wICk7XG5cdFx0XHRjb25zdCBudW1CbG9ja3NZID0gTWF0aC5jZWlsKCBoZWlnaHQgLyA4LjAgKTtcblx0XHRcdGNvbnN0IGxlZnRvdmVyWCA9IHdpZHRoIC0gKCBudW1CbG9ja3NYIC0gMSApICogODtcblx0XHRcdGNvbnN0IGxlZnRvdmVyWSA9IGhlaWdodCAtICggbnVtQmxvY2tzWSAtIDEgKSAqIDg7XG5cblx0XHRcdGNvbnN0IGN1cnJBY0NvbXAgPSB7IHZhbHVlOiAwIH07XG5cdFx0XHRjb25zdCBjdXJyRGNDb21wID0gbmV3IEFycmF5KCBudW1Db21wICk7XG5cdFx0XHRjb25zdCBkY3REYXRhID0gbmV3IEFycmF5KCBudW1Db21wICk7XG5cdFx0XHRjb25zdCBoYWxmWmlnQmxvY2sgPSBuZXcgQXJyYXkoIG51bUNvbXAgKTtcblx0XHRcdGNvbnN0IHJvd0Jsb2NrID0gbmV3IEFycmF5KCBudW1Db21wICk7XG5cdFx0XHRjb25zdCByb3dPZmZzZXRzID0gbmV3IEFycmF5KCBudW1Db21wICk7XG5cblx0XHRcdGZvciAoIGxldCBjb21wID0gMDsgY29tcCA8IG51bUNvbXA7ICsrIGNvbXAgKSB7XG5cblx0XHRcdFx0cm93T2Zmc2V0c1sgY29tcCBdID0gcm93UHRyc1sgY3NjU2V0LmlkeFsgY29tcCBdIF07XG5cdFx0XHRcdGN1cnJEY0NvbXBbIGNvbXAgXSA9ICggY29tcCA8IDEgKSA/IDAgOiBjdXJyRGNDb21wWyBjb21wIC0gMSBdICsgbnVtQmxvY2tzWCAqIG51bUJsb2Nrc1k7XG5cdFx0XHRcdGRjdERhdGFbIGNvbXAgXSA9IG5ldyBGbG9hdDMyQXJyYXkoIDY0ICk7XG5cdFx0XHRcdGhhbGZaaWdCbG9ja1sgY29tcCBdID0gbmV3IFVpbnQxNkFycmF5KCA2NCApO1xuXHRcdFx0XHRyb3dCbG9ja1sgY29tcCBdID0gbmV3IFVpbnQxNkFycmF5KCBudW1CbG9ja3NYICogNjQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBsZXQgYmxvY2t5ID0gMDsgYmxvY2t5IDwgbnVtQmxvY2tzWTsgKysgYmxvY2t5ICkge1xuXG5cdFx0XHRcdGxldCBtYXhZID0gODtcblxuXHRcdFx0XHRpZiAoIGJsb2NreSA9PSBudW1CbG9ja3NZIC0gMSApXG5cdFx0XHRcdFx0bWF4WSA9IGxlZnRvdmVyWTtcblxuXHRcdFx0XHRsZXQgbWF4WCA9IDg7XG5cblx0XHRcdFx0Zm9yICggbGV0IGJsb2NreCA9IDA7IGJsb2NreCA8IG51bUJsb2Nrc1g7ICsrIGJsb2NreCApIHtcblxuXHRcdFx0XHRcdGlmICggYmxvY2t4ID09IG51bUJsb2Nrc1ggLSAxIClcblx0XHRcdFx0XHRcdG1heFggPSBsZWZ0b3Zlclg7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgY29tcCA9IDA7IGNvbXAgPCBudW1Db21wOyArKyBjb21wICkge1xuXG5cdFx0XHRcdFx0XHRoYWxmWmlnQmxvY2tbIGNvbXAgXS5maWxsKCAwICk7XG5cblx0XHRcdFx0XHRcdC8vIHNldCBibG9jayBEQyBjb21wb25lbnRcblx0XHRcdFx0XHRcdGhhbGZaaWdCbG9ja1sgY29tcCBdWyAwIF0gPSBkY0J1ZmZlclsgY3VyckRjQ29tcFsgY29tcCBdICsrIF07XG5cdFx0XHRcdFx0XHQvLyBzZXQgYmxvY2sgQUMgY29tcG9uZW50c1xuXHRcdFx0XHRcdFx0dW5SbGVBQyggY3VyckFjQ29tcCwgYWNCdWZmZXIsIGhhbGZaaWdCbG9ja1sgY29tcCBdICk7XG5cblx0XHRcdFx0XHRcdC8vIFVuWmlnWmFnIGJsb2NrIHRvIGZsb2F0XG5cdFx0XHRcdFx0XHR1blppZ1phZyggaGFsZlppZ0Jsb2NrWyBjb21wIF0sIGRjdERhdGFbIGNvbXAgXSApO1xuXHRcdFx0XHRcdFx0Ly8gZGVjb2RlIGZsb2F0IGRjdFxuXHRcdFx0XHRcdFx0ZGN0SW52ZXJzZSggZGN0RGF0YVsgY29tcCBdICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIG51bUNvbXAgPT0gMyApIHtcblxuXHRcdFx0XHRcdFx0Y3NjNzA5SW52ZXJzZSggZGN0RGF0YSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGNvbXAgPSAwOyBjb21wIDwgbnVtQ29tcDsgKysgY29tcCApIHtcblxuXHRcdFx0XHRcdFx0Y29udmVydFRvSGFsZiggZGN0RGF0YVsgY29tcCBdLCByb3dCbG9ja1sgY29tcCBdLCBibG9ja3ggKiA2NCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gLy8gYmxvY2t4XG5cblx0XHRcdFx0bGV0IG9mZnNldCA9IDA7XG5cblx0XHRcdFx0Zm9yICggbGV0IGNvbXAgPSAwOyBjb21wIDwgbnVtQ29tcDsgKysgY29tcCApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHR5cGUgPSBjaGFubmVsRGF0YVsgY3NjU2V0LmlkeFsgY29tcCBdIF0udHlwZTtcblxuXHRcdFx0XHRcdGZvciAoIGxldCB5ID0gOCAqIGJsb2NreTsgeSA8IDggKiBibG9ja3kgKyBtYXhZOyArKyB5ICkge1xuXG5cdFx0XHRcdFx0XHRvZmZzZXQgPSByb3dPZmZzZXRzWyBjb21wIF1bIHkgXTtcblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGJsb2NreCA9IDA7IGJsb2NreCA8IG51bUZ1bGxCbG9ja3NYOyArKyBibG9ja3ggKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc3Qgc3JjID0gYmxvY2t4ICogNjQgKyAoICggeSAmIDB4NyApICogOCApO1xuXG5cdFx0XHRcdFx0XHRcdGRhdGFWaWV3LnNldFVpbnQxNiggb2Zmc2V0ICsgMCAqIElOVDE2X1NJWkUgKiB0eXBlLCByb3dCbG9ja1sgY29tcCBdWyBzcmMgKyAwIF0sIHRydWUgKTtcblx0XHRcdFx0XHRcdFx0ZGF0YVZpZXcuc2V0VWludDE2KCBvZmZzZXQgKyAxICogSU5UMTZfU0laRSAqIHR5cGUsIHJvd0Jsb2NrWyBjb21wIF1bIHNyYyArIDEgXSwgdHJ1ZSApO1xuXHRcdFx0XHRcdFx0XHRkYXRhVmlldy5zZXRVaW50MTYoIG9mZnNldCArIDIgKiBJTlQxNl9TSVpFICogdHlwZSwgcm93QmxvY2tbIGNvbXAgXVsgc3JjICsgMiBdLCB0cnVlICk7XG5cdFx0XHRcdFx0XHRcdGRhdGFWaWV3LnNldFVpbnQxNiggb2Zmc2V0ICsgMyAqIElOVDE2X1NJWkUgKiB0eXBlLCByb3dCbG9ja1sgY29tcCBdWyBzcmMgKyAzIF0sIHRydWUgKTtcblxuXHRcdFx0XHRcdFx0XHRkYXRhVmlldy5zZXRVaW50MTYoIG9mZnNldCArIDQgKiBJTlQxNl9TSVpFICogdHlwZSwgcm93QmxvY2tbIGNvbXAgXVsgc3JjICsgNCBdLCB0cnVlICk7XG5cdFx0XHRcdFx0XHRcdGRhdGFWaWV3LnNldFVpbnQxNiggb2Zmc2V0ICsgNSAqIElOVDE2X1NJWkUgKiB0eXBlLCByb3dCbG9ja1sgY29tcCBdWyBzcmMgKyA1IF0sIHRydWUgKTtcblx0XHRcdFx0XHRcdFx0ZGF0YVZpZXcuc2V0VWludDE2KCBvZmZzZXQgKyA2ICogSU5UMTZfU0laRSAqIHR5cGUsIHJvd0Jsb2NrWyBjb21wIF1bIHNyYyArIDYgXSwgdHJ1ZSApO1xuXHRcdFx0XHRcdFx0XHRkYXRhVmlldy5zZXRVaW50MTYoIG9mZnNldCArIDcgKiBJTlQxNl9TSVpFICogdHlwZSwgcm93QmxvY2tbIGNvbXAgXVsgc3JjICsgNyBdLCB0cnVlICk7XG5cblx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDggKiBJTlQxNl9TSVpFICogdHlwZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gaGFuZGxlIHBhcnRpYWwgWCBibG9ja3Ncblx0XHRcdFx0XHRpZiAoIG51bUZ1bGxCbG9ja3NYICE9IG51bUJsb2Nrc1ggKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGxldCB5ID0gOCAqIGJsb2NreTsgeSA8IDggKiBibG9ja3kgKyBtYXhZOyArKyB5ICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbnN0IG9mZnNldCA9IHJvd09mZnNldHNbIGNvbXAgXVsgeSBdICsgOCAqIG51bUZ1bGxCbG9ja3NYICogSU5UMTZfU0laRSAqIHR5cGU7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHNyYyA9IG51bUZ1bGxCbG9ja3NYICogNjQgKyAoICggeSAmIDB4NyApICogOCApO1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIGxldCB4ID0gMDsgeCA8IG1heFg7ICsrIHggKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRkYXRhVmlldy5zZXRVaW50MTYoIG9mZnNldCArIHggKiBJTlQxNl9TSVpFICogdHlwZSwgcm93QmxvY2tbIGNvbXAgXVsgc3JjICsgeCBdLCB0cnVlICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSAvLyBjb21wXG5cblx0XHRcdH0gLy8gYmxvY2t5XG5cblx0XHRcdGNvbnN0IGhhbGZSb3cgPSBuZXcgVWludDE2QXJyYXkoIHdpZHRoICk7XG5cdFx0XHRkYXRhVmlldyA9IG5ldyBEYXRhVmlldyggb3V0QnVmZmVyLmJ1ZmZlciApO1xuXG5cdFx0XHQvLyBjb252ZXJ0IGNoYW5uZWxzIGJhY2sgdG8gZmxvYXQsIGlmIG5lZWRlZFxuXHRcdFx0Zm9yICggbGV0IGNvbXAgPSAwOyBjb21wIDwgbnVtQ29tcDsgKysgY29tcCApIHtcblxuXHRcdFx0XHRjaGFubmVsRGF0YVsgY3NjU2V0LmlkeFsgY29tcCBdIF0uZGVjb2RlZCA9IHRydWU7XG5cdFx0XHRcdGNvbnN0IHR5cGUgPSBjaGFubmVsRGF0YVsgY3NjU2V0LmlkeFsgY29tcCBdIF0udHlwZTtcblxuXHRcdFx0XHRpZiAoIGNoYW5uZWxEYXRhWyBjb21wIF0udHlwZSAhPSAyICkgY29udGludWU7XG5cblx0XHRcdFx0Zm9yICggbGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyArKyB5ICkge1xuXG5cdFx0XHRcdFx0Y29uc3Qgb2Zmc2V0ID0gcm93T2Zmc2V0c1sgY29tcCBdWyB5IF07XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgeCA9IDA7IHggPCB3aWR0aDsgKysgeCApIHtcblxuXHRcdFx0XHRcdFx0aGFsZlJvd1sgeCBdID0gZGF0YVZpZXcuZ2V0VWludDE2KCBvZmZzZXQgKyB4ICogSU5UMTZfU0laRSAqIHR5cGUsIHRydWUgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAoIGxldCB4ID0gMDsgeCA8IHdpZHRoOyArKyB4ICkge1xuXG5cdFx0XHRcdFx0XHRkYXRhVmlldy5zZXRGbG9hdDMyKCBvZmZzZXQgKyB4ICogSU5UMTZfU0laRSAqIHR5cGUsIGRlY29kZUZsb2F0MTYoIGhhbGZSb3dbIHggXSApLCB0cnVlICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1blJsZUFDKCBjdXJyQWNDb21wLCBhY0J1ZmZlciwgaGFsZlppZ0Jsb2NrICkge1xuXG5cdFx0XHRsZXQgYWNWYWx1ZTtcblx0XHRcdGxldCBkY3RDb21wID0gMTtcblxuXHRcdFx0d2hpbGUgKCBkY3RDb21wIDwgNjQgKSB7XG5cblx0XHRcdFx0YWNWYWx1ZSA9IGFjQnVmZmVyWyBjdXJyQWNDb21wLnZhbHVlIF07XG5cblx0XHRcdFx0aWYgKCBhY1ZhbHVlID09IDB4ZmYwMCApIHtcblxuXHRcdFx0XHRcdGRjdENvbXAgPSA2NDtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBhY1ZhbHVlID4+IDggPT0gMHhmZiApIHtcblxuXHRcdFx0XHRcdGRjdENvbXAgKz0gYWNWYWx1ZSAmIDB4ZmY7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGhhbGZaaWdCbG9ja1sgZGN0Q29tcCBdID0gYWNWYWx1ZTtcblx0XHRcdFx0XHRkY3RDb21wICsrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjdXJyQWNDb21wLnZhbHVlICsrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1blppZ1phZyggc3JjLCBkc3QgKSB7XG5cblx0XHRcdGRzdFsgMCBdID0gZGVjb2RlRmxvYXQxNiggc3JjWyAwIF0gKTtcblx0XHRcdGRzdFsgMSBdID0gZGVjb2RlRmxvYXQxNiggc3JjWyAxIF0gKTtcblx0XHRcdGRzdFsgMiBdID0gZGVjb2RlRmxvYXQxNiggc3JjWyA1IF0gKTtcblx0XHRcdGRzdFsgMyBdID0gZGVjb2RlRmxvYXQxNiggc3JjWyA2IF0gKTtcblx0XHRcdGRzdFsgNCBdID0gZGVjb2RlRmxvYXQxNiggc3JjWyAxNCBdICk7XG5cdFx0XHRkc3RbIDUgXSA9IGRlY29kZUZsb2F0MTYoIHNyY1sgMTUgXSApO1xuXHRcdFx0ZHN0WyA2IF0gPSBkZWNvZGVGbG9hdDE2KCBzcmNbIDI3IF0gKTtcblx0XHRcdGRzdFsgNyBdID0gZGVjb2RlRmxvYXQxNiggc3JjWyAyOCBdICk7XG5cdFx0XHRkc3RbIDggXSA9IGRlY29kZUZsb2F0MTYoIHNyY1sgMiBdICk7XG5cdFx0XHRkc3RbIDkgXSA9IGRlY29kZUZsb2F0MTYoIHNyY1sgNCBdICk7XG5cblx0XHRcdGRzdFsgMTAgXSA9IGRlY29kZUZsb2F0MTYoIHNyY1sgNyBdICk7XG5cdFx0XHRkc3RbIDExIF0gPSBkZWNvZGVGbG9hdDE2KCBzcmNbIDEzIF0gKTtcblx0XHRcdGRzdFsgMTIgXSA9IGRlY29kZUZsb2F0MTYoIHNyY1sgMTYgXSApO1xuXHRcdFx0ZHN0WyAxMyBdID0gZGVjb2RlRmxvYXQxNiggc3JjWyAyNiBdICk7XG5cdFx0XHRkc3RbIDE0IF0gPSBkZWNvZGVGbG9hdDE2KCBzcmNbIDI5IF0gKTtcblx0XHRcdGRzdFsgMTUgXSA9IGRlY29kZUZsb2F0MTYoIHNyY1sgNDIgXSApO1xuXHRcdFx0ZHN0WyAxNiBdID0gZGVjb2RlRmxvYXQxNiggc3JjWyAzIF0gKTtcblx0XHRcdGRzdFsgMTcgXSA9IGRlY29kZUZsb2F0MTYoIHNyY1sgOCBdICk7XG5cdFx0XHRkc3RbIDE4IF0gPSBkZWNvZGVGbG9hdDE2KCBzcmNbIDEyIF0gKTtcblx0XHRcdGRzdFsgMTkgXSA9IGRlY29kZUZsb2F0MTYoIHNyY1sgMTcgXSApO1xuXG5cdFx0XHRkc3RbIDIwIF0gPSBkZWNvZGVGbG9hdDE2KCBzcmNbIDI1IF0gKTtcblx0XHRcdGRzdFsgMjEgXSA9IGRlY29kZUZsb2F0MTYoIHNyY1sgMzAgXSApO1xuXHRcdFx0ZHN0WyAyMiBdID0gZGVjb2RlRmxvYXQxNiggc3JjWyA0MSBdICk7XG5cdFx0XHRkc3RbIDIzIF0gPSBkZWNvZGVGbG9hdDE2KCBzcmNbIDQzIF0gKTtcblx0XHRcdGRzdFsgMjQgXSA9IGRlY29kZUZsb2F0MTYoIHNyY1sgOSBdICk7XG5cdFx0XHRkc3RbIDI1IF0gPSBkZWNvZGVGbG9hdDE2KCBzcmNbIDExIF0gKTtcblx0XHRcdGRzdFsgMjYgXSA9IGRlY29kZUZsb2F0MTYoIHNyY1sgMTggXSApO1xuXHRcdFx0ZHN0WyAyNyBdID0gZGVjb2RlRmxvYXQxNiggc3JjWyAyNCBdICk7XG5cdFx0XHRkc3RbIDI4IF0gPSBkZWNvZGVGbG9hdDE2KCBzcmNbIDMxIF0gKTtcblx0XHRcdGRzdFsgMjkgXSA9IGRlY29kZUZsb2F0MTYoIHNyY1sgNDAgXSApO1xuXG5cdFx0XHRkc3RbIDMwIF0gPSBkZWNvZGVGbG9hdDE2KCBzcmNbIDQ0IF0gKTtcblx0XHRcdGRzdFsgMzEgXSA9IGRlY29kZUZsb2F0MTYoIHNyY1sgNTMgXSApO1xuXHRcdFx0ZHN0WyAzMiBdID0gZGVjb2RlRmxvYXQxNiggc3JjWyAxMCBdICk7XG5cdFx0XHRkc3RbIDMzIF0gPSBkZWNvZGVGbG9hdDE2KCBzcmNbIDE5IF0gKTtcblx0XHRcdGRzdFsgMzQgXSA9IGRlY29kZUZsb2F0MTYoIHNyY1sgMjMgXSApO1xuXHRcdFx0ZHN0WyAzNSBdID0gZGVjb2RlRmxvYXQxNiggc3JjWyAzMiBdICk7XG5cdFx0XHRkc3RbIDM2IF0gPSBkZWNvZGVGbG9hdDE2KCBzcmNbIDM5IF0gKTtcblx0XHRcdGRzdFsgMzcgXSA9IGRlY29kZUZsb2F0MTYoIHNyY1sgNDUgXSApO1xuXHRcdFx0ZHN0WyAzOCBdID0gZGVjb2RlRmxvYXQxNiggc3JjWyA1MiBdICk7XG5cdFx0XHRkc3RbIDM5IF0gPSBkZWNvZGVGbG9hdDE2KCBzcmNbIDU0IF0gKTtcblxuXHRcdFx0ZHN0WyA0MCBdID0gZGVjb2RlRmxvYXQxNiggc3JjWyAyMCBdICk7XG5cdFx0XHRkc3RbIDQxIF0gPSBkZWNvZGVGbG9hdDE2KCBzcmNbIDIyIF0gKTtcblx0XHRcdGRzdFsgNDIgXSA9IGRlY29kZUZsb2F0MTYoIHNyY1sgMzMgXSApO1xuXHRcdFx0ZHN0WyA0MyBdID0gZGVjb2RlRmxvYXQxNiggc3JjWyAzOCBdICk7XG5cdFx0XHRkc3RbIDQ0IF0gPSBkZWNvZGVGbG9hdDE2KCBzcmNbIDQ2IF0gKTtcblx0XHRcdGRzdFsgNDUgXSA9IGRlY29kZUZsb2F0MTYoIHNyY1sgNTEgXSApO1xuXHRcdFx0ZHN0WyA0NiBdID0gZGVjb2RlRmxvYXQxNiggc3JjWyA1NSBdICk7XG5cdFx0XHRkc3RbIDQ3IF0gPSBkZWNvZGVGbG9hdDE2KCBzcmNbIDYwIF0gKTtcblx0XHRcdGRzdFsgNDggXSA9IGRlY29kZUZsb2F0MTYoIHNyY1sgMjEgXSApO1xuXHRcdFx0ZHN0WyA0OSBdID0gZGVjb2RlRmxvYXQxNiggc3JjWyAzNCBdICk7XG5cblx0XHRcdGRzdFsgNTAgXSA9IGRlY29kZUZsb2F0MTYoIHNyY1sgMzcgXSApO1xuXHRcdFx0ZHN0WyA1MSBdID0gZGVjb2RlRmxvYXQxNiggc3JjWyA0NyBdICk7XG5cdFx0XHRkc3RbIDUyIF0gPSBkZWNvZGVGbG9hdDE2KCBzcmNbIDUwIF0gKTtcblx0XHRcdGRzdFsgNTMgXSA9IGRlY29kZUZsb2F0MTYoIHNyY1sgNTYgXSApO1xuXHRcdFx0ZHN0WyA1NCBdID0gZGVjb2RlRmxvYXQxNiggc3JjWyA1OSBdICk7XG5cdFx0XHRkc3RbIDU1IF0gPSBkZWNvZGVGbG9hdDE2KCBzcmNbIDYxIF0gKTtcblx0XHRcdGRzdFsgNTYgXSA9IGRlY29kZUZsb2F0MTYoIHNyY1sgMzUgXSApO1xuXHRcdFx0ZHN0WyA1NyBdID0gZGVjb2RlRmxvYXQxNiggc3JjWyAzNiBdICk7XG5cdFx0XHRkc3RbIDU4IF0gPSBkZWNvZGVGbG9hdDE2KCBzcmNbIDQ4IF0gKTtcblx0XHRcdGRzdFsgNTkgXSA9IGRlY29kZUZsb2F0MTYoIHNyY1sgNDkgXSApO1xuXG5cdFx0XHRkc3RbIDYwIF0gPSBkZWNvZGVGbG9hdDE2KCBzcmNbIDU3IF0gKTtcblx0XHRcdGRzdFsgNjEgXSA9IGRlY29kZUZsb2F0MTYoIHNyY1sgNTggXSApO1xuXHRcdFx0ZHN0WyA2MiBdID0gZGVjb2RlRmxvYXQxNiggc3JjWyA2MiBdICk7XG5cdFx0XHRkc3RbIDYzIF0gPSBkZWNvZGVGbG9hdDE2KCBzcmNbIDYzIF0gKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRjdEludmVyc2UoIGRhdGEgKSB7XG5cblx0XHRcdGNvbnN0IGEgPSAwLjUgKiBNYXRoLmNvcyggMy4xNDE1OSAvIDQuMCApO1xuXHRcdFx0Y29uc3QgYiA9IDAuNSAqIE1hdGguY29zKCAzLjE0MTU5IC8gMTYuMCApO1xuXHRcdFx0Y29uc3QgYyA9IDAuNSAqIE1hdGguY29zKCAzLjE0MTU5IC8gOC4wICk7XG5cdFx0XHRjb25zdCBkID0gMC41ICogTWF0aC5jb3MoIDMuMCAqIDMuMTQxNTkgLyAxNi4wICk7XG5cdFx0XHRjb25zdCBlID0gMC41ICogTWF0aC5jb3MoIDUuMCAqIDMuMTQxNTkgLyAxNi4wICk7XG5cdFx0XHRjb25zdCBmID0gMC41ICogTWF0aC5jb3MoIDMuMCAqIDMuMTQxNTkgLyA4LjAgKTtcblx0XHRcdGNvbnN0IGcgPSAwLjUgKiBNYXRoLmNvcyggNy4wICogMy4xNDE1OSAvIDE2LjAgKTtcblxuXHRcdFx0Y29uc3QgYWxwaGEgPSBuZXcgQXJyYXkoIDQgKTtcblx0XHRcdGNvbnN0IGJldGEgPSBuZXcgQXJyYXkoIDQgKTtcblx0XHRcdGNvbnN0IHRoZXRhID0gbmV3IEFycmF5KCA0ICk7XG5cdFx0XHRjb25zdCBnYW1tYSA9IG5ldyBBcnJheSggNCApO1xuXG5cdFx0XHRmb3IgKCBsZXQgcm93ID0gMDsgcm93IDwgODsgKysgcm93ICkge1xuXG5cdFx0XHRcdGNvbnN0IHJvd1B0ciA9IHJvdyAqIDg7XG5cblx0XHRcdFx0YWxwaGFbIDAgXSA9IGMgKiBkYXRhWyByb3dQdHIgKyAyIF07XG5cdFx0XHRcdGFscGhhWyAxIF0gPSBmICogZGF0YVsgcm93UHRyICsgMiBdO1xuXHRcdFx0XHRhbHBoYVsgMiBdID0gYyAqIGRhdGFbIHJvd1B0ciArIDYgXTtcblx0XHRcdFx0YWxwaGFbIDMgXSA9IGYgKiBkYXRhWyByb3dQdHIgKyA2IF07XG5cblx0XHRcdFx0YmV0YVsgMCBdID0gYiAqIGRhdGFbIHJvd1B0ciArIDEgXSArIGQgKiBkYXRhWyByb3dQdHIgKyAzIF0gKyBlICogZGF0YVsgcm93UHRyICsgNSBdICsgZyAqIGRhdGFbIHJvd1B0ciArIDcgXTtcblx0XHRcdFx0YmV0YVsgMSBdID0gZCAqIGRhdGFbIHJvd1B0ciArIDEgXSAtIGcgKiBkYXRhWyByb3dQdHIgKyAzIF0gLSBiICogZGF0YVsgcm93UHRyICsgNSBdIC0gZSAqIGRhdGFbIHJvd1B0ciArIDcgXTtcblx0XHRcdFx0YmV0YVsgMiBdID0gZSAqIGRhdGFbIHJvd1B0ciArIDEgXSAtIGIgKiBkYXRhWyByb3dQdHIgKyAzIF0gKyBnICogZGF0YVsgcm93UHRyICsgNSBdICsgZCAqIGRhdGFbIHJvd1B0ciArIDcgXTtcblx0XHRcdFx0YmV0YVsgMyBdID0gZyAqIGRhdGFbIHJvd1B0ciArIDEgXSAtIGUgKiBkYXRhWyByb3dQdHIgKyAzIF0gKyBkICogZGF0YVsgcm93UHRyICsgNSBdIC0gYiAqIGRhdGFbIHJvd1B0ciArIDcgXTtcblxuXHRcdFx0XHR0aGV0YVsgMCBdID0gYSAqICggZGF0YVsgcm93UHRyICsgMCBdICsgZGF0YVsgcm93UHRyICsgNCBdICk7XG5cdFx0XHRcdHRoZXRhWyAzIF0gPSBhICogKCBkYXRhWyByb3dQdHIgKyAwIF0gLSBkYXRhWyByb3dQdHIgKyA0IF0gKTtcblx0XHRcdFx0dGhldGFbIDEgXSA9IGFscGhhWyAwIF0gKyBhbHBoYVsgMyBdO1xuXHRcdFx0XHR0aGV0YVsgMiBdID0gYWxwaGFbIDEgXSAtIGFscGhhWyAyIF07XG5cblx0XHRcdFx0Z2FtbWFbIDAgXSA9IHRoZXRhWyAwIF0gKyB0aGV0YVsgMSBdO1xuXHRcdFx0XHRnYW1tYVsgMSBdID0gdGhldGFbIDMgXSArIHRoZXRhWyAyIF07XG5cdFx0XHRcdGdhbW1hWyAyIF0gPSB0aGV0YVsgMyBdIC0gdGhldGFbIDIgXTtcblx0XHRcdFx0Z2FtbWFbIDMgXSA9IHRoZXRhWyAwIF0gLSB0aGV0YVsgMSBdO1xuXG5cdFx0XHRcdGRhdGFbIHJvd1B0ciArIDAgXSA9IGdhbW1hWyAwIF0gKyBiZXRhWyAwIF07XG5cdFx0XHRcdGRhdGFbIHJvd1B0ciArIDEgXSA9IGdhbW1hWyAxIF0gKyBiZXRhWyAxIF07XG5cdFx0XHRcdGRhdGFbIHJvd1B0ciArIDIgXSA9IGdhbW1hWyAyIF0gKyBiZXRhWyAyIF07XG5cdFx0XHRcdGRhdGFbIHJvd1B0ciArIDMgXSA9IGdhbW1hWyAzIF0gKyBiZXRhWyAzIF07XG5cblx0XHRcdFx0ZGF0YVsgcm93UHRyICsgNCBdID0gZ2FtbWFbIDMgXSAtIGJldGFbIDMgXTtcblx0XHRcdFx0ZGF0YVsgcm93UHRyICsgNSBdID0gZ2FtbWFbIDIgXSAtIGJldGFbIDIgXTtcblx0XHRcdFx0ZGF0YVsgcm93UHRyICsgNiBdID0gZ2FtbWFbIDEgXSAtIGJldGFbIDEgXTtcblx0XHRcdFx0ZGF0YVsgcm93UHRyICsgNyBdID0gZ2FtbWFbIDAgXSAtIGJldGFbIDAgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBsZXQgY29sdW1uID0gMDsgY29sdW1uIDwgODsgKysgY29sdW1uICkge1xuXG5cdFx0XHRcdGFscGhhWyAwIF0gPSBjICogZGF0YVsgMTYgKyBjb2x1bW4gXTtcblx0XHRcdFx0YWxwaGFbIDEgXSA9IGYgKiBkYXRhWyAxNiArIGNvbHVtbiBdO1xuXHRcdFx0XHRhbHBoYVsgMiBdID0gYyAqIGRhdGFbIDQ4ICsgY29sdW1uIF07XG5cdFx0XHRcdGFscGhhWyAzIF0gPSBmICogZGF0YVsgNDggKyBjb2x1bW4gXTtcblxuXHRcdFx0XHRiZXRhWyAwIF0gPSBiICogZGF0YVsgOCArIGNvbHVtbiBdICsgZCAqIGRhdGFbIDI0ICsgY29sdW1uIF0gKyBlICogZGF0YVsgNDAgKyBjb2x1bW4gXSArIGcgKiBkYXRhWyA1NiArIGNvbHVtbiBdO1xuXHRcdFx0XHRiZXRhWyAxIF0gPSBkICogZGF0YVsgOCArIGNvbHVtbiBdIC0gZyAqIGRhdGFbIDI0ICsgY29sdW1uIF0gLSBiICogZGF0YVsgNDAgKyBjb2x1bW4gXSAtIGUgKiBkYXRhWyA1NiArIGNvbHVtbiBdO1xuXHRcdFx0XHRiZXRhWyAyIF0gPSBlICogZGF0YVsgOCArIGNvbHVtbiBdIC0gYiAqIGRhdGFbIDI0ICsgY29sdW1uIF0gKyBnICogZGF0YVsgNDAgKyBjb2x1bW4gXSArIGQgKiBkYXRhWyA1NiArIGNvbHVtbiBdO1xuXHRcdFx0XHRiZXRhWyAzIF0gPSBnICogZGF0YVsgOCArIGNvbHVtbiBdIC0gZSAqIGRhdGFbIDI0ICsgY29sdW1uIF0gKyBkICogZGF0YVsgNDAgKyBjb2x1bW4gXSAtIGIgKiBkYXRhWyA1NiArIGNvbHVtbiBdO1xuXG5cdFx0XHRcdHRoZXRhWyAwIF0gPSBhICogKCBkYXRhWyBjb2x1bW4gXSArIGRhdGFbIDMyICsgY29sdW1uIF0gKTtcblx0XHRcdFx0dGhldGFbIDMgXSA9IGEgKiAoIGRhdGFbIGNvbHVtbiBdIC0gZGF0YVsgMzIgKyBjb2x1bW4gXSApO1xuXG5cdFx0XHRcdHRoZXRhWyAxIF0gPSBhbHBoYVsgMCBdICsgYWxwaGFbIDMgXTtcblx0XHRcdFx0dGhldGFbIDIgXSA9IGFscGhhWyAxIF0gLSBhbHBoYVsgMiBdO1xuXG5cdFx0XHRcdGdhbW1hWyAwIF0gPSB0aGV0YVsgMCBdICsgdGhldGFbIDEgXTtcblx0XHRcdFx0Z2FtbWFbIDEgXSA9IHRoZXRhWyAzIF0gKyB0aGV0YVsgMiBdO1xuXHRcdFx0XHRnYW1tYVsgMiBdID0gdGhldGFbIDMgXSAtIHRoZXRhWyAyIF07XG5cdFx0XHRcdGdhbW1hWyAzIF0gPSB0aGV0YVsgMCBdIC0gdGhldGFbIDEgXTtcblxuXHRcdFx0XHRkYXRhWyAwICsgY29sdW1uIF0gPSBnYW1tYVsgMCBdICsgYmV0YVsgMCBdO1xuXHRcdFx0XHRkYXRhWyA4ICsgY29sdW1uIF0gPSBnYW1tYVsgMSBdICsgYmV0YVsgMSBdO1xuXHRcdFx0XHRkYXRhWyAxNiArIGNvbHVtbiBdID0gZ2FtbWFbIDIgXSArIGJldGFbIDIgXTtcblx0XHRcdFx0ZGF0YVsgMjQgKyBjb2x1bW4gXSA9IGdhbW1hWyAzIF0gKyBiZXRhWyAzIF07XG5cblx0XHRcdFx0ZGF0YVsgMzIgKyBjb2x1bW4gXSA9IGdhbW1hWyAzIF0gLSBiZXRhWyAzIF07XG5cdFx0XHRcdGRhdGFbIDQwICsgY29sdW1uIF0gPSBnYW1tYVsgMiBdIC0gYmV0YVsgMiBdO1xuXHRcdFx0XHRkYXRhWyA0OCArIGNvbHVtbiBdID0gZ2FtbWFbIDEgXSAtIGJldGFbIDEgXTtcblx0XHRcdFx0ZGF0YVsgNTYgKyBjb2x1bW4gXSA9IGdhbW1hWyAwIF0gLSBiZXRhWyAwIF07XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNzYzcwOUludmVyc2UoIGRhdGEgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDY0OyArKyBpICkge1xuXG5cdFx0XHRcdGNvbnN0IHkgPSBkYXRhWyAwIF1bIGkgXTtcblx0XHRcdFx0Y29uc3QgY2IgPSBkYXRhWyAxIF1bIGkgXTtcblx0XHRcdFx0Y29uc3QgY3IgPSBkYXRhWyAyIF1bIGkgXTtcblxuXHRcdFx0XHRkYXRhWyAwIF1bIGkgXSA9IHkgKyAxLjU3NDcgKiBjcjtcblx0XHRcdFx0ZGF0YVsgMSBdWyBpIF0gPSB5IC0gMC4xODczICogY2IgLSAwLjQ2ODIgKiBjcjtcblx0XHRcdFx0ZGF0YVsgMiBdWyBpIF0gPSB5ICsgMS44NTU2ICogY2I7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNvbnZlcnRUb0hhbGYoIHNyYywgZHN0LCBpZHggKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDY0OyArKyBpICkge1xuXG5cdFx0XHRcdGRzdFsgaWR4ICsgaSBdID0gRGF0YVV0aWxzLnRvSGFsZkZsb2F0KCB0b0xpbmVhciggc3JjWyBpIF0gKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0b0xpbmVhciggZmxvYXQgKSB7XG5cblx0XHRcdGlmICggZmxvYXQgPD0gMSApIHtcblxuXHRcdFx0XHRyZXR1cm4gTWF0aC5zaWduKCBmbG9hdCApICogTWF0aC5wb3coIE1hdGguYWJzKCBmbG9hdCApLCAyLjIgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXR1cm4gTWF0aC5zaWduKCBmbG9hdCApICogTWF0aC5wb3coIGxvZ0Jhc2UsIE1hdGguYWJzKCBmbG9hdCApIC0gMS4wICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVuY29tcHJlc3NSQVcoIGluZm8gKSB7XG5cblx0XHRcdHJldHVybiBuZXcgRGF0YVZpZXcoIGluZm8uYXJyYXkuYnVmZmVyLCBpbmZvLm9mZnNldC52YWx1ZSwgaW5mby5zaXplICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1bmNvbXByZXNzUkxFKCBpbmZvICkge1xuXG5cdFx0XHRjb25zdCBjb21wcmVzc2VkID0gaW5mby52aWV3ZXIuYnVmZmVyLnNsaWNlKCBpbmZvLm9mZnNldC52YWx1ZSwgaW5mby5vZmZzZXQudmFsdWUgKyBpbmZvLnNpemUgKTtcblxuXHRcdFx0Y29uc3QgcmF3QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoIGRlY29kZVJ1bkxlbmd0aCggY29tcHJlc3NlZCApICk7XG5cdFx0XHRjb25zdCB0bXBCdWZmZXIgPSBuZXcgVWludDhBcnJheSggcmF3QnVmZmVyLmxlbmd0aCApO1xuXG5cdFx0XHRwcmVkaWN0b3IoIHJhd0J1ZmZlciApOyAvLyByZXZlcnQgcHJlZGljdG9yXG5cblx0XHRcdGludGVybGVhdmVTY2FsYXIoIHJhd0J1ZmZlciwgdG1wQnVmZmVyICk7IC8vIGludGVybGVhdmUgcGl4ZWxzXG5cblx0XHRcdHJldHVybiBuZXcgRGF0YVZpZXcoIHRtcEJ1ZmZlci5idWZmZXIgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVuY29tcHJlc3NaSVAoIGluZm8gKSB7XG5cblx0XHRcdGNvbnN0IGNvbXByZXNzZWQgPSBpbmZvLmFycmF5LnNsaWNlKCBpbmZvLm9mZnNldC52YWx1ZSwgaW5mby5vZmZzZXQudmFsdWUgKyBpbmZvLnNpemUgKTtcblxuXHRcdFx0Y29uc3QgcmF3QnVmZmVyID0gZmZsYXRlLnVuemxpYlN5bmMoIGNvbXByZXNzZWQgKTtcblx0XHRcdGNvbnN0IHRtcEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KCByYXdCdWZmZXIubGVuZ3RoICk7XG5cblx0XHRcdHByZWRpY3RvciggcmF3QnVmZmVyICk7IC8vIHJldmVydCBwcmVkaWN0b3JcblxuXHRcdFx0aW50ZXJsZWF2ZVNjYWxhciggcmF3QnVmZmVyLCB0bXBCdWZmZXIgKTsgLy8gaW50ZXJsZWF2ZSBwaXhlbHNcblxuXHRcdFx0cmV0dXJuIG5ldyBEYXRhVmlldyggdG1wQnVmZmVyLmJ1ZmZlciApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdW5jb21wcmVzc1BJWiggaW5mbyApIHtcblxuXHRcdFx0Y29uc3QgaW5EYXRhVmlldyA9IGluZm8udmlld2VyO1xuXHRcdFx0Y29uc3QgaW5PZmZzZXQgPSB7IHZhbHVlOiBpbmZvLm9mZnNldC52YWx1ZSB9O1xuXG5cdFx0XHRjb25zdCBvdXRCdWZmZXIgPSBuZXcgVWludDE2QXJyYXkoIGluZm8ud2lkdGggKiBpbmZvLnNjYW5saW5lQmxvY2tTaXplICogKCBpbmZvLmNoYW5uZWxzICogaW5mby50eXBlICkgKTtcblx0XHRcdGNvbnN0IGJpdG1hcCA9IG5ldyBVaW50OEFycmF5KCBCSVRNQVBfU0laRSApO1xuXG5cdFx0XHQvLyBTZXR1cCBjaGFubmVsIGluZm9cblx0XHRcdGxldCBvdXRCdWZmZXJFbmQgPSAwO1xuXHRcdFx0Y29uc3QgcGl6Q2hhbm5lbERhdGEgPSBuZXcgQXJyYXkoIGluZm8uY2hhbm5lbHMgKTtcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGluZm8uY2hhbm5lbHM7IGkgKysgKSB7XG5cblx0XHRcdFx0cGl6Q2hhbm5lbERhdGFbIGkgXSA9IHt9O1xuXHRcdFx0XHRwaXpDaGFubmVsRGF0YVsgaSBdWyAnc3RhcnQnIF0gPSBvdXRCdWZmZXJFbmQ7XG5cdFx0XHRcdHBpekNoYW5uZWxEYXRhWyBpIF1bICdlbmQnIF0gPSBwaXpDaGFubmVsRGF0YVsgaSBdWyAnc3RhcnQnIF07XG5cdFx0XHRcdHBpekNoYW5uZWxEYXRhWyBpIF1bICdueCcgXSA9IGluZm8ud2lkdGg7XG5cdFx0XHRcdHBpekNoYW5uZWxEYXRhWyBpIF1bICdueScgXSA9IGluZm8ubGluZXM7XG5cdFx0XHRcdHBpekNoYW5uZWxEYXRhWyBpIF1bICdzaXplJyBdID0gaW5mby50eXBlO1xuXG5cdFx0XHRcdG91dEJ1ZmZlckVuZCArPSBwaXpDaGFubmVsRGF0YVsgaSBdLm54ICogcGl6Q2hhbm5lbERhdGFbIGkgXS5ueSAqIHBpekNoYW5uZWxEYXRhWyBpIF0uc2l6ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZWFkIHJhbmdlIGNvbXByZXNzaW9uIGRhdGFcblxuXHRcdFx0Y29uc3QgbWluTm9uWmVybyA9IHBhcnNlVWludDE2KCBpbkRhdGFWaWV3LCBpbk9mZnNldCApO1xuXHRcdFx0Y29uc3QgbWF4Tm9uWmVybyA9IHBhcnNlVWludDE2KCBpbkRhdGFWaWV3LCBpbk9mZnNldCApO1xuXG5cdFx0XHRpZiAoIG1heE5vblplcm8gPj0gQklUTUFQX1NJWkUgKSB7XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnU29tZXRoaW5nIGlzIHdyb25nIHdpdGggUElaX0NPTVBSRVNTSU9OIEJJVE1BUF9TSVpFJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWluTm9uWmVybyA8PSBtYXhOb25aZXJvICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IG1heE5vblplcm8gLSBtaW5Ob25aZXJvICsgMTsgaSArKyApIHtcblxuXHRcdFx0XHRcdGJpdG1hcFsgaSArIG1pbk5vblplcm8gXSA9IHBhcnNlVWludDgoIGluRGF0YVZpZXcsIGluT2Zmc2V0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2UgTFVUXG5cdFx0XHRjb25zdCBsdXQgPSBuZXcgVWludDE2QXJyYXkoIFVTSE9SVF9SQU5HRSApO1xuXHRcdFx0Y29uc3QgbWF4VmFsdWUgPSByZXZlcnNlTHV0RnJvbUJpdG1hcCggYml0bWFwLCBsdXQgKTtcblxuXHRcdFx0Y29uc3QgbGVuZ3RoID0gcGFyc2VVaW50MzIoIGluRGF0YVZpZXcsIGluT2Zmc2V0ICk7XG5cblx0XHRcdC8vIEh1ZmZtYW4gZGVjb2Rpbmdcblx0XHRcdGh1ZlVuY29tcHJlc3MoIGluZm8uYXJyYXksIGluRGF0YVZpZXcsIGluT2Zmc2V0LCBsZW5ndGgsIG91dEJ1ZmZlciwgb3V0QnVmZmVyRW5kICk7XG5cblx0XHRcdC8vIFdhdmVsZXQgZGVjb2Rpbmdcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGluZm8uY2hhbm5lbHM7ICsrIGkgKSB7XG5cblx0XHRcdFx0Y29uc3QgY2QgPSBwaXpDaGFubmVsRGF0YVsgaSBdO1xuXG5cdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IHBpekNoYW5uZWxEYXRhWyBpIF0uc2l6ZTsgKysgaiApIHtcblxuXHRcdFx0XHRcdHdhdjJEZWNvZGUoXG5cdFx0XHRcdFx0XHRvdXRCdWZmZXIsXG5cdFx0XHRcdFx0XHRjZC5zdGFydCArIGosXG5cdFx0XHRcdFx0XHRjZC5ueCxcblx0XHRcdFx0XHRcdGNkLnNpemUsXG5cdFx0XHRcdFx0XHRjZC5ueSxcblx0XHRcdFx0XHRcdGNkLm54ICogY2Quc2l6ZSxcblx0XHRcdFx0XHRcdG1heFZhbHVlXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gRXhwYW5kIHRoZSBwaXhlbCBkYXRhIHRvIHRoZWlyIG9yaWdpbmFsIHJhbmdlXG5cdFx0XHRhcHBseUx1dCggbHV0LCBvdXRCdWZmZXIsIG91dEJ1ZmZlckVuZCApO1xuXG5cdFx0XHQvLyBSZWFycmFuZ2UgdGhlIHBpeGVsIGRhdGEgaW50byB0aGUgZm9ybWF0IGV4cGVjdGVkIGJ5IHRoZSBjYWxsZXIuXG5cdFx0XHRsZXQgdG1wT2Zmc2V0ID0gMDtcblx0XHRcdGNvbnN0IHRtcEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KCBvdXRCdWZmZXIuYnVmZmVyLmJ5dGVMZW5ndGggKTtcblx0XHRcdGZvciAoIGxldCB5ID0gMDsgeSA8IGluZm8ubGluZXM7IHkgKysgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGMgPSAwOyBjIDwgaW5mby5jaGFubmVsczsgYyArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGNkID0gcGl6Q2hhbm5lbERhdGFbIGMgXTtcblxuXHRcdFx0XHRcdGNvbnN0IG4gPSBjZC5ueCAqIGNkLnNpemU7XG5cdFx0XHRcdFx0Y29uc3QgY3AgPSBuZXcgVWludDhBcnJheSggb3V0QnVmZmVyLmJ1ZmZlciwgY2QuZW5kICogSU5UMTZfU0laRSwgbiAqIElOVDE2X1NJWkUgKTtcblxuXHRcdFx0XHRcdHRtcEJ1ZmZlci5zZXQoIGNwLCB0bXBPZmZzZXQgKTtcblx0XHRcdFx0XHR0bXBPZmZzZXQgKz0gbiAqIElOVDE2X1NJWkU7XG5cdFx0XHRcdFx0Y2QuZW5kICs9IG47XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBuZXcgRGF0YVZpZXcoIHRtcEJ1ZmZlci5idWZmZXIgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVuY29tcHJlc3NQWFIoIGluZm8gKSB7XG5cblx0XHRcdGNvbnN0IGNvbXByZXNzZWQgPSBpbmZvLmFycmF5LnNsaWNlKCBpbmZvLm9mZnNldC52YWx1ZSwgaW5mby5vZmZzZXQudmFsdWUgKyBpbmZvLnNpemUgKTtcblxuXHRcdFx0Y29uc3QgcmF3QnVmZmVyID0gZmZsYXRlLnVuemxpYlN5bmMoIGNvbXByZXNzZWQgKTtcblxuXHRcdFx0Y29uc3Qgc3ogPSBpbmZvLmxpbmVzICogaW5mby5jaGFubmVscyAqIGluZm8ud2lkdGg7XG5cdFx0XHRjb25zdCB0bXBCdWZmZXIgPSAoIGluZm8udHlwZSA9PSAxICkgPyBuZXcgVWludDE2QXJyYXkoIHN6ICkgOiBuZXcgVWludDMyQXJyYXkoIHN6ICk7XG5cblx0XHRcdGxldCB0bXBCdWZmZXJFbmQgPSAwO1xuXHRcdFx0bGV0IHdyaXRlUHRyID0gMDtcblx0XHRcdGNvbnN0IHB0ciA9IG5ldyBBcnJheSggNCApO1xuXG5cdFx0XHRmb3IgKCBsZXQgeSA9IDA7IHkgPCBpbmZvLmxpbmVzOyB5ICsrICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBjID0gMDsgYyA8IGluZm8uY2hhbm5lbHM7IGMgKysgKSB7XG5cblx0XHRcdFx0XHRsZXQgcGl4ZWwgPSAwO1xuXG5cdFx0XHRcdFx0c3dpdGNoICggaW5mby50eXBlICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlIDE6XG5cblx0XHRcdFx0XHRcdFx0cHRyWyAwIF0gPSB0bXBCdWZmZXJFbmQ7XG5cdFx0XHRcdFx0XHRcdHB0clsgMSBdID0gcHRyWyAwIF0gKyBpbmZvLndpZHRoO1xuXHRcdFx0XHRcdFx0XHR0bXBCdWZmZXJFbmQgPSBwdHJbIDEgXSArIGluZm8ud2lkdGg7XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgaW5mby53aWR0aDsgKysgaiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IGRpZmYgPSAoIHJhd0J1ZmZlclsgcHRyWyAwIF0gKysgXSA8PCA4ICkgfCByYXdCdWZmZXJbIHB0clsgMSBdICsrIF07XG5cblx0XHRcdFx0XHRcdFx0XHRwaXhlbCArPSBkaWZmO1xuXG5cdFx0XHRcdFx0XHRcdFx0dG1wQnVmZmVyWyB3cml0ZVB0ciBdID0gcGl4ZWw7XG5cdFx0XHRcdFx0XHRcdFx0d3JpdGVQdHIgKys7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIDI6XG5cblx0XHRcdFx0XHRcdFx0cHRyWyAwIF0gPSB0bXBCdWZmZXJFbmQ7XG5cdFx0XHRcdFx0XHRcdHB0clsgMSBdID0gcHRyWyAwIF0gKyBpbmZvLndpZHRoO1xuXHRcdFx0XHRcdFx0XHRwdHJbIDIgXSA9IHB0clsgMSBdICsgaW5mby53aWR0aDtcblx0XHRcdFx0XHRcdFx0dG1wQnVmZmVyRW5kID0gcHRyWyAyIF0gKyBpbmZvLndpZHRoO1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IGluZm8ud2lkdGg7ICsrIGogKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjb25zdCBkaWZmID0gKCByYXdCdWZmZXJbIHB0clsgMCBdICsrIF0gPDwgMjQgKSB8ICggcmF3QnVmZmVyWyBwdHJbIDEgXSArKyBdIDw8IDE2ICkgfCAoIHJhd0J1ZmZlclsgcHRyWyAyIF0gKysgXSA8PCA4ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRwaXhlbCArPSBkaWZmO1xuXG5cdFx0XHRcdFx0XHRcdFx0dG1wQnVmZmVyWyB3cml0ZVB0ciBdID0gcGl4ZWw7XG5cdFx0XHRcdFx0XHRcdFx0d3JpdGVQdHIgKys7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IERhdGFWaWV3KCB0bXBCdWZmZXIuYnVmZmVyICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1bmNvbXByZXNzRFdBKCBpbmZvICkge1xuXG5cdFx0XHRjb25zdCBpbkRhdGFWaWV3ID0gaW5mby52aWV3ZXI7XG5cdFx0XHRjb25zdCBpbk9mZnNldCA9IHsgdmFsdWU6IGluZm8ub2Zmc2V0LnZhbHVlIH07XG5cdFx0XHRjb25zdCBvdXRCdWZmZXIgPSBuZXcgVWludDhBcnJheSggaW5mby53aWR0aCAqIGluZm8ubGluZXMgKiAoIGluZm8uY2hhbm5lbHMgKiBpbmZvLnR5cGUgKiBJTlQxNl9TSVpFICkgKTtcblxuXHRcdFx0Ly8gUmVhZCBjb21wcmVzc2lvbiBoZWFkZXIgaW5mb3JtYXRpb25cblx0XHRcdGNvbnN0IGR3YUhlYWRlciA9IHtcblxuXHRcdFx0XHR2ZXJzaW9uOiBwYXJzZUludDY0KCBpbkRhdGFWaWV3LCBpbk9mZnNldCApLFxuXHRcdFx0XHR1bmtub3duVW5jb21wcmVzc2VkU2l6ZTogcGFyc2VJbnQ2NCggaW5EYXRhVmlldywgaW5PZmZzZXQgKSxcblx0XHRcdFx0dW5rbm93bkNvbXByZXNzZWRTaXplOiBwYXJzZUludDY0KCBpbkRhdGFWaWV3LCBpbk9mZnNldCApLFxuXHRcdFx0XHRhY0NvbXByZXNzZWRTaXplOiBwYXJzZUludDY0KCBpbkRhdGFWaWV3LCBpbk9mZnNldCApLFxuXHRcdFx0XHRkY0NvbXByZXNzZWRTaXplOiBwYXJzZUludDY0KCBpbkRhdGFWaWV3LCBpbk9mZnNldCApLFxuXHRcdFx0XHRybGVDb21wcmVzc2VkU2l6ZTogcGFyc2VJbnQ2NCggaW5EYXRhVmlldywgaW5PZmZzZXQgKSxcblx0XHRcdFx0cmxlVW5jb21wcmVzc2VkU2l6ZTogcGFyc2VJbnQ2NCggaW5EYXRhVmlldywgaW5PZmZzZXQgKSxcblx0XHRcdFx0cmxlUmF3U2l6ZTogcGFyc2VJbnQ2NCggaW5EYXRhVmlldywgaW5PZmZzZXQgKSxcblx0XHRcdFx0dG90YWxBY1VuY29tcHJlc3NlZENvdW50OiBwYXJzZUludDY0KCBpbkRhdGFWaWV3LCBpbk9mZnNldCApLFxuXHRcdFx0XHR0b3RhbERjVW5jb21wcmVzc2VkQ291bnQ6IHBhcnNlSW50NjQoIGluRGF0YVZpZXcsIGluT2Zmc2V0ICksXG5cdFx0XHRcdGFjQ29tcHJlc3Npb246IHBhcnNlSW50NjQoIGluRGF0YVZpZXcsIGluT2Zmc2V0IClcblxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKCBkd2FIZWFkZXIudmVyc2lvbiA8IDIgKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdFWFJMb2FkZXIucGFyc2U6ICcgKyBFWFJIZWFkZXIuY29tcHJlc3Npb24gKyAnIHZlcnNpb24gJyArIGR3YUhlYWRlci52ZXJzaW9uICsgJyBpcyB1bnN1cHBvcnRlZCcgKTtcblxuXHRcdFx0Ly8gUmVhZCBjaGFubmVsIHJ1bGVzZXQgaW5mb3JtYXRpb25cblx0XHRcdGNvbnN0IGNoYW5uZWxSdWxlcyA9IG5ldyBBcnJheSgpO1xuXHRcdFx0bGV0IHJ1bGVTaXplID0gcGFyc2VVaW50MTYoIGluRGF0YVZpZXcsIGluT2Zmc2V0ICkgLSBJTlQxNl9TSVpFO1xuXG5cdFx0XHR3aGlsZSAoIHJ1bGVTaXplID4gMCApIHtcblxuXHRcdFx0XHRjb25zdCBuYW1lID0gcGFyc2VOdWxsVGVybWluYXRlZFN0cmluZyggaW5EYXRhVmlldy5idWZmZXIsIGluT2Zmc2V0ICk7XG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gcGFyc2VVaW50OCggaW5EYXRhVmlldywgaW5PZmZzZXQgKTtcblx0XHRcdFx0Y29uc3QgY29tcHJlc3Npb24gPSAoIHZhbHVlID4+IDIgKSAmIDM7XG5cdFx0XHRcdGNvbnN0IGNzYyA9ICggdmFsdWUgPj4gNCApIC0gMTtcblx0XHRcdFx0Y29uc3QgaW5kZXggPSBuZXcgSW50OEFycmF5KCBbIGNzYyBdIClbIDAgXTtcblx0XHRcdFx0Y29uc3QgdHlwZSA9IHBhcnNlVWludDgoIGluRGF0YVZpZXcsIGluT2Zmc2V0ICk7XG5cblx0XHRcdFx0Y2hhbm5lbFJ1bGVzLnB1c2goIHtcblx0XHRcdFx0XHRuYW1lOiBuYW1lLFxuXHRcdFx0XHRcdGluZGV4OiBpbmRleCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdGNvbXByZXNzaW9uOiBjb21wcmVzc2lvbixcblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdHJ1bGVTaXplIC09IG5hbWUubGVuZ3RoICsgMztcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGFzc2lmeSBjaGFubmVsc1xuXHRcdFx0Y29uc3QgY2hhbm5lbHMgPSBFWFJIZWFkZXIuY2hhbm5lbHM7XG5cdFx0XHRjb25zdCBjaGFubmVsRGF0YSA9IG5ldyBBcnJheSggaW5mby5jaGFubmVscyApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBpbmZvLmNoYW5uZWxzOyArKyBpICkge1xuXG5cdFx0XHRcdGNvbnN0IGNkID0gY2hhbm5lbERhdGFbIGkgXSA9IHt9O1xuXHRcdFx0XHRjb25zdCBjaGFubmVsID0gY2hhbm5lbHNbIGkgXTtcblxuXHRcdFx0XHRjZC5uYW1lID0gY2hhbm5lbC5uYW1lO1xuXHRcdFx0XHRjZC5jb21wcmVzc2lvbiA9IFVOS05PV047XG5cdFx0XHRcdGNkLmRlY29kZWQgPSBmYWxzZTtcblx0XHRcdFx0Y2QudHlwZSA9IGNoYW5uZWwucGl4ZWxUeXBlO1xuXHRcdFx0XHRjZC5wTGluZWFyID0gY2hhbm5lbC5wTGluZWFyO1xuXHRcdFx0XHRjZC53aWR0aCA9IGluZm8ud2lkdGg7XG5cdFx0XHRcdGNkLmhlaWdodCA9IGluZm8ubGluZXM7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgY3NjU2V0ID0ge1xuXHRcdFx0XHRpZHg6IG5ldyBBcnJheSggMyApXG5cdFx0XHR9O1xuXG5cdFx0XHRmb3IgKCBsZXQgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgaW5mby5jaGFubmVsczsgKysgb2Zmc2V0ICkge1xuXG5cdFx0XHRcdGNvbnN0IGNkID0gY2hhbm5lbERhdGFbIG9mZnNldCBdO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGNoYW5uZWxSdWxlcy5sZW5ndGg7ICsrIGkgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBydWxlID0gY2hhbm5lbFJ1bGVzWyBpIF07XG5cblx0XHRcdFx0XHRpZiAoIGNkLm5hbWUgPT0gcnVsZS5uYW1lICkge1xuXG5cdFx0XHRcdFx0XHRjZC5jb21wcmVzc2lvbiA9IHJ1bGUuY29tcHJlc3Npb247XG5cblx0XHRcdFx0XHRcdGlmICggcnVsZS5pbmRleCA+PSAwICkge1xuXG5cdFx0XHRcdFx0XHRcdGNzY1NldC5pZHhbIHJ1bGUuaW5kZXggXSA9IG9mZnNldDtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRjZC5vZmZzZXQgPSBvZmZzZXQ7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGxldCBhY0J1ZmZlciwgZGNCdWZmZXIsIHJsZUJ1ZmZlcjtcblxuXHRcdFx0Ly8gUmVhZCBEQ1QgLSBBQyBjb21wb25lbnQgZGF0YVxuXHRcdFx0aWYgKCBkd2FIZWFkZXIuYWNDb21wcmVzc2VkU2l6ZSA+IDAgKSB7XG5cblx0XHRcdFx0c3dpdGNoICggZHdhSGVhZGVyLmFjQ29tcHJlc3Npb24gKSB7XG5cblx0XHRcdFx0XHRjYXNlIFNUQVRJQ19IVUZGTUFOOlxuXG5cdFx0XHRcdFx0XHRhY0J1ZmZlciA9IG5ldyBVaW50MTZBcnJheSggZHdhSGVhZGVyLnRvdGFsQWNVbmNvbXByZXNzZWRDb3VudCApO1xuXHRcdFx0XHRcdFx0aHVmVW5jb21wcmVzcyggaW5mby5hcnJheSwgaW5EYXRhVmlldywgaW5PZmZzZXQsIGR3YUhlYWRlci5hY0NvbXByZXNzZWRTaXplLCBhY0J1ZmZlciwgZHdhSGVhZGVyLnRvdGFsQWNVbmNvbXByZXNzZWRDb3VudCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIERFRkxBVEU6XG5cblx0XHRcdFx0XHRcdGNvbnN0IGNvbXByZXNzZWQgPSBpbmZvLmFycmF5LnNsaWNlKCBpbk9mZnNldC52YWx1ZSwgaW5PZmZzZXQudmFsdWUgKyBkd2FIZWFkZXIudG90YWxBY1VuY29tcHJlc3NlZENvdW50ICk7XG5cdFx0XHRcdFx0XHRjb25zdCBkYXRhID0gZmZsYXRlLnVuemxpYlN5bmMoIGNvbXByZXNzZWQgKTtcblx0XHRcdFx0XHRcdGFjQnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KCBkYXRhLmJ1ZmZlciApO1xuXHRcdFx0XHRcdFx0aW5PZmZzZXQudmFsdWUgKz0gZHdhSGVhZGVyLnRvdGFsQWNVbmNvbXByZXNzZWRDb3VudDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlYWQgRENUIC0gREMgY29tcG9uZW50IGRhdGFcblx0XHRcdGlmICggZHdhSGVhZGVyLmRjQ29tcHJlc3NlZFNpemUgPiAwICkge1xuXG5cdFx0XHRcdGNvbnN0IHpsaWJJbmZvID0ge1xuXHRcdFx0XHRcdGFycmF5OiBpbmZvLmFycmF5LFxuXHRcdFx0XHRcdG9mZnNldDogaW5PZmZzZXQsXG5cdFx0XHRcdFx0c2l6ZTogZHdhSGVhZGVyLmRjQ29tcHJlc3NlZFNpemVcblx0XHRcdFx0fTtcblx0XHRcdFx0ZGNCdWZmZXIgPSBuZXcgVWludDE2QXJyYXkoIHVuY29tcHJlc3NaSVAoIHpsaWJJbmZvICkuYnVmZmVyICk7XG5cdFx0XHRcdGluT2Zmc2V0LnZhbHVlICs9IGR3YUhlYWRlci5kY0NvbXByZXNzZWRTaXplO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlYWQgUkxFIGNvbXByZXNzZWQgZGF0YVxuXHRcdFx0aWYgKCBkd2FIZWFkZXIucmxlUmF3U2l6ZSA+IDAgKSB7XG5cblx0XHRcdFx0Y29uc3QgY29tcHJlc3NlZCA9IGluZm8uYXJyYXkuc2xpY2UoIGluT2Zmc2V0LnZhbHVlLCBpbk9mZnNldC52YWx1ZSArIGR3YUhlYWRlci5ybGVDb21wcmVzc2VkU2l6ZSApO1xuXHRcdFx0XHRjb25zdCBkYXRhID0gZmZsYXRlLnVuemxpYlN5bmMoIGNvbXByZXNzZWQgKTtcblx0XHRcdFx0cmxlQnVmZmVyID0gZGVjb2RlUnVuTGVuZ3RoKCBkYXRhLmJ1ZmZlciApO1xuXG5cdFx0XHRcdGluT2Zmc2V0LnZhbHVlICs9IGR3YUhlYWRlci5ybGVDb21wcmVzc2VkU2l6ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBQcmVwYXJlIG91dGJ1ZmZlciBkYXRhIG9mZnNldFxuXHRcdFx0bGV0IG91dEJ1ZmZlckVuZCA9IDA7XG5cdFx0XHRjb25zdCByb3dPZmZzZXRzID0gbmV3IEFycmF5KCBjaGFubmVsRGF0YS5sZW5ndGggKTtcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHJvd09mZnNldHMubGVuZ3RoOyArKyBpICkge1xuXG5cdFx0XHRcdHJvd09mZnNldHNbIGkgXSA9IG5ldyBBcnJheSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGxldCB5ID0gMDsgeSA8IGluZm8ubGluZXM7ICsrIHkgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGNoYW4gPSAwOyBjaGFuIDwgY2hhbm5lbERhdGEubGVuZ3RoOyArKyBjaGFuICkge1xuXG5cdFx0XHRcdFx0cm93T2Zmc2V0c1sgY2hhbiBdLnB1c2goIG91dEJ1ZmZlckVuZCApO1xuXHRcdFx0XHRcdG91dEJ1ZmZlckVuZCArPSBjaGFubmVsRGF0YVsgY2hhbiBdLndpZHRoICogaW5mby50eXBlICogSU5UMTZfU0laRTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9zc3kgRENUIGRlY29kZSBSR0IgY2hhbm5lbHNcblx0XHRcdGxvc3N5RGN0RGVjb2RlKCBjc2NTZXQsIHJvd09mZnNldHMsIGNoYW5uZWxEYXRhLCBhY0J1ZmZlciwgZGNCdWZmZXIsIG91dEJ1ZmZlciApO1xuXG5cdFx0XHQvLyBEZWNvZGUgb3RoZXIgY2hhbm5lbHNcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGNoYW5uZWxEYXRhLmxlbmd0aDsgKysgaSApIHtcblxuXHRcdFx0XHRjb25zdCBjZCA9IGNoYW5uZWxEYXRhWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjZC5kZWNvZGVkICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2QuY29tcHJlc3Npb24gKSB7XG5cblx0XHRcdFx0XHRjYXNlIFJMRTpcblxuXHRcdFx0XHRcdFx0bGV0IHJvdyA9IDA7XG5cdFx0XHRcdFx0XHRsZXQgcmxlT2Zmc2V0ID0gMDtcblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IHkgPSAwOyB5IDwgaW5mby5saW5lczsgKysgeSApIHtcblxuXHRcdFx0XHRcdFx0XHRsZXQgcm93T2Zmc2V0Qnl0ZXMgPSByb3dPZmZzZXRzWyBpIF1bIHJvdyBdO1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIGxldCB4ID0gMDsgeCA8IGNkLndpZHRoOyArKyB4ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Zm9yICggbGV0IGJ5dGUgPSAwOyBieXRlIDwgSU5UMTZfU0laRSAqIGNkLnR5cGU7ICsrIGJ5dGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdG91dEJ1ZmZlclsgcm93T2Zmc2V0Qnl0ZXMgKysgXSA9IHJsZUJ1ZmZlclsgcmxlT2Zmc2V0ICsgYnl0ZSAqIGNkLndpZHRoICogY2QuaGVpZ2h0IF07XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRybGVPZmZzZXQgKys7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdHJvdyArKztcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgTE9TU1lfRENUOiAvLyBza2lwXG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnRVhSTG9hZGVyLnBhcnNlOiB1bnN1cHBvcnRlZCBjaGFubmVsIGNvbXByZXNzaW9uJyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IERhdGFWaWV3KCBvdXRCdWZmZXIuYnVmZmVyICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZU51bGxUZXJtaW5hdGVkU3RyaW5nKCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdFx0Y29uc3QgdWludEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KCBidWZmZXIgKTtcblx0XHRcdGxldCBlbmRPZmZzZXQgPSAwO1xuXG5cdFx0XHR3aGlsZSAoIHVpbnRCdWZmZXJbIG9mZnNldC52YWx1ZSArIGVuZE9mZnNldCBdICE9IDAgKSB7XG5cblx0XHRcdFx0ZW5kT2Zmc2V0ICs9IDE7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc3RyaW5nVmFsdWUgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoXG5cdFx0XHRcdHVpbnRCdWZmZXIuc2xpY2UoIG9mZnNldC52YWx1ZSwgb2Zmc2V0LnZhbHVlICsgZW5kT2Zmc2V0IClcblx0XHRcdCk7XG5cblx0XHRcdG9mZnNldC52YWx1ZSA9IG9mZnNldC52YWx1ZSArIGVuZE9mZnNldCArIDE7XG5cblx0XHRcdHJldHVybiBzdHJpbmdWYWx1ZTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlRml4ZWRMZW5ndGhTdHJpbmcoIGJ1ZmZlciwgb2Zmc2V0LCBzaXplICkge1xuXG5cdFx0XHRjb25zdCBzdHJpbmdWYWx1ZSA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShcblx0XHRcdFx0bmV3IFVpbnQ4QXJyYXkoIGJ1ZmZlciApLnNsaWNlKCBvZmZzZXQudmFsdWUsIG9mZnNldC52YWx1ZSArIHNpemUgKVxuXHRcdFx0KTtcblxuXHRcdFx0b2Zmc2V0LnZhbHVlID0gb2Zmc2V0LnZhbHVlICsgc2l6ZTtcblxuXHRcdFx0cmV0dXJuIHN0cmluZ1ZhbHVlO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VSYXRpb25hbCggZGF0YVZpZXcsIG9mZnNldCApIHtcblxuXHRcdFx0Y29uc3QgeCA9IHBhcnNlSW50MzIoIGRhdGFWaWV3LCBvZmZzZXQgKTtcblx0XHRcdGNvbnN0IHkgPSBwYXJzZVVpbnQzMiggZGF0YVZpZXcsIG9mZnNldCApO1xuXG5cdFx0XHRyZXR1cm4gWyB4LCB5IF07XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZVRpbWVjb2RlKCBkYXRhVmlldywgb2Zmc2V0ICkge1xuXG5cdFx0XHRjb25zdCB4ID0gcGFyc2VVaW50MzIoIGRhdGFWaWV3LCBvZmZzZXQgKTtcblx0XHRcdGNvbnN0IHkgPSBwYXJzZVVpbnQzMiggZGF0YVZpZXcsIG9mZnNldCApO1xuXG5cdFx0XHRyZXR1cm4gWyB4LCB5IF07XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUludDMyKCBkYXRhVmlldywgb2Zmc2V0ICkge1xuXG5cdFx0XHRjb25zdCBJbnQzMiA9IGRhdGFWaWV3LmdldEludDMyKCBvZmZzZXQudmFsdWUsIHRydWUgKTtcblxuXHRcdFx0b2Zmc2V0LnZhbHVlID0gb2Zmc2V0LnZhbHVlICsgSU5UMzJfU0laRTtcblxuXHRcdFx0cmV0dXJuIEludDMyO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VVaW50MzIoIGRhdGFWaWV3LCBvZmZzZXQgKSB7XG5cblx0XHRcdGNvbnN0IFVpbnQzMiA9IGRhdGFWaWV3LmdldFVpbnQzMiggb2Zmc2V0LnZhbHVlLCB0cnVlICk7XG5cblx0XHRcdG9mZnNldC52YWx1ZSA9IG9mZnNldC52YWx1ZSArIElOVDMyX1NJWkU7XG5cblx0XHRcdHJldHVybiBVaW50MzI7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZVVpbnQ4QXJyYXkoIHVJbnQ4QXJyYXksIG9mZnNldCApIHtcblxuXHRcdFx0Y29uc3QgVWludDggPSB1SW50OEFycmF5WyBvZmZzZXQudmFsdWUgXTtcblxuXHRcdFx0b2Zmc2V0LnZhbHVlID0gb2Zmc2V0LnZhbHVlICsgSU5UOF9TSVpFO1xuXG5cdFx0XHRyZXR1cm4gVWludDg7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZVVpbnQ4KCBkYXRhVmlldywgb2Zmc2V0ICkge1xuXG5cdFx0XHRjb25zdCBVaW50OCA9IGRhdGFWaWV3LmdldFVpbnQ4KCBvZmZzZXQudmFsdWUgKTtcblxuXHRcdFx0b2Zmc2V0LnZhbHVlID0gb2Zmc2V0LnZhbHVlICsgSU5UOF9TSVpFO1xuXG5cdFx0XHRyZXR1cm4gVWludDg7XG5cblx0XHR9XG5cblx0XHRjb25zdCBwYXJzZUludDY0ID0gZnVuY3Rpb24gKCBkYXRhVmlldywgb2Zmc2V0ICkge1xuXG5cdFx0XHRsZXQgaW50O1xuXG5cdFx0XHRpZiAoICdnZXRCaWdJbnQ2NCcgaW4gRGF0YVZpZXcucHJvdG90eXBlICkge1xuXG5cdFx0XHRcdGludCA9IE51bWJlciggZGF0YVZpZXcuZ2V0QmlnSW50NjQoIG9mZnNldC52YWx1ZSwgdHJ1ZSApICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aW50ID0gZGF0YVZpZXcuZ2V0VWludDMyKCBvZmZzZXQudmFsdWUgKyA0LCB0cnVlICkgKyBOdW1iZXIoIGRhdGFWaWV3LmdldFVpbnQzMiggb2Zmc2V0LnZhbHVlLCB0cnVlICkgPDwgMzIgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRvZmZzZXQudmFsdWUgKz0gVUxPTkdfU0laRTtcblxuXHRcdFx0cmV0dXJuIGludDtcblxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBwYXJzZUZsb2F0MzIoIGRhdGFWaWV3LCBvZmZzZXQgKSB7XG5cblx0XHRcdGNvbnN0IGZsb2F0ID0gZGF0YVZpZXcuZ2V0RmxvYXQzMiggb2Zmc2V0LnZhbHVlLCB0cnVlICk7XG5cblx0XHRcdG9mZnNldC52YWx1ZSArPSBGTE9BVDMyX1NJWkU7XG5cblx0XHRcdHJldHVybiBmbG9hdDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRlY29kZUZsb2F0MzIoIGRhdGFWaWV3LCBvZmZzZXQgKSB7XG5cblx0XHRcdHJldHVybiBEYXRhVXRpbHMudG9IYWxmRmxvYXQoIHBhcnNlRmxvYXQzMiggZGF0YVZpZXcsIG9mZnNldCApICk7XG5cblx0XHR9XG5cblx0XHQvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81Njc4NDMyL2RlY29tcHJlc3NpbmctaGFsZi1wcmVjaXNpb24tZmxvYXRzLWluLWphdmFzY3JpcHRcblx0XHRmdW5jdGlvbiBkZWNvZGVGbG9hdDE2KCBiaW5hcnkgKSB7XG5cblx0XHRcdGNvbnN0IGV4cG9uZW50ID0gKCBiaW5hcnkgJiAweDdDMDAgKSA+PiAxMCxcblx0XHRcdFx0ZnJhY3Rpb24gPSBiaW5hcnkgJiAweDAzRkY7XG5cblx0XHRcdHJldHVybiAoIGJpbmFyeSA+PiAxNSA/IC0gMSA6IDEgKSAqIChcblx0XHRcdFx0ZXhwb25lbnQgP1xuXHRcdFx0XHRcdChcblx0XHRcdFx0XHRcdGV4cG9uZW50ID09PSAweDFGID9cblx0XHRcdFx0XHRcdFx0ZnJhY3Rpb24gPyBOYU4gOiBJbmZpbml0eSA6XG5cdFx0XHRcdFx0XHRcdE1hdGgucG93KCAyLCBleHBvbmVudCAtIDE1ICkgKiAoIDEgKyBmcmFjdGlvbiAvIDB4NDAwIClcblx0XHRcdFx0XHQpIDpcblx0XHRcdFx0XHQ2LjEwMzUxNTYyNWUtNSAqICggZnJhY3Rpb24gLyAweDQwMCApXG5cdFx0XHQpO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VVaW50MTYoIGRhdGFWaWV3LCBvZmZzZXQgKSB7XG5cblx0XHRcdGNvbnN0IFVpbnQxNiA9IGRhdGFWaWV3LmdldFVpbnQxNiggb2Zmc2V0LnZhbHVlLCB0cnVlICk7XG5cblx0XHRcdG9mZnNldC52YWx1ZSArPSBJTlQxNl9TSVpFO1xuXG5cdFx0XHRyZXR1cm4gVWludDE2O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VGbG9hdDE2KCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdFx0cmV0dXJuIGRlY29kZUZsb2F0MTYoIHBhcnNlVWludDE2KCBidWZmZXIsIG9mZnNldCApICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUNobGlzdCggZGF0YVZpZXcsIGJ1ZmZlciwgb2Zmc2V0LCBzaXplICkge1xuXG5cdFx0XHRjb25zdCBzdGFydE9mZnNldCA9IG9mZnNldC52YWx1ZTtcblx0XHRcdGNvbnN0IGNoYW5uZWxzID0gW107XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0LnZhbHVlIDwgKCBzdGFydE9mZnNldCArIHNpemUgLSAxICkgKSB7XG5cblx0XHRcdFx0Y29uc3QgbmFtZSA9IHBhcnNlTnVsbFRlcm1pbmF0ZWRTdHJpbmcoIGJ1ZmZlciwgb2Zmc2V0ICk7XG5cdFx0XHRcdGNvbnN0IHBpeGVsVHlwZSA9IHBhcnNlSW50MzIoIGRhdGFWaWV3LCBvZmZzZXQgKTtcblx0XHRcdFx0Y29uc3QgcExpbmVhciA9IHBhcnNlVWludDgoIGRhdGFWaWV3LCBvZmZzZXQgKTtcblx0XHRcdFx0b2Zmc2V0LnZhbHVlICs9IDM7IC8vIHJlc2VydmVkLCB0aHJlZSBjaGFyc1xuXHRcdFx0XHRjb25zdCB4U2FtcGxpbmcgPSBwYXJzZUludDMyKCBkYXRhVmlldywgb2Zmc2V0ICk7XG5cdFx0XHRcdGNvbnN0IHlTYW1wbGluZyA9IHBhcnNlSW50MzIoIGRhdGFWaWV3LCBvZmZzZXQgKTtcblxuXHRcdFx0XHRjaGFubmVscy5wdXNoKCB7XG5cdFx0XHRcdFx0bmFtZTogbmFtZSxcblx0XHRcdFx0XHRwaXhlbFR5cGU6IHBpeGVsVHlwZSxcblx0XHRcdFx0XHRwTGluZWFyOiBwTGluZWFyLFxuXHRcdFx0XHRcdHhTYW1wbGluZzogeFNhbXBsaW5nLFxuXHRcdFx0XHRcdHlTYW1wbGluZzogeVNhbXBsaW5nXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRvZmZzZXQudmFsdWUgKz0gMTtcblxuXHRcdFx0cmV0dXJuIGNoYW5uZWxzO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VDaHJvbWF0aWNpdGllcyggZGF0YVZpZXcsIG9mZnNldCApIHtcblxuXHRcdFx0Y29uc3QgcmVkWCA9IHBhcnNlRmxvYXQzMiggZGF0YVZpZXcsIG9mZnNldCApO1xuXHRcdFx0Y29uc3QgcmVkWSA9IHBhcnNlRmxvYXQzMiggZGF0YVZpZXcsIG9mZnNldCApO1xuXHRcdFx0Y29uc3QgZ3JlZW5YID0gcGFyc2VGbG9hdDMyKCBkYXRhVmlldywgb2Zmc2V0ICk7XG5cdFx0XHRjb25zdCBncmVlblkgPSBwYXJzZUZsb2F0MzIoIGRhdGFWaWV3LCBvZmZzZXQgKTtcblx0XHRcdGNvbnN0IGJsdWVYID0gcGFyc2VGbG9hdDMyKCBkYXRhVmlldywgb2Zmc2V0ICk7XG5cdFx0XHRjb25zdCBibHVlWSA9IHBhcnNlRmxvYXQzMiggZGF0YVZpZXcsIG9mZnNldCApO1xuXHRcdFx0Y29uc3Qgd2hpdGVYID0gcGFyc2VGbG9hdDMyKCBkYXRhVmlldywgb2Zmc2V0ICk7XG5cdFx0XHRjb25zdCB3aGl0ZVkgPSBwYXJzZUZsb2F0MzIoIGRhdGFWaWV3LCBvZmZzZXQgKTtcblxuXHRcdFx0cmV0dXJuIHsgcmVkWDogcmVkWCwgcmVkWTogcmVkWSwgZ3JlZW5YOiBncmVlblgsIGdyZWVuWTogZ3JlZW5ZLCBibHVlWDogYmx1ZVgsIGJsdWVZOiBibHVlWSwgd2hpdGVYOiB3aGl0ZVgsIHdoaXRlWTogd2hpdGVZIH07XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUNvbXByZXNzaW9uKCBkYXRhVmlldywgb2Zmc2V0ICkge1xuXG5cdFx0XHRjb25zdCBjb21wcmVzc2lvbkNvZGVzID0gW1xuXHRcdFx0XHQnTk9fQ09NUFJFU1NJT04nLFxuXHRcdFx0XHQnUkxFX0NPTVBSRVNTSU9OJyxcblx0XHRcdFx0J1pJUFNfQ09NUFJFU1NJT04nLFxuXHRcdFx0XHQnWklQX0NPTVBSRVNTSU9OJyxcblx0XHRcdFx0J1BJWl9DT01QUkVTU0lPTicsXG5cdFx0XHRcdCdQWFIyNF9DT01QUkVTU0lPTicsXG5cdFx0XHRcdCdCNDRfQ09NUFJFU1NJT04nLFxuXHRcdFx0XHQnQjQ0QV9DT01QUkVTU0lPTicsXG5cdFx0XHRcdCdEV0FBX0NPTVBSRVNTSU9OJyxcblx0XHRcdFx0J0RXQUJfQ09NUFJFU1NJT04nXG5cdFx0XHRdO1xuXG5cdFx0XHRjb25zdCBjb21wcmVzc2lvbiA9IHBhcnNlVWludDgoIGRhdGFWaWV3LCBvZmZzZXQgKTtcblxuXHRcdFx0cmV0dXJuIGNvbXByZXNzaW9uQ29kZXNbIGNvbXByZXNzaW9uIF07XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUJveDJpKCBkYXRhVmlldywgb2Zmc2V0ICkge1xuXG5cdFx0XHRjb25zdCB4TWluID0gcGFyc2VVaW50MzIoIGRhdGFWaWV3LCBvZmZzZXQgKTtcblx0XHRcdGNvbnN0IHlNaW4gPSBwYXJzZVVpbnQzMiggZGF0YVZpZXcsIG9mZnNldCApO1xuXHRcdFx0Y29uc3QgeE1heCA9IHBhcnNlVWludDMyKCBkYXRhVmlldywgb2Zmc2V0ICk7XG5cdFx0XHRjb25zdCB5TWF4ID0gcGFyc2VVaW50MzIoIGRhdGFWaWV3LCBvZmZzZXQgKTtcblxuXHRcdFx0cmV0dXJuIHsgeE1pbjogeE1pbiwgeU1pbjogeU1pbiwgeE1heDogeE1heCwgeU1heDogeU1heCB9O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VMaW5lT3JkZXIoIGRhdGFWaWV3LCBvZmZzZXQgKSB7XG5cblx0XHRcdGNvbnN0IGxpbmVPcmRlcnMgPSBbXG5cdFx0XHRcdCdJTkNSRUFTSU5HX1knXG5cdFx0XHRdO1xuXG5cdFx0XHRjb25zdCBsaW5lT3JkZXIgPSBwYXJzZVVpbnQ4KCBkYXRhVmlldywgb2Zmc2V0ICk7XG5cblx0XHRcdHJldHVybiBsaW5lT3JkZXJzWyBsaW5lT3JkZXIgXTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlVjJmKCBkYXRhVmlldywgb2Zmc2V0ICkge1xuXG5cdFx0XHRjb25zdCB4ID0gcGFyc2VGbG9hdDMyKCBkYXRhVmlldywgb2Zmc2V0ICk7XG5cdFx0XHRjb25zdCB5ID0gcGFyc2VGbG9hdDMyKCBkYXRhVmlldywgb2Zmc2V0ICk7XG5cblx0XHRcdHJldHVybiBbIHgsIHkgXTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlVjNmKCBkYXRhVmlldywgb2Zmc2V0ICkge1xuXG5cdFx0XHRjb25zdCB4ID0gcGFyc2VGbG9hdDMyKCBkYXRhVmlldywgb2Zmc2V0ICk7XG5cdFx0XHRjb25zdCB5ID0gcGFyc2VGbG9hdDMyKCBkYXRhVmlldywgb2Zmc2V0ICk7XG5cdFx0XHRjb25zdCB6ID0gcGFyc2VGbG9hdDMyKCBkYXRhVmlldywgb2Zmc2V0ICk7XG5cblx0XHRcdHJldHVybiBbIHgsIHksIHogXTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlVmFsdWUoIGRhdGFWaWV3LCBidWZmZXIsIG9mZnNldCwgdHlwZSwgc2l6ZSApIHtcblxuXHRcdFx0aWYgKCB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnc3RyaW5ndmVjdG9yJyB8fCB0eXBlID09PSAnaWNjUHJvZmlsZScgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHBhcnNlRml4ZWRMZW5ndGhTdHJpbmcoIGJ1ZmZlciwgb2Zmc2V0LCBzaXplICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09ICdjaGxpc3QnICkge1xuXG5cdFx0XHRcdHJldHVybiBwYXJzZUNobGlzdCggZGF0YVZpZXcsIGJ1ZmZlciwgb2Zmc2V0LCBzaXplICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09ICdjaHJvbWF0aWNpdGllcycgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHBhcnNlQ2hyb21hdGljaXRpZXMoIGRhdGFWaWV3LCBvZmZzZXQgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gJ2NvbXByZXNzaW9uJyApIHtcblxuXHRcdFx0XHRyZXR1cm4gcGFyc2VDb21wcmVzc2lvbiggZGF0YVZpZXcsIG9mZnNldCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSAnYm94MmknICkge1xuXG5cdFx0XHRcdHJldHVybiBwYXJzZUJveDJpKCBkYXRhVmlldywgb2Zmc2V0ICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09ICdsaW5lT3JkZXInICkge1xuXG5cdFx0XHRcdHJldHVybiBwYXJzZUxpbmVPcmRlciggZGF0YVZpZXcsIG9mZnNldCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSAnZmxvYXQnICkge1xuXG5cdFx0XHRcdHJldHVybiBwYXJzZUZsb2F0MzIoIGRhdGFWaWV3LCBvZmZzZXQgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gJ3YyZicgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHBhcnNlVjJmKCBkYXRhVmlldywgb2Zmc2V0ICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09ICd2M2YnICkge1xuXG5cdFx0XHRcdHJldHVybiBwYXJzZVYzZiggZGF0YVZpZXcsIG9mZnNldCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSAnaW50JyApIHtcblxuXHRcdFx0XHRyZXR1cm4gcGFyc2VJbnQzMiggZGF0YVZpZXcsIG9mZnNldCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSAncmF0aW9uYWwnICkge1xuXG5cdFx0XHRcdHJldHVybiBwYXJzZVJhdGlvbmFsKCBkYXRhVmlldywgb2Zmc2V0ICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09ICd0aW1lY29kZScgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHBhcnNlVGltZWNvZGUoIGRhdGFWaWV3LCBvZmZzZXQgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gJ3ByZXZpZXcnICkge1xuXG5cdFx0XHRcdG9mZnNldC52YWx1ZSArPSBzaXplO1xuXHRcdFx0XHRyZXR1cm4gJ3NraXBwZWQnO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdG9mZnNldC52YWx1ZSArPSBzaXplO1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUhlYWRlciggZGF0YVZpZXcsIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0XHRjb25zdCBFWFJIZWFkZXIgPSB7fTtcblxuXHRcdFx0aWYgKCBkYXRhVmlldy5nZXRVaW50MzIoIDAsIHRydWUgKSAhPSAyMDAwMDYzMCApIHsgLy8gbWFnaWNcblxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5FWFJMb2FkZXI6IHByb3ZpZGVkIGZpbGUgZG9lc25cXCd0IGFwcGVhciB0byBiZSBpbiBPcGVuRVhSIGZvcm1hdC4nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0RVhSSGVhZGVyLnZlcnNpb24gPSBkYXRhVmlldy5nZXRVaW50OCggNCApO1xuXG5cdFx0XHRjb25zdCBzcGVjID0gZGF0YVZpZXcuZ2V0VWludDgoIDUgKTsgLy8gZnVsbE1hc2tcblxuXHRcdFx0RVhSSGVhZGVyLnNwZWMgPSB7XG5cdFx0XHRcdHNpbmdsZVRpbGU6ICEhICggc3BlYyAmIDIgKSxcblx0XHRcdFx0bG9uZ05hbWU6ICEhICggc3BlYyAmIDQgKSxcblx0XHRcdFx0ZGVlcEZvcm1hdDogISEgKCBzcGVjICYgOCApLFxuXHRcdFx0XHRtdWx0aVBhcnQ6ICEhICggc3BlYyAmIDE2ICksXG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBzdGFydCBvZiBoZWFkZXJcblxuXHRcdFx0b2Zmc2V0LnZhbHVlID0gODsgLy8gc3RhcnQgYXQgOCAtIGFmdGVyIHByZS1hbWJsZVxuXG5cdFx0XHRsZXQga2VlcFJlYWRpbmcgPSB0cnVlO1xuXG5cdFx0XHR3aGlsZSAoIGtlZXBSZWFkaW5nICkge1xuXG5cdFx0XHRcdGNvbnN0IGF0dHJpYnV0ZU5hbWUgPSBwYXJzZU51bGxUZXJtaW5hdGVkU3RyaW5nKCBidWZmZXIsIG9mZnNldCApO1xuXG5cdFx0XHRcdGlmICggYXR0cmlidXRlTmFtZSA9PSAwICkge1xuXG5cdFx0XHRcdFx0a2VlcFJlYWRpbmcgPSBmYWxzZTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc3QgYXR0cmlidXRlVHlwZSA9IHBhcnNlTnVsbFRlcm1pbmF0ZWRTdHJpbmcoIGJ1ZmZlciwgb2Zmc2V0ICk7XG5cdFx0XHRcdFx0Y29uc3QgYXR0cmlidXRlU2l6ZSA9IHBhcnNlVWludDMyKCBkYXRhVmlldywgb2Zmc2V0ICk7XG5cdFx0XHRcdFx0Y29uc3QgYXR0cmlidXRlVmFsdWUgPSBwYXJzZVZhbHVlKCBkYXRhVmlldywgYnVmZmVyLCBvZmZzZXQsIGF0dHJpYnV0ZVR5cGUsIGF0dHJpYnV0ZVNpemUgKTtcblxuXHRcdFx0XHRcdGlmICggYXR0cmlidXRlVmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCBgRVhSTG9hZGVyLnBhcnNlOiBza2lwcGVkIHVua25vd24gaGVhZGVyIGF0dHJpYnV0ZSB0eXBlIFxcJyR7YXR0cmlidXRlVHlwZX1cXCcuYCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0RVhSSGVhZGVyWyBhdHRyaWJ1dGVOYW1lIF0gPSBhdHRyaWJ1dGVWYWx1ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCAoIHNwZWMgJiB+IDB4MDQgKSAhPSAwICkgeyAvLyB1bnN1cHBvcnRlZCB0aWxlZCwgZGVlcC1pbWFnZSwgbXVsdGktcGFydFxuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdFWFJIZWFkZXI6JywgRVhSSGVhZGVyICk7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkVYUkxvYWRlcjogcHJvdmlkZWQgZmlsZSBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBFWFJIZWFkZXI7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzZXR1cERlY29kZXIoIEVYUkhlYWRlciwgZGF0YVZpZXcsIHVJbnQ4QXJyYXksIG9mZnNldCwgb3V0cHV0VHlwZSApIHtcblxuXHRcdFx0Y29uc3QgRVhSRGVjb2RlciA9IHtcblx0XHRcdFx0c2l6ZTogMCxcblx0XHRcdFx0dmlld2VyOiBkYXRhVmlldyxcblx0XHRcdFx0YXJyYXk6IHVJbnQ4QXJyYXksXG5cdFx0XHRcdG9mZnNldDogb2Zmc2V0LFxuXHRcdFx0XHR3aWR0aDogRVhSSGVhZGVyLmRhdGFXaW5kb3cueE1heCAtIEVYUkhlYWRlci5kYXRhV2luZG93LnhNaW4gKyAxLFxuXHRcdFx0XHRoZWlnaHQ6IEVYUkhlYWRlci5kYXRhV2luZG93LnlNYXggLSBFWFJIZWFkZXIuZGF0YVdpbmRvdy55TWluICsgMSxcblx0XHRcdFx0Y2hhbm5lbHM6IEVYUkhlYWRlci5jaGFubmVscy5sZW5ndGgsXG5cdFx0XHRcdGJ5dGVzUGVyTGluZTogbnVsbCxcblx0XHRcdFx0bGluZXM6IG51bGwsXG5cdFx0XHRcdGlucHV0U2l6ZTogbnVsbCxcblx0XHRcdFx0dHlwZTogRVhSSGVhZGVyLmNoYW5uZWxzWyAwIF0ucGl4ZWxUeXBlLFxuXHRcdFx0XHR1bmNvbXByZXNzOiBudWxsLFxuXHRcdFx0XHRnZXR0ZXI6IG51bGwsXG5cdFx0XHRcdGZvcm1hdDogbnVsbCxcblx0XHRcdFx0Y29sb3JTcGFjZTogTGluZWFyU1JHQkNvbG9yU3BhY2UsXG5cdFx0XHR9O1xuXG5cdFx0XHRzd2l0Y2ggKCBFWFJIZWFkZXIuY29tcHJlc3Npb24gKSB7XG5cblx0XHRcdFx0Y2FzZSAnTk9fQ09NUFJFU1NJT04nOlxuXHRcdFx0XHRcdEVYUkRlY29kZXIubGluZXMgPSAxO1xuXHRcdFx0XHRcdEVYUkRlY29kZXIudW5jb21wcmVzcyA9IHVuY29tcHJlc3NSQVc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnUkxFX0NPTVBSRVNTSU9OJzpcblx0XHRcdFx0XHRFWFJEZWNvZGVyLmxpbmVzID0gMTtcblx0XHRcdFx0XHRFWFJEZWNvZGVyLnVuY29tcHJlc3MgPSB1bmNvbXByZXNzUkxFO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1pJUFNfQ09NUFJFU1NJT04nOlxuXHRcdFx0XHRcdEVYUkRlY29kZXIubGluZXMgPSAxO1xuXHRcdFx0XHRcdEVYUkRlY29kZXIudW5jb21wcmVzcyA9IHVuY29tcHJlc3NaSVA7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnWklQX0NPTVBSRVNTSU9OJzpcblx0XHRcdFx0XHRFWFJEZWNvZGVyLmxpbmVzID0gMTY7XG5cdFx0XHRcdFx0RVhSRGVjb2Rlci51bmNvbXByZXNzID0gdW5jb21wcmVzc1pJUDtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdQSVpfQ09NUFJFU1NJT04nOlxuXHRcdFx0XHRcdEVYUkRlY29kZXIubGluZXMgPSAzMjtcblx0XHRcdFx0XHRFWFJEZWNvZGVyLnVuY29tcHJlc3MgPSB1bmNvbXByZXNzUElaO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1BYUjI0X0NPTVBSRVNTSU9OJzpcblx0XHRcdFx0XHRFWFJEZWNvZGVyLmxpbmVzID0gMTY7XG5cdFx0XHRcdFx0RVhSRGVjb2Rlci51bmNvbXByZXNzID0gdW5jb21wcmVzc1BYUjtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdEV0FBX0NPTVBSRVNTSU9OJzpcblx0XHRcdFx0XHRFWFJEZWNvZGVyLmxpbmVzID0gMzI7XG5cdFx0XHRcdFx0RVhSRGVjb2Rlci51bmNvbXByZXNzID0gdW5jb21wcmVzc0RXQTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdEV0FCX0NPTVBSRVNTSU9OJzpcblx0XHRcdFx0XHRFWFJEZWNvZGVyLmxpbmVzID0gMjU2O1xuXHRcdFx0XHRcdEVYUkRlY29kZXIudW5jb21wcmVzcyA9IHVuY29tcHJlc3NEV0E7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdFWFJMb2FkZXIucGFyc2U6ICcgKyBFWFJIZWFkZXIuY29tcHJlc3Npb24gKyAnIGlzIHVuc3VwcG9ydGVkJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdEVYUkRlY29kZXIuc2NhbmxpbmVCbG9ja1NpemUgPSBFWFJEZWNvZGVyLmxpbmVzO1xuXG5cdFx0XHRpZiAoIEVYUkRlY29kZXIudHlwZSA9PSAxICkge1xuXG5cdFx0XHRcdC8vIGhhbGZcblx0XHRcdFx0c3dpdGNoICggb3V0cHV0VHlwZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgRmxvYXRUeXBlOlxuXHRcdFx0XHRcdFx0RVhSRGVjb2Rlci5nZXR0ZXIgPSBwYXJzZUZsb2F0MTY7XG5cdFx0XHRcdFx0XHRFWFJEZWNvZGVyLmlucHV0U2l6ZSA9IElOVDE2X1NJWkU7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgSGFsZkZsb2F0VHlwZTpcblx0XHRcdFx0XHRcdEVYUkRlY29kZXIuZ2V0dGVyID0gcGFyc2VVaW50MTY7XG5cdFx0XHRcdFx0XHRFWFJEZWNvZGVyLmlucHV0U2l6ZSA9IElOVDE2X1NJWkU7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIEVYUkRlY29kZXIudHlwZSA9PSAyICkge1xuXG5cdFx0XHRcdC8vIGZsb2F0XG5cdFx0XHRcdHN3aXRjaCAoIG91dHB1dFR5cGUgKSB7XG5cblx0XHRcdFx0XHRjYXNlIEZsb2F0VHlwZTpcblx0XHRcdFx0XHRcdEVYUkRlY29kZXIuZ2V0dGVyID0gcGFyc2VGbG9hdDMyO1xuXHRcdFx0XHRcdFx0RVhSRGVjb2Rlci5pbnB1dFNpemUgPSBGTE9BVDMyX1NJWkU7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgSGFsZkZsb2F0VHlwZTpcblx0XHRcdFx0XHRcdEVYUkRlY29kZXIuZ2V0dGVyID0gZGVjb2RlRmxvYXQzMjtcblx0XHRcdFx0XHRcdEVYUkRlY29kZXIuaW5wdXRTaXplID0gRkxPQVQzMl9TSVpFO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdFWFJMb2FkZXIucGFyc2U6IHVuc3VwcG9ydGVkIHBpeGVsVHlwZSAnICsgRVhSRGVjb2Rlci50eXBlICsgJyBmb3IgJyArIEVYUkhlYWRlci5jb21wcmVzc2lvbiArICcuJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdEVYUkRlY29kZXIuYmxvY2tDb3VudCA9ICggRVhSSGVhZGVyLmRhdGFXaW5kb3cueU1heCArIDEgKSAvIEVYUkRlY29kZXIuc2NhbmxpbmVCbG9ja1NpemU7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IEVYUkRlY29kZXIuYmxvY2tDb3VudDsgaSArKyApXG5cdFx0XHRcdHBhcnNlSW50NjQoIGRhdGFWaWV3LCBvZmZzZXQgKTsgLy8gc2NhbmxpbmVPZmZzZXRcblxuXHRcdFx0Ly8gd2Ugc2hvdWxkIGJlIHBhc3NlZCB0aGUgc2NhbmxpbmUgb2Zmc2V0IHRhYmxlLCByZWFkeSB0byBzdGFydCByZWFkaW5nIHBpeGVsIGRhdGEuXG5cblx0XHRcdC8vIFJHQiBpbWFnZXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gUkdCQSBmb3JtYXQsIHByZXZlbnRpbmcgc29mdHdhcmUgZW11bGF0aW9uIGluIHNlbGVjdCBkZXZpY2VzLlxuXHRcdFx0RVhSRGVjb2Rlci5vdXRwdXRDaGFubmVscyA9ICggKCBFWFJEZWNvZGVyLmNoYW5uZWxzID09IDMgKSA/IDQgOiBFWFJEZWNvZGVyLmNoYW5uZWxzICk7XG5cdFx0XHRjb25zdCBzaXplID0gRVhSRGVjb2Rlci53aWR0aCAqIEVYUkRlY29kZXIuaGVpZ2h0ICogRVhSRGVjb2Rlci5vdXRwdXRDaGFubmVscztcblxuXHRcdFx0c3dpdGNoICggb3V0cHV0VHlwZSApIHtcblxuXHRcdFx0XHRjYXNlIEZsb2F0VHlwZTpcblx0XHRcdFx0XHRFWFJEZWNvZGVyLmJ5dGVBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIHNpemUgKTtcblxuXHRcdFx0XHRcdC8vIEZpbGwgaW5pdGlhbGx5IHdpdGggMXMgZm9yIHRoZSBhbHBoYSB2YWx1ZSBpZiB0aGUgdGV4dHVyZSBpcyBub3QgUkdCQSwgUkdCIHZhbHVlcyB3aWxsIGJlIG92ZXJ3cml0dGVuXG5cdFx0XHRcdFx0aWYgKCBFWFJEZWNvZGVyLmNoYW5uZWxzIDwgRVhSRGVjb2Rlci5vdXRwdXRDaGFubmVscyApXG5cdFx0XHRcdFx0XHRFWFJEZWNvZGVyLmJ5dGVBcnJheS5maWxsKCAxLCAwLCBzaXplICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIEhhbGZGbG9hdFR5cGU6XG5cdFx0XHRcdFx0RVhSRGVjb2Rlci5ieXRlQXJyYXkgPSBuZXcgVWludDE2QXJyYXkoIHNpemUgKTtcblxuXHRcdFx0XHRcdGlmICggRVhSRGVjb2Rlci5jaGFubmVscyA8IEVYUkRlY29kZXIub3V0cHV0Q2hhbm5lbHMgKVxuXHRcdFx0XHRcdFx0RVhSRGVjb2Rlci5ieXRlQXJyYXkuZmlsbCggMHgzQzAwLCAwLCBzaXplICk7IC8vIFVpbnQxNkFycmF5IGhvbGRzIGhhbGYgZmxvYXQgZGF0YSwgMHgzQzAwIGlzIDFcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkVYUkxvYWRlcjogdW5zdXBwb3J0ZWQgdHlwZTogJywgb3V0cHV0VHlwZSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdEVYUkRlY29kZXIuYnl0ZXNQZXJMaW5lID0gRVhSRGVjb2Rlci53aWR0aCAqIEVYUkRlY29kZXIuaW5wdXRTaXplICogRVhSRGVjb2Rlci5jaGFubmVscztcblxuXHRcdFx0aWYgKCBFWFJEZWNvZGVyLm91dHB1dENoYW5uZWxzID09IDQgKSB7XG5cblx0XHRcdFx0RVhSRGVjb2Rlci5mb3JtYXQgPSBSR0JBRm9ybWF0O1xuXHRcdFx0XHRFWFJEZWNvZGVyLmNvbG9yU3BhY2UgPSBMaW5lYXJTUkdCQ29sb3JTcGFjZTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRFWFJEZWNvZGVyLmZvcm1hdCA9IFJlZEZvcm1hdDtcblx0XHRcdFx0RVhSRGVjb2Rlci5jb2xvclNwYWNlID0gTm9Db2xvclNwYWNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBFWFJEZWNvZGVyO1xuXG5cdFx0fVxuXG5cdFx0Ly8gc3RhcnQgcGFyc2luZyBmaWxlIFtTVEFSVF1cblxuXHRcdGNvbnN0IGJ1ZmZlckRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KCBidWZmZXIgKTtcblx0XHRjb25zdCB1SW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoIGJ1ZmZlciApO1xuXHRcdGNvbnN0IG9mZnNldCA9IHsgdmFsdWU6IDAgfTtcblxuXHRcdC8vIGdldCBoZWFkZXIgaW5mb3JtYXRpb24gYW5kIHZhbGlkYXRlIGZvcm1hdC5cblx0XHRjb25zdCBFWFJIZWFkZXIgPSBwYXJzZUhlYWRlciggYnVmZmVyRGF0YVZpZXcsIGJ1ZmZlciwgb2Zmc2V0ICk7XG5cblx0XHQvLyBnZXQgaW5wdXQgY29tcHJlc3Npb24gaW5mb3JtYXRpb24gYW5kIHByZXBhcmUgZGVjb2RpbmcuXG5cdFx0Y29uc3QgRVhSRGVjb2RlciA9IHNldHVwRGVjb2RlciggRVhSSGVhZGVyLCBidWZmZXJEYXRhVmlldywgdUludDhBcnJheSwgb2Zmc2V0LCB0aGlzLnR5cGUgKTtcblxuXHRcdGNvbnN0IHRtcE9mZnNldCA9IHsgdmFsdWU6IDAgfTtcblx0XHRjb25zdCBjaGFubmVsT2Zmc2V0cyA9IHsgUjogMCwgRzogMSwgQjogMiwgQTogMywgWTogMCB9O1xuXG5cdFx0Zm9yICggbGV0IHNjYW5saW5lQmxvY2tJZHggPSAwOyBzY2FubGluZUJsb2NrSWR4IDwgRVhSRGVjb2Rlci5oZWlnaHQgLyBFWFJEZWNvZGVyLnNjYW5saW5lQmxvY2tTaXplOyBzY2FubGluZUJsb2NrSWR4ICsrICkge1xuXG5cdFx0XHRjb25zdCBsaW5lID0gcGFyc2VVaW50MzIoIGJ1ZmZlckRhdGFWaWV3LCBvZmZzZXQgKTsgLy8gbGluZV9ub1xuXHRcdFx0RVhSRGVjb2Rlci5zaXplID0gcGFyc2VVaW50MzIoIGJ1ZmZlckRhdGFWaWV3LCBvZmZzZXQgKTsgLy8gZGF0YV9sZW5cblx0XHRcdEVYUkRlY29kZXIubGluZXMgPSAoICggbGluZSArIEVYUkRlY29kZXIuc2NhbmxpbmVCbG9ja1NpemUgPiBFWFJEZWNvZGVyLmhlaWdodCApID8gKCBFWFJEZWNvZGVyLmhlaWdodCAtIGxpbmUgKSA6IEVYUkRlY29kZXIuc2NhbmxpbmVCbG9ja1NpemUgKTtcblxuXHRcdFx0Y29uc3QgaXNDb21wcmVzc2VkID0gRVhSRGVjb2Rlci5zaXplIDwgRVhSRGVjb2Rlci5saW5lcyAqIEVYUkRlY29kZXIuYnl0ZXNQZXJMaW5lO1xuXHRcdFx0Y29uc3Qgdmlld2VyID0gaXNDb21wcmVzc2VkID8gRVhSRGVjb2Rlci51bmNvbXByZXNzKCBFWFJEZWNvZGVyICkgOiB1bmNvbXByZXNzUkFXKCBFWFJEZWNvZGVyICk7XG5cblx0XHRcdG9mZnNldC52YWx1ZSArPSBFWFJEZWNvZGVyLnNpemU7XG5cblx0XHRcdGZvciAoIGxldCBsaW5lX3kgPSAwOyBsaW5lX3kgPCBFWFJEZWNvZGVyLnNjYW5saW5lQmxvY2tTaXplOyBsaW5lX3kgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgdHJ1ZV95ID0gbGluZV95ICsgc2NhbmxpbmVCbG9ja0lkeCAqIEVYUkRlY29kZXIuc2NhbmxpbmVCbG9ja1NpemU7XG5cdFx0XHRcdGlmICggdHJ1ZV95ID49IEVYUkRlY29kZXIuaGVpZ2h0ICkgYnJlYWs7XG5cblx0XHRcdFx0Zm9yICggbGV0IGNoYW5uZWxJRCA9IDA7IGNoYW5uZWxJRCA8IEVYUkRlY29kZXIuY2hhbm5lbHM7IGNoYW5uZWxJRCArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGNPZmYgPSBjaGFubmVsT2Zmc2V0c1sgRVhSSGVhZGVyLmNoYW5uZWxzWyBjaGFubmVsSUQgXS5uYW1lIF07XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgeCA9IDA7IHggPCBFWFJEZWNvZGVyLndpZHRoOyB4ICsrICkge1xuXG5cdFx0XHRcdFx0XHR0bXBPZmZzZXQudmFsdWUgPSAoIGxpbmVfeSAqICggRVhSRGVjb2Rlci5jaGFubmVscyAqIEVYUkRlY29kZXIud2lkdGggKSArIGNoYW5uZWxJRCAqIEVYUkRlY29kZXIud2lkdGggKyB4ICkgKiBFWFJEZWNvZGVyLmlucHV0U2l6ZTtcblx0XHRcdFx0XHRcdGNvbnN0IG91dEluZGV4ID0gKCBFWFJEZWNvZGVyLmhlaWdodCAtIDEgLSB0cnVlX3kgKSAqICggRVhSRGVjb2Rlci53aWR0aCAqIEVYUkRlY29kZXIub3V0cHV0Q2hhbm5lbHMgKSArIHggKiBFWFJEZWNvZGVyLm91dHB1dENoYW5uZWxzICsgY09mZjtcblx0XHRcdFx0XHRcdEVYUkRlY29kZXIuYnl0ZUFycmF5WyBvdXRJbmRleCBdID0gRVhSRGVjb2Rlci5nZXR0ZXIoIHZpZXdlciwgdG1wT2Zmc2V0ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0aGVhZGVyOiBFWFJIZWFkZXIsXG5cdFx0XHR3aWR0aDogRVhSRGVjb2Rlci53aWR0aCxcblx0XHRcdGhlaWdodDogRVhSRGVjb2Rlci5oZWlnaHQsXG5cdFx0XHRkYXRhOiBFWFJEZWNvZGVyLmJ5dGVBcnJheSxcblx0XHRcdGZvcm1hdDogRVhSRGVjb2Rlci5mb3JtYXQsXG5cdFx0XHRjb2xvclNwYWNlOiBFWFJEZWNvZGVyLmNvbG9yU3BhY2UsXG5cdFx0XHR0eXBlOiB0aGlzLnR5cGUsXG5cdFx0fTtcblxuXHR9XG5cblx0c2V0RGF0YVR5cGUoIHZhbHVlICkge1xuXG5cdFx0dGhpcy50eXBlID0gdmFsdWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGxvYWQoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0ZnVuY3Rpb24gb25Mb2FkQ2FsbGJhY2soIHRleHR1cmUsIHRleERhdGEgKSB7XG5cblx0XHRcdHRleHR1cmUuY29sb3JTcGFjZSA9IHRleERhdGEuY29sb3JTcGFjZTtcblx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xuXHRcdFx0dGV4dHVyZS5tYWdGaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XG5cdFx0XHR0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXHRcdFx0dGV4dHVyZS5mbGlwWSA9IGZhbHNlO1xuXG5cdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSwgdGV4RGF0YSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN1cGVyLmxvYWQoIHVybCwgb25Mb2FkQ2FsbGJhY2ssIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgRVhSTG9hZGVyIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/three/examples/jsm/loaders/EXRLoader.js\n"));

/***/ })

});